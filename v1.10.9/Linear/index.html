<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear · LowLevelFEM</title><meta name="title" content="Linear · LowLevelFEM"/><meta property="og:title" content="Linear · LowLevelFEM"/><meta property="twitter:title" content="Linear · LowLevelFEM"/><meta name="description" content="Documentation for LowLevelFEM."/><meta property="og:description" content="Documentation for LowLevelFEM."/><meta property="twitter:description" content="Documentation for LowLevelFEM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelFEM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../General/">General</a></li><li class="is-active"><a class="tocitem" href>Linear</a></li><li><a class="tocitem" href="../Heat/">Heat</a></li><li><a class="tocitem" href="../Nonlinear/">Nonlinear</a></li><li><a class="tocitem" href="../Operators/">Operators</a></li></ul></li><li><a class="tocitem" href="../Examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Linear</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/main/docs/src/Linear.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Mechanics"><a class="docs-heading-anchor" href="#Linear-Mechanics">Linear Mechanics</a><a id="Linear-Mechanics-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Mechanics" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDM-NTuple{8, Any}" href="#LowLevelFEM.CDM-NTuple{8, Any}"><code>LowLevelFEM.CDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CDM(K, M, C, f, u0, v0, T, Δt)</code></pre><p>Solves a transient dynamic problem using central difference method (CDM) (explicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>C</code> is the damping matrix, <code>f</code> is the load vector, <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the upper bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time step size. Returns the displacement vectors and velocity vectors in each time step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code> of the time instants used.</p><p>The critical (largest allowed) time step is <code>Δtₘₐₓ = Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ)</code> where <code>Tₘᵢₙ</code> is the time period of the largest eigenfrequency and <code>ξₘₐₓ</code> is the largest modal damping.</p><p>Return: <code>u</code>, <code>v</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>C</code>: SystemMatrix</li><li><code>f</code>: VectorField</li><li><code>u0</code>: VectorField</li><li><code>v0</code>: VectorField</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>u</code>: VectorField</li><li><code>v</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5576-L5604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the CDM method.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:PDR</code>: physical damping ratio</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. The damping matrix is assembled in the  following ways: <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. If <code>show_β</code> or <code>show_ξ</code> is <code>true</code>, the corresponding <code>β</code> or <code>ξ</code> values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>show_β</code>: Boolean</li><li><code>show_ξ</code>: Boolean</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5738-L5776">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHT-NTuple{7, Any}" href="#LowLevelFEM.HHT-NTuple{7, Any}"><code>LowLevelFEM.HHT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HHT(K, M, f, u0, v0, T, Δt; α=..., δ=..., γ=..., β=...)</code></pre><p>Solves a transient dynamic problem using HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (implicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>f</code> is the load vector,  <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the  upper bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time  step size. Returns the displacement vectors and velocity vectors in each time  step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code>  of the time instants used. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)².</p><p>Return: <code>u</code>, <code>v</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>f</code>: VectorField</li><li><code>u0</code>: VectorField</li><li><code>v0</code>: VectorField</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>u</code>: VectorField</li><li><code>v</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5651-L5683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> and <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5835-L5869">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3205-L3219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(heatCondMat, heatCapMat, heatFluxVec, supports)</code></pre><p>Applies boundary conditions <code>supports</code> on a heat conduction matrix <code>heatCondMat</code>, heat capacity matrix <code>heatCapMat</code> and heat flux vector <code>heatFluxVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed temperature <code>T</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3264-L3277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(stiffMat, massMat, dampMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code>, mass matrix <code>massMat</code>, damping matrix <code>dampMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>massMat</code>: SystemMatrix </li><li><code>dampMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3312-L3328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{Problem, Matrix, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{Problem, Matrix, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(dispVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a displacement vector <code>dispVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dispVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3482-L3495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions(stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>. Creates a new stiffness matrix and load vector.</p><p>Returns: <code>stiffMat</code>, <code>loadVec</code></p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3233-L3247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}" href="#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}"><code>LowLevelFEM.applyElasticSupport!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyElasticSupport!(stiffMat, elastSupp)</code></pre><p>Applies elastic support boundary conditions <code>elastSupp</code> on a stiffness matrix <code>stiffMat</code>. Mesh details are in <code>problem</code>. <code>elastSupp</code> is a tuple of <code>name</code> of physical group and prescribed <code>kx</code>, <code>ky</code> and <code>kz</code> stiffnesses.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>elastSupp</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3552-L3564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}" href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)</code></pre><p>Generates the damping matrix for proportional damping. C = αM + βK, or C = αM + β₁K + β₂KM⁻¹K + β₃KM⁻¹KM⁻¹K + ⋯. The latter corresponds to a damping characteristic given by a power series in the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the arguments) are the values of the individual terms of the series at ωₘₐₓ. βᵢ (<code>β</code> in the arguments) are the coefficients of the series. Either <code>ξ</code> or <code>β</code> must be specified; each may be a scalar or a vector. <code>K</code> is the stiffness matrix, <code>M</code> is the mass matrix, and <code>ωₘₐₓ</code> is the largest natural frequency.</p><p>Returns: <code>dampingMatrix</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>α</code>: Float64</li><li><code>ξ</code>: Float64 or Vector{Float64}</li><li><code>β</code>: Float64 or Vector{Float64}</li><li><code>dampingMatrix</code>: SystemMatrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">K = stiffnessMatrix(problem)
M = massMatrix(problem; lumped=true)
ωmax = 2π * 1000
C = dampingMatrix(K, M, ωmax; α=0.0, ξ=[0.02, 0.02])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L2784-L2814">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}" href="#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}"><code>LowLevelFEM.elasticSupportMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elasticSupportMatrix(problem, elSupp)</code></pre><p>Solves the elastic support matrix of the <code>problem</code>. <code>elSupp</code> is a vector of elastic supports defined in function <code>elasticSupport</code>. With the displacementent vector <code>q</code> in hand the reaction force vector <code>fR</code> arising from the elastic support can be solved. (<code>fR = heatConvMat * q</code>)</p><p>Return: <code>elSuppMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>elSupp</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>elSuppMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L2841-L2855">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getTagForPhysicalName-Tuple{Any}" href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getTagForPhysicalName(name)</code></pre><p>Returns <code>tags</code> of elements of physical group <code>name</code>.</p><p>Returns: <code>tags</code></p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>tags</code>: Vector{Integer}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3289-L3299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement!-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialDisplacement!(name, u0; ux=..., uy=..., uz=...)</code></pre><p>Changes the displacement values to <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in displacement vector <code>u0</code>.</p><p>Return: u0</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li><li><code>u0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5356-L5371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialDisplacement(problem, name; ux=..., uy=..., uz=...)</code></pre><p>Sets the displacement values <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial displacement vector <code>u0</code>.</p><p>Return: u0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>u0</code>: VectorField</li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5308-L5324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity!-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialVelocity!(name, v0; vx=..., vy=..., vz=...)</code></pre><p>Changes the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in velocity vector <code>v0</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>v0</code>: VectorField</li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5416-L5431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialVelocity(problem, name; vx=..., vy=..., vz=...)</code></pre><p>Sets the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial velocity vector <code>v0</code>.</p><p>Return: v0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li><li><code>v0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5395-L5411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestEigenValue-Tuple{Any, Any}" href="#LowLevelFEM.largestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.largestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">largestEigenValue(K, M)</code></pre><p>Solves the smallest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘᵢₙ</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>λₘᵢₙ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5552-L5564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">largestPeriodTime(K, M)</code></pre><p>Solves the largest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5476-L5488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.loadVector-Tuple{Any, Any}" href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadVector(problem, loads)</code></pre><p>Solves a load vector of <code>problem</code>. <code>loads</code> is a tuple of name of physical group  <code>name</code>, coordinates <code>fx</code>, <code>fy</code> and <code>fz</code> or pressure <code>p</code> which are intensities of a distributed force. It can solve traction or body force depending on the problem.</p><ul><li>In case of 2D problems and Point physical group means concentrated force.</li><li>In case of 2D problems and Line physical group means surface force.</li><li>In case of 2D problems and Surface physical group means body force.</li><li>In case of 3D problems and Point physical group means concentrated force.</li><li>In case of 3D problems and Line physical group means edge force.</li><li>In case of 3D problems and Surface physical group means surface force.</li><li>In case of 3D problems and Volume physical group means body force.</li></ul><p>Return: <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>loadVec</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3000-L3020">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.massMatrix-Tuple{Any}" href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">massMatrix(problem; lumped=...)</code></pre><p>Solves the mass matrix of the <code>problem</code>. If <code>lumped</code> is true, computes the lumped mass matrix.</p><p>Returns: <code>massMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>lumped</code>: Boolean</li><li><code>massMat</code>: SystemMatrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">M = massMatrix(problem; lumped=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L1824-L1841">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalAcceleration!-Tuple{Any}" href="#LowLevelFEM.nodalAcceleration!-Tuple{Any}"><code>LowLevelFEM.nodalAcceleration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodalAcceleration!(name, a0; ax=..., ay=..., az=...)</code></pre><p>Changes the acceleration values <code>ax</code>, <code>ay</code> and <code>az</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in acceleration vector <code>a0</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>a0</code>: VectorField</li><li><code>ax</code>: Float64</li><li><code>ay</code>: Float64</li><li><code>az</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5456-L5471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalForce!-Tuple{Any}" href="#LowLevelFEM.nodalForce!-Tuple{Any}"><code>LowLevelFEM.nodalForce!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodalForce!(name, f0; fx=..., fy=..., fz=...)</code></pre><p>Changes the force values <code>fx</code>, <code>fy</code> and <code>fz</code> (depending on the dimension of the problem) at nodes belonging to physical group <code>name</code>. Original values are in load vector <code>f0</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>f0</code>: VectorField</li><li><code>fx</code>: Float64 </li><li><code>fy</code>: Float64 </li><li><code>fz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5436-L5451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.nonLinearStiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonLinearStiffnessMatrix(problem, q)</code></pre><p>Solves the nonlinear stiffness matrix of the <code>problem</code>. <code>q</code> is a displacement field.</p><p>Returns: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: VectorField</li><li><code>stiffMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L1537-L1548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestEigenValue-Tuple{Any, Any}" href="#LowLevelFEM.smallestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.smallestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smallestEigenValue(K, M)</code></pre><p>Solves the largest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘₐₓ</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>λₘₐₓ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5526-L5538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smallestPeriodTime(K, M)</code></pre><p>Solves the smallest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5502-L5514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveAxialForce-Tuple{VectorField}" href="#LowLevelFEM.solveAxialForce-Tuple{VectorField}"><code>LowLevelFEM.solveAxialForce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveAxialForce(u::VectorField)</code></pre><p>Compute axial (bar/truss) forces from a displacement field.</p><p>The input displacement field <code>u</code> must be nodal (VectorField), typically containing the nodal displacements of a truss or bar structure.   The output is a scalar field (ScalarField), where each value represents  the axial force in a truss element.</p><p><strong>Arguments</strong></p><ul><li><code>u::VectorField</code>: nodal displacement field.</li></ul><p><strong>Returns</strong></p><ul><li><code>ScalarField</code>: axial forces defined per element.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">u = solveDisplacement(problem, [loads], [supports])  # VectorField of nodal displacements
N = solveAxialForce(u)                               # ScalarField of axial element forces</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L4917-L4938">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveBuckling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveBuckling(problem, loads, constraints; n=6)</code></pre><p>Solves the multipliers for the first <code>n</code> critical forces and the corresponding  buckling shapes for the instability of the <code>problem</code>, when <code>loads</code> and  <code>constraints</code> are applied. Result can be presented by <code>showBucklingResults</code> function. <code>loads</code> and <code>constraints</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively.</p><p>Return: <code>buckling</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{tuples}</li><li><code>constraints</code>: Vector{tuples}</li><li><code>n</code>: Int64</li><li><code>buckling</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5265-L5282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBucklingModes-Tuple{Any, Any}" href="#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}"><code>LowLevelFEM.solveBucklingModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveBucklingModes(K, Knl; n=6)</code></pre><p>Solves the critical force multipliers and buckling mode shapes of a problem given by stiffness matrix <code>K</code> and the nonlinear stiffness matrix <code>Knl</code>. <code>n</code> is the number of buckling modes to solve. Returns the struct of critical forces and buckling modes. Results can be presented by <code>showBucklingResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>Knl</code>: SystemMatrix</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5156-L5170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-NTuple{4, Any}" href="#LowLevelFEM.solveDisplacement-NTuple{4, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(problem, load, supp, elSupp;
                  condensed = false,
                  iterative = false,
                  reltol::Real = sqrt(eps()),
                  maxiter::Int = problem.non * problem.dim,
                  preconditioner = Identity(),
                  ordering=true)</code></pre><p>Computes the displacement vector <code>q</code> for the given <code>problem</code> subject to  loads <code>load</code>, supports <code>supp</code> and elastic supports <code>elSupp</code>. When <code>condensed</code> is <code>true</code>, the  reduced stiffness matrix and load vector are used in the solution. (see <code>load</code>, <code>displacementConstraint</code> and <code>elasticSupport</code>) If <code>iterative</code> is true, conjugate gradient method will be used with <code>reltol</code> and <code>maxiter</code> (see <code>cg</code> in the <code>IterativeSolvers</code> package) If <code>ordering</code> is false, no culomn ordering will be performed in the stiffness matrix. In this case it is advisable to use the <code>bandwidth</code> option when define <code>Problem</code>. (see <code>lu</code> in <code>LinearAlgebra</code> package, <code>q=nothing</code> option)</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>load</code>: Vector{Tuple} </li><li><code>supp</code>: Vector{Tuple}</li><li><code>elSupp</code>: Vector{Tuple}</li><li><code>condensed</code>: Boolean</li><li><code>iterative</code>: Boolean</li><li><code>maxiter</code>: Int</li><li><code>reltol</code>: Real</li><li><code>preconditioner</code>: preconditioner object (made by eg. <code>ilu</code> or <code>ichol</code>)</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3599-L3631">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(problem, load, supp;
                  condensed = false,
                  iterative = false,
                  reltol::Real = sqrt(eps()),
                  maxiter::Int = problem.non * problem.dim,
                  preconditioner = Identity(),
                  ordering=true)</code></pre><p>Computes the displacement vector <code>q</code> for the given <code>problem</code> subject to  loads <code>load</code> and supports <code>supp</code>. When <code>condensed</code> is <code>true</code>, the  reduced stiffness matrix and load vector are used in the solution. (see <code>load</code>, <code>displacementConstraint</code> and <code>elasticSupport</code>) If <code>iterative</code> is true, conjugate gradient method will be used with <code>reltol</code> and <code>maxiter</code> (see <code>cg</code> in the <code>IterativeSolvers</code> package) If <code>ordering</code> is false, no culomn ordering will be performed in the stiffness matrix. In this case it is advisable to use the <code>bandwidth</code> option when define <code>Problem</code>. (see <code>lu</code> in <code>LinearAlgebra</code> package, <code>q=nothing</code> option)</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>load</code>: Vector{Tuple} </li><li><code>supp</code>: Vector{Tuple}</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3713-L3739">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(K, q)</code></pre><p>Solves the equation K*q=f for the displacement vector <code>q</code>. <code>K</code> is the stiffness Matrix, <code>q</code> is the load vector.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix </li><li><code>f</code>: VectorField </li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3574-L3586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveEigenModes-Tuple{Any, Any}" href="#LowLevelFEM.solveEigenModes-Tuple{Any, Any}"><code>LowLevelFEM.solveEigenModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveEigenModes(K, M; n=6, fₘᵢₙ=1.01)</code></pre><p>Solves the eigen frequencies and mode shapes of a problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>. <code>n</code> is the number of eigenfrequencies to solve, and solves the eigenfrequencies greater than <code>fₘᵢₙ</code>. Returns the struct of eigenfrequencies and eigen modes. Results can be presented by <code>showModalResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>n</code>: Int64</li><li><code>fₘᵢₙ</code>: Float64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5116-L5132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveModalAnalysis-Tuple{Any}" href="#LowLevelFEM.solveModalAnalysis-Tuple{Any}"><code>LowLevelFEM.solveModalAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveModalAnalysis(problem; constraints=[]; loads=[], n=6)</code></pre><p>Solves the first <code>n</code> eigenfrequencies and the corresponding  mode shapes for the <code>problem</code>, when <code>loads</code> and  <code>constraints</code> are applied. <code>loads</code> and <code>contraints</code> are optional.  Result can be presented by <code>showModalResults</code> function.  <code>loads</code> and <code>constraints</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively. If <code>loads</code> are given, it solves the eigenfrequencies of a prestressed structure.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{tuples}</li><li><code>constraints</code>: Vector{tuples}</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L5189-L5207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStrainNew-Tuple{Any}" href="#LowLevelFEM.solveStrainNew-Tuple{Any}"><code>LowLevelFEM.solveStrainNew</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveStrain(q; DoFResults=false)</code></pre><p>Solves the strain field <code>E</code> from displacement vector <code>q</code>. Strain field is given per elements, so it usually contains jumps at the boundaries of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>E</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStrainResults</code> or <code>showElementResults</code>).</p><p>Return: <code>E</code></p><p>Types:</p><ul><li><code>q</code>: VectorField</li><li><code>E</code>: TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L3750-L3764">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStressSlow-Tuple{Any}" href="#LowLevelFEM.solveStressSlow-Tuple{Any}"><code>LowLevelFEM.solveStressSlow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveStress(q; T=..., T₀=..., DoFResults=false)</code></pre><p>Solves the stress field <code>S</code> from displacement vector <code>q</code>. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>S</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStressResults</code> or <code>showElementResults</code>). If the <code>T</code> temperature field (and <code>T₀</code> initial temperature field if it differs from zero) is given, the function solves also the thermal stresses.</p><p>Return: <code>S</code></p><p>Types:</p><ul><li><code>q</code>: VectorField</li><li><code>T</code>: ScalarField</li><li><code>T₀</code>: ScalarField</li><li><code>S</code>: TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L4391-L4409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.stiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stiffnessMatrix(problem; forceOneThread=true)</code></pre><p>Solves the stiffness matrix of the <code>problem</code>.</p><p>Returns: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SystemMatrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">K = stiffnessMatrix(problem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/7af12989c6f5b08b024353f82bed872d3a529516/src/linear.jl#L52-L68">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>Serfőző, D., Pere, B.: <em>An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems</em>, Meccanica, <a href="https://doi.org/10.1007/s11012-025-02036-9">https://doi.org/10.1007/s11012-025-02036-9</a></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. <em>Improved  numerical dissipation for time integration algorithms in structural  dynamics</em>. Earthquake Engineering &amp; Structural Dynamics 5.3 (1977): 283-292.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Belytschko, Ted, and Thomas JR, Hughes: <em>Computational methods for  transient analysis</em>, North-Holland, (1983).</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Serfőző, D., Pere, B.: <em>A method to accurately define arbitrary algorithmic damping character as viscous damping</em>. Arch Appl Mech 93, 3581–3595 (2023). <a href="https://doi.org/10.1007/s00419-023-02454-9">https://doi.org/10.1007/s00419-023-02454-9</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../General/">« General</a><a class="docs-footer-nextpage" href="../Heat/">Heat »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 22 October 2025 10:06">Wednesday 22 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
