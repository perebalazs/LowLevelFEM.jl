<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General · LowLevelFEM</title><meta name="title" content="General · LowLevelFEM"/><meta property="og:title" content="General · LowLevelFEM"/><meta property="twitter:title" content="General · LowLevelFEM"/><meta name="description" content="Documentation for LowLevelFEM."/><meta property="og:description" content="Documentation for LowLevelFEM."/><meta property="twitter:description" content="Documentation for LowLevelFEM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/plausible.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelFEM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>General</a></li><li><a class="tocitem" href="../Linear/">Linear</a></li><li><a class="tocitem" href="../Heat/">Heat</a></li><li><a class="tocitem" href="../Poisson/">Poisson operators</a></li><li><a class="tocitem" href="../Nonlinear/">Nonlinear</a></li><li><a class="tocitem" href="../Operators/">Operators</a></li></ul></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../news/">News &amp; Updates</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>General</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/main/docs/src/General.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="General-API"><a class="docs-heading-anchor" href="#General-API">General API</a><a id="General-API-1"></a><a class="docs-heading-anchor-permalink" href="#General-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.BoundaryCondition" href="#LowLevelFEM.BoundaryCondition"><code>LowLevelFEM.BoundaryCondition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryCondition</code></pre><p>General container type for prescribing boundary conditions in LowLevelFEM.</p><p><code>BoundaryCondition</code> unifies all Dirichlet- and Neumann-type boundary data (mechanical, thermal, elastic, convective, etc.) into a single, extensible structure. A boundary condition always refers to a <em>physical group</em> of the mesh (e.g. <code>&quot;left&quot;</code>, <code>&quot;right&quot;</code>, <code>&quot;wall&quot;</code>) and may prescribe one or more fields simultaneously.</p><p>The same <code>BoundaryCondition</code> type is used consistently across:</p><ul><li>static and transient solid mechanics</li><li>modal and buckling analysis</li><li>heat conduction and thermo-mechanical problems</li></ul><p>Boundary conditions are typically passed as <code>Vector{BoundaryCondition}</code> to assembly, load, and solver routines.</p><p><strong>Prescribed fields</strong></p><p><strong>Mechanical (solid mechanics)</strong></p><p><strong>Dirichlet-type (essential)</strong></p><ul><li><code>ux, uy, uz</code> : prescribed displacement components</li><li><code>p</code>          : prescribed pressure (if applicable)</li></ul><p><strong>Neumann-type (natural)</strong></p><ul><li><code>fx, fy, fz</code> : prescribed surface forces / tractions</li></ul><p><strong>Elastic (Robin-type)</strong></p><ul><li><code>kx, ky, kz</code> : elastic support (spring stiffness per displacement component)</li></ul><p><strong>Thermal</strong></p><p><strong>Dirichlet-type</strong></p><ul><li><code>T</code>          : prescribed temperature</li></ul><p><strong>Neumann-type</strong></p><ul><li><code>q</code>          : prescribed heat flux</li><li><code>qn</code>         : prescribed normal heat flux</li></ul><p><strong>Convection (Robin-type)</strong></p><ul><li><code>h</code>          : heat transfer coefficient</li><li><code>T</code>          : ambient temperature (used together with <code>h</code>)</li></ul><p><strong>Poisson-type problems</strong></p><p><strong>Dirichlet-type</strong></p><ul><li><code>p</code>          : prescribed field</li></ul><p><strong>Neumann-type</strong></p><ul><li><code>q</code>          : prescribed force</li></ul><p>For heat convection, the field <code>T</code> is interpreted as <em>ambient temperature</em>. This is intentional and handled consistently by the heat assembly routines.</p><p><strong>Value types</strong></p><p>Each field may be specified as:</p><ul><li>a scalar number (<code>Number</code>)</li><li>a <code>ScalarField</code></li><li>a <code>VectorField</code></li><li>a function <code>(x,y,z) -&gt; value</code></li></ul><p>depending on the context and the assembly routine using it.</p><p><strong>Usage pattern</strong></p><p>It is recommended to:</p><ul><li>use <strong>separate <code>BoundaryCondition</code> objects</strong> for conceptually different constraints (e.g. displacement support vs. load),</li><li>and collect them in a vector:</li></ul><pre><code class="language-julia hljs">bc = [
    displacementConstraint(&quot;left&quot;, ux=0.0, uy=0.0),
    load(&quot;right&quot;, fx=1.0),
    temperatureConstraint(&quot;wall&quot;, T=300.0)
]</code></pre><p><strong>Notes</strong></p><ul><li>Only the fields relevant to a given analysis are accessed; unused fields may safely remain <code>nothing</code>.</li><li>Invalid combinations (e.g. simultaneous displacement and force prescription on the same DOF) are detected during boundary condition application.</li></ul><p>See also:</p><ul><li><code>displacementConstraint</code></li><li><code>load</code></li><li><code>elasticSupport</code></li><li><code>temperatureConstraint</code></li><li><code>heatFlux</code></li><li><code>heatConvection</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1339-L1435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CoordinateSystem" href="#LowLevelFEM.CoordinateSystem"><code>LowLevelFEM.CoordinateSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoordinateSystem(vec1, vec2)</code></pre><p>A structure containing the data of a coordinate system.</p><ul><li><code>vec1</code>: direction of the new x axis.</li><li><code>vec2</code>: together with <code>vec1</code> determine the xy plane</li></ul><p>If the problem is two dimensional, it is enough to give the first two elements of <code>vec1</code>. Elements of <code>vec1</code> and <code>vec2</code> can be functions. In 3D case the functions have three arguments (x, y, and z coordinates), otherwise (in 2D case) the number of arguments is two (x and y coordinates).</p><p>Types:</p><ul><li><code>vec1</code>: Vector{Float64}</li><li><code>vec2</code>: Vector{Float64}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 2D case
nx(x, y) = x
ny(x, y) = y
cs = CoordinateSystem([nx, ny])
Q = rotateNodes(problem, &quot;body&quot;, cs)
q2 = Q&#39; * q1 # where `q1` is in Cartesian, `q2` is in Axisymmetric coordinate system and
# `q1` is a nodal displacement vector.
S2 = Q&#39; * S1 * Q # where `S1` is a stress field in Cartesian coordinate system while
# `S2` is in Axisymmetric coordinate system.

# 3D case
n1x(x, y, z) = x
n1y(x, y, z) = y
n2x(x, y, z) = -y
n2y = n1x
cs = CoordinateSystem([n1x, n1y, 0], [n2x, n2y, 0])
Q = rotateNodes(problem, &quot;body&quot;, cs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1261-L1297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Eigen" href="#LowLevelFEM.Eigen"><code>LowLevelFEM.Eigen</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Eigen(f, ϕ, model)</code></pre><p>A structure containing the eigenfrequencies and eigen modes.</p><ul><li>f: eigenfrequencies</li><li>ϕ: eigen modes</li><li>model: same as <code>Problem</code></li></ul><p>Types:</p><ul><li><code>f</code>: Matrix{Float64}</li><li><code>ϕ</code>: Vector{Float64}</li><li><code>model</code>: Problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2369-L2381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Material" href="#LowLevelFEM.Material"><code>LowLevelFEM.Material</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Material(phName, type, E, ν, ρ, k, c, α, λ, μ, κ)</code></pre><p>Structure containing the material type and constants.</p><ul><li>type: constitutive law (<code>:Hooke</code>, <code>:StVenantKirchhoff</code>, <code>:NeoHookeCompressible</code>)</li><li>E: elastic modulus</li><li>ν: Poisson&#39;s ratio</li><li>ρ: mass density</li><li>k: thermal conductivity</li><li>c: specific heat</li><li>α: thermal expansion coefficient</li><li>λ: Lamé parameter</li><li>μ: Lamé parameter</li><li>κ: bulk modulus</li></ul><p><code>phName</code> is the name of the physical group where the material is used.</p><p>Types:</p><ul><li><code>phName</code>: String</li><li><code>type</code>: Symbol</li><li><code>E</code>: Float64</li><li><code>ν</code>: Float64</li><li><code>ρ</code>: Float64</li><li><code>k</code>: Float64</li><li><code>c</code>: Float64</li><li><code>α</code>: Float64</li><li><code>λ</code>: Float64</li><li><code>μ</code>: Float64</li><li><code>κ</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L17-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Problem" href="#LowLevelFEM.Problem"><code>LowLevelFEM.Problem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Problem(materials; thickness=..., type=..., bandwidth=..., dim=..., fdim=...)</code></pre><p>Structure containing key data for a problem.</p><ul><li>Parts of the model with their material constants. Multiple materials can be provided (see <code>material</code>).</li><li>Problem type: <code>:Solid</code>, <code>:PlaneStrain</code>, <code>:PlaneStress</code>, <code>:AxiSymmetric</code>, <code>:HeatConduction</code>, <code>:PlaneHeatConduction</code>, </li></ul><p><code>:AxiSymmetricHeatConduction</code>, <code>:Truss</code>, <code>:General</code>.   For <code>:AxiSymmetric</code>, the symmetry axis is <code>y</code>, and the geometry must be drawn in the positive <code>x</code> half-plane.</p><ul><li>Bandwidth optimization using Gmsh&#39;s built-in reordering. Options: <code>:RCMK</code>, <code>:Hilbert</code>, <code>:Metis</code>, or <code>:none</code> (default).</li><li>Dimension of the problem, determined by <code>type</code>.</li><li>Material constants (vector of <code>Material</code>; see the <code>Material</code> struct).</li><li>Plate thickness (for 2D plate problems).</li><li>Number of nodes (<code>non</code>).</li><li>Geometry dimension.</li><li>Problem dimension (e.g., a 3D heat conduction problem is a 1D problem).</li><li>In case of 2D truss displacements have to be fixed in the third direction.</li><li><code>dim</code> is number of dimensions in space (in case of :General)</li><li><code>fdim</code> is the number of unknown fields (eg. scalar-&gt;1, 2D vector-&gt;2, 3D vector-&gt;3 or more) (in case of :General)</li></ul><p>Types:</p><ul><li><code>materials</code>: Material</li><li><code>type</code>: Symbol</li><li><code>bandwidth</code>: Symbol</li><li><code>dim</code>: Integer</li><li><code>thickness</code>: Float64</li><li><code>non</code>: Integer</li><li><code>dim</code>: Integer</li><li><code>pdim</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L211-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.ScalarField" href="#LowLevelFEM.ScalarField"><code>LowLevelFEM.ScalarField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScalarField(A, a, t, numElem, nsteps, type, model)
ScalarField(problem::Problem, dataField::Vector; steps=1, tmin=0.0, tmax=tmin+(steps-1))
ScalarField(problem::Problem, phName::String, data::Union{Number,Function};
            steps=1, tmin=0.0, tmax=tmin+(steps-1))
ScalarField(s::ScalarField; steps=1, tmin=0.0, tmax=tmin+(steps-1), step=1)</code></pre><p>Container for a time-dependent scalar field defined on a finite element mesh (e.g. temperature, pressure, potential).</p><p>A <code>ScalarField</code> can store the field either</p><ul><li><strong>element-wise</strong> (values at the element nodes, stored in <code>A</code>), or</li><li><strong>nodally</strong> (values at global mesh nodes, stored in <code>a</code>).</li></ul><p>Time dependence is handled by storing multiple time steps for each spatial degree of freedom.</p><hr/><p><strong>Stored data</strong></p><ul><li><code>A</code> : Vector of matrices holding <strong>element-wise</strong> values   (<code>A[e][k,i]</code> = value at local node <code>k</code> of element <code>e</code> at time step <code>i</code>)</li><li><code>a</code> : Matrix of <strong>nodal</strong> values   (<code>a[n,i]</code> = value at node <code>n</code> at time step <code>i</code>)</li><li><code>t</code> : Vector of time instants corresponding to the stored time steps</li><li><code>numElem</code> : Vector of element tags associated with <code>A</code></li><li><code>nsteps</code> : Number of stored time steps</li><li><code>type</code> : Symbol identifying the physical meaning of the field</li><li><code>model</code> : Associated <code>Problem</code></li></ul><p>At a given time, either <code>A</code> or <code>a</code> is typically populated, depending on whether the field is element-wise or nodal.</p><hr/><p><strong>Constructors</strong></p><p><strong>Low-level constructor</strong></p><pre><code class="language-julia hljs">ScalarField(A, a, t, numElem, nsteps, type, model)</code></pre><p>Directly constructs a <code>ScalarField</code> from preallocated data arrays.</p><hr/><p><strong>From spatial field definitions</strong></p><pre><code class="language-julia hljs">ScalarField(problem, dataField; steps, tmin, tmax)</code></pre><p>Constructs an <strong>element-wise</strong> scalar field from a vector of field definitions (e.g. as returned by <code>field(...)</code>). The scalar value may be:</p><ul><li>a constant,</li><li>a spatial function <code>f(x,y,z)</code>,</li><li>or a space–time function <code>f(x,y,z,t)</code>.</li></ul><p>Values are evaluated at the element nodes for each requested time step.</p><hr/><p><strong>From a physical group</strong></p><pre><code class="language-julia hljs">ScalarField(problem, phName, data; steps, tmin, tmax)</code></pre><p>Convenience constructor for defining a scalar field on a single physical group. Equivalent to calling <code>field(phName, f=data)</code> internally.</p><hr/><p><strong>From an existing ScalarField</strong></p><pre><code class="language-julia hljs">ScalarField(s; steps, tmin, tmax, step)</code></pre><p>Creates a new <code>ScalarField</code> by <strong>replicating a selected time step</strong> of an existing field. This is useful for initializing a time-dependent field from a static solution.</p><ul><li><code>step</code> selects the time index of <code>s</code> to be replicated.</li><li>The new field contains <code>steps</code> identical time slices.</li></ul><hr/><p><strong>Notes</strong></p><ul><li>Time steps do not need to be uniformly spaced.</li><li>No assumptions are made about governing equations; this is a pure data container.</li><li>Spatial interpolation and projections (e.g. nodal ↔ element-wise) are handled by separate utility functions.</li></ul><hr/><p><strong>Example</strong></p><pre><code class="language-julia hljs">s(x,y,z) = 2x + 3y
fs = field(&quot;body&quot;, f=s)

S1 = ScalarField(problem, [fs])
S2 = ScalarField(problem, &quot;body&quot;, s)</code></pre><p>Here <code>S1</code> and <code>S2</code> define equivalent element-wise scalar fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L409-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.SystemMatrix" href="#LowLevelFEM.SystemMatrix"><code>LowLevelFEM.SystemMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SystemMatrix(A::SparseMatrixCSC{Float64}, model::Problem)</code></pre><p>Structure containing the stiffness/mass/heat conduction/heat capacity/latent heat/... matrix and the associated <code>Problem</code>.</p><p>Types:</p><ul><li><code>A</code>: SparseMatrixCSC{Float64}</li><li><code>model</code>: Problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L374-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.TensorField" href="#LowLevelFEM.TensorField"><code>LowLevelFEM.TensorField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TensorField(A, a, t, numElem, nsteps, type, model)
TensorField(problem::Problem, dataField::Vector)
TensorField(problem::Problem, phName::String, data::Matrix)
TensorField(comps::Matrix{ScalarField})</code></pre><p>Container for a (possibly time-dependent) second-order tensor field defined on a finite element mesh (e.g. stress, strain, conductivity tensor).</p><p>A <code>TensorField</code> stores a full 3×3 tensor at each spatial location, either</p><ul><li><strong>element-wise</strong>, with values given at element nodes (<code>A</code>), or</li><li><strong>nodally</strong>, with values given at global mesh nodes (<code>a</code>).</li></ul><p>Time dependence is handled by storing multiple time steps for each tensor component.</p><hr/><p><strong>Stored data</strong></p><ul><li><code>A</code> : Vector of matrices holding <strong>element-wise</strong> tensor values   (<code>A[e][9k-8:9k, i]</code> = tensor components at local node <code>k</code> of element <code>e</code> at time step <code>i</code>)</li><li><code>a</code> : Matrix of <strong>nodal</strong> tensor values   (same component ordering as element-wise storage)</li><li><code>t</code> : Vector of time instants corresponding to the stored time steps</li><li><code>numElem</code> : Vector of element tags associated with <code>A</code></li><li><code>nsteps</code> : Number of stored time steps</li><li><code>type</code> : Symbol identifying the physical meaning of the tensor field (e.g. <code>:e</code>, <code>:stress</code>, <code>:tensor</code>)</li><li><code>model</code> : Associated <code>Problem</code></li></ul><p>Tensor components are stored in <strong>row-major, interleaved form</strong> for each node:</p><pre><code class="nohighlight hljs">
(xx, yx, zx,
xy, yy, zy,
xz, yz, zz)
</code></pre><p>repeated for all nodes and time steps.</p><hr/><p><strong>Constructors</strong></p><p><strong>Low-level constructor</strong></p><pre><code class="language-julia hljs">TensorField(A, a, t, numElem, nsteps, type, model)</code></pre><p>Directly constructs a <code>TensorField</code> from preallocated data arrays.</p><hr/><p><strong>From element-wise field definitions</strong></p><pre><code class="language-julia hljs">TensorField(problem, dataField::Vector)</code></pre><p>Constructs an <strong>element-wise</strong> tensor field from a vector of field definitions (e.g. as returned by <code>field(...)</code>).</p><p>Each tensor component may be specified as:</p><ul><li>a constant,</li><li>a spatial function <code>f(x,y,z)</code>.</li></ul><p>Values are evaluated at the element nodes.</p><hr/><p><strong>From a constant or functional tensor</strong></p><pre><code class="language-julia hljs">TensorField(problem, phName, data::Matrix)</code></pre><p>Convenience constructor for defining a tensor field on a single physical group, where <code>data</code> is a <code>3×3</code> matrix whose entries are constants or functions <code>f(x,y,z)</code>.</p><hr/><p><strong>From scalar components</strong></p><pre><code class="language-julia hljs">TensorField(comps::Matrix{ScalarField})</code></pre><p>Assembles a 3×3 tensor field from a <code>3×3</code> matrix of compatible <code>ScalarField</code>s.</p><p>Requirements:</p><ul><li>exactly a 3×3 matrix of scalar fields,</li><li>identical <code>Problem</code>,</li><li>identical element numbering,</li><li>identical time discretization.</li></ul><p>Each scalar field provides one tensor component.</p><hr/><p><strong>Notes</strong></p><ul><li>Time steps do not need to be uniformly spaced.</li><li>No symmetry is assumed; all 9 tensor components are stored explicitly.</li><li>This is a pure data container; no constitutive or kinematic assumptions are implied.</li><li>Spatial operations (e.g. divergence, invariants, projections) are handled by separate utility functions.</li><li>Element-wise storage is the primary representation; nodal storage may be empty depending on construction.</li></ul><hr/><p><strong>Example</strong></p><pre><code class="language-julia hljs">tx(x,y,z)  = x + y
txy(x,y,z) = z

ft = field(&quot;body&quot;, fx=tx, fxy=txy, fz=3)
T1 = TensorField(problem, [ft])

T2 = TensorField(problem, &quot;body&quot;, [1 0 0;
                                  0 2 0;
                                  0 0 3])</code></pre><p>Here <code>T1</code> and <code>T2</code> define equivalent element-wise tensor fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L939-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Transformation" href="#LowLevelFEM.Transformation"><code>LowLevelFEM.Transformation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transformation(T::SparseMatrixCSC{Float64}, non::Int64, dim::Int64)</code></pre><p>Structure containing the transformation matrix <code>T</code> at each node in the FE mesh, the number of nodes <code>non</code>, and the problem dimension <code>dim</code>.</p><p>Types:</p><ul><li><code>T</code>: SparseMatrixCSC{Float64}</li><li><code>non</code>: Int64</li><li><code>dim</code>: Int64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L357-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.VectorField" href="#LowLevelFEM.VectorField"><code>LowLevelFEM.VectorField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorField(A, a, t, numElem, nsteps, type, model)
VectorField(problem::Problem, dataField::Vector)
VectorField(problem::Problem, phName::String, data::Vector)
VectorField(problem::Problem, phName::String, func::Function)
VectorField(comps::Vector{ScalarField})</code></pre><p>Container for a (possibly time-dependent) vector field defined on a finite element mesh (e.g. displacement, velocity, heat flux).</p><p>A <code>VectorField</code> stores a 3D vector field either</p><ul><li><strong>element-wise</strong>, with values given at element nodes (<code>A</code>), or</li><li><strong>nodally</strong>, with values given at global mesh nodes (<code>a</code>).</li></ul><p>Time dependence is handled by storing multiple time steps for each spatial degree of freedom, analogously to <code>ScalarField</code>.</p><hr/><p><strong>Stored data</strong></p><ul><li><code>A</code> : Vector of matrices holding <strong>element-wise</strong> vector values   (<code>A[e][3k-2:3k, i]</code> = vector value at local node <code>k</code> of element <code>e</code> at time step <code>i</code>)</li><li><code>a</code> : Matrix of <strong>nodal</strong> vector values   (layout follows the same interleaved component ordering)</li><li><code>t</code> : Vector of time instants corresponding to the stored time steps</li><li><code>numElem</code> : Vector of element tags associated with <code>A</code></li><li><code>nsteps</code> : Number of stored time steps</li><li><code>type</code> : Symbol identifying the physical meaning of the vector field (e.g. <code>:v3D</code>)</li><li><code>model</code> : Associated <code>Problem</code></li></ul><p>Vector components are stored in <strong>interleaved form</strong> (<code>x₁,y₁,z₁,x₂,y₂,z₂,…</code>) for each element or node.</p><hr/><p><strong>Constructors</strong></p><p><strong>Low-level constructor</strong></p><pre><code class="language-julia hljs">VectorField(A, a, t, numElem, nsteps, type, model)</code></pre><p>Directly constructs a <code>VectorField</code> from preallocated data arrays.</p><hr/><p><strong>From element-wise field definitions</strong></p><pre><code class="language-julia hljs">VectorField(problem, dataField::Vector)</code></pre><p>Constructs an <strong>element-wise</strong> vector field from a vector of field definitions (e.g. as returned by <code>field(...)</code>). Each component may be specified as:</p><ul><li>a constant,</li><li>a spatial function <code>f(x,y,z)</code>.</li></ul><p>Values are evaluated at the element nodes.</p><hr/><p><strong>From a physical group and component data</strong></p><pre><code class="language-julia hljs">VectorField(problem, phName, data::Vector)</code></pre><p>Convenience constructor for defining a vector field on a single physical group, where <code>data = [fx, fy, fz]</code> specifies the three components (constants or functions).</p><hr/><p><strong>From a vector-valued function</strong></p><pre><code class="language-julia hljs">VectorField(problem, phName, func::Function)</code></pre><p>Constructs an element-wise vector field by evaluating a function <code>func(x,y,z) -&gt; (vx,vy,vz)</code> at the element nodes.</p><hr/><p><strong>From scalar components</strong></p><pre><code class="language-julia hljs">VectorField(comps::Vector{ScalarField})</code></pre><p>Assembles a 3D vector field from exactly three compatible <code>ScalarField</code>s.</p><p>Requirements:</p><ul><li>exactly three components,</li><li>same <code>Problem</code>,</li><li>identical element numbering,</li><li>identical time discretization.</li></ul><p>Each scalar field provides one vector component.</p><hr/><p><strong>From an existing VectorField</strong></p><pre><code class="language-julia hljs">VectorField(s; steps, tmin, tmax, step)</code></pre><p>Creates a new <code>VectorField</code> by <strong>replicating a selected time step</strong> of an existing field. This is useful for initializing a time-dependent field from a static solution.</p><ul><li><code>step</code> selects the time index of <code>s</code> to be replicated.</li><li>The new field contains <code>steps</code> identical time slices.</li></ul><hr/><p><strong>Notes</strong></p><ul><li>Time steps do not need to be uniformly spaced.</li><li>No governing equations are implied; this is a pure data container.</li><li>Spatial operations (gradient, divergence, projections, etc.) are handled by separate utility functions.</li><li>Element-wise storage is the primary representation; nodal storage may be empty depending on construction.</li></ul><hr/><p><strong>Example</strong></p><pre><code class="language-julia hljs">vx(x,y,z) = x + y
vy(x,y,z) = z

fv = field(&quot;body&quot;, fx=vx, fy=vy, fz=3)
V1 = VectorField(problem, [fv])

V2 = VectorField(problem, &quot;body&quot;, [vx, vy, 3])</code></pre><p>Here <code>V1</code> and <code>V2</code> define equivalent element-wise vector fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L604-L751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{TensorField, Colon, Int64}" href="#Base.getindex-Tuple{TensorField, Colon, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T[:,j] -&gt; VectorField</code></pre><p>Extract the j-th column of a 3×3 <code>TensorField</code> as a 3-component <code>VectorField</code>.</p><p>Equivalent to: [T[1,j], T[2,j], T[3,j]]</p><p><strong>Arguments</strong></p><ul><li><code>j::Int</code>: column index (1 ≤ j ≤ 3).</li></ul><p><strong>Returns</strong></p><p>A <code>VectorField</code> of size 3.</p><p><strong>Notes</strong></p><p>Colon indexing is required; <code>T[j]</code> is not allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2115-L2130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{TensorField, Int64, Colon}" href="#Base.getindex-Tuple{TensorField, Int64, Colon}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T[i,:] -&gt; VectorField</code></pre><p>Extract the i-th row of a 3×3 <code>TensorField</code> as a 3-component <code>VectorField</code>.</p><p>Equivalent to: [T[i,1], T[i,2], T[i,3]]</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>: row index (1 ≤ i ≤ 3).</li></ul><p><strong>Returns</strong></p><p>A <code>VectorField</code> of size 3.</p><p><strong>Notes</strong></p><p>Colon indexing is required; <code>T[i]</code> is not allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2089-L2104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{TensorField, Int64, Int64}" href="#Base.getindex-Tuple{TensorField, Int64, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T[i,j] -&gt; ScalarField</code></pre><p>Extract a single tensor component (i,j) from a 3×3 <code>TensorField</code>.</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>, <code>j::Int</code>: tensor indices in 1:3.</li></ul><p><strong>Returns</strong></p><p>A <code>ScalarField</code> corresponding to component Tᵢⱼ.</p><p><strong>Notes</strong></p><p>Block extraction is done elementwise or nodally depending on the representation of <code>T</code>.</p><p><strong>Errors</strong></p><p>Raises an error if i or j is outside 1:3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2040-L2057">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{TensorField, Vararg{Any}}" href="#Base.getindex-Tuple{TensorField, Vararg{Any}}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Invalid index pattern for <code>TensorField</code>.</p><p>Allowed:</p><ul><li><code>T[i,j]</code>    → ScalarField</li><li><code>T[i,:]</code>    → VectorField (row)</li><li><code>T[:,j]</code>    → VectorField (column)</li></ul><p>Not allowed:</p><ul><li><code>T[i]</code></li><li><code>T[:]</code></li><li><code>T[1:2,1]</code></li><li><code>T[:, :]</code></li><li><code>T[[1,3],2]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2141-L2155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{VectorField, Int64}" href="#Base.getindex-Tuple{VectorField, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">v[k] -&gt; ScalarField</code></pre><p>Extract the k-th component (1,2,3) of a <code>VectorField</code> as a <code>ScalarField</code>.</p><p><strong>Arguments</strong></p><ul><li><code>k::Int</code>: component index (1 → x, 2 → y, 3 → z).</li></ul><p><strong>Returns</strong></p><p>A <code>ScalarField</code> in the same representation as the parent field (elementwise or nodal).</p><p><strong>Errors</strong></p><p>Raises an error for any non-scalar indexing:</p><ul><li><code>v[1:2]</code>    → ERROR  </li><li><code>v[[1,3]]</code>  → ERROR  </li><li><code>v[:]</code>      → ERROR</li></ul><p>Only single-component extraction <code>v[k]</code> is allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1989-L2007">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{TensorField, ScalarField, Int64, Int64}" href="#Base.setindex!-Tuple{TensorField, ScalarField, Int64, Int64}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">T[i, j] = s
T[i, :] = v
T[:, j] = v</code></pre><p>Assign a scalar or vector component into a <code>TensorField</code>.</p><p><strong>Supported forms</strong></p><p><strong>1. Assign scalar component</strong></p><p><code>T[i, j] = s</code></p><ul><li>Inserts the scalar field <code>s</code> into the tensor component <code>(i, j)</code>   (with i,j ∈ 1:3).</li><li>Only the rows of the <code>(i,j)</code> block are overwritten.</li></ul><p><strong>2. Assign row vector</strong></p><p><code>T[i, :] = v</code></p><ul><li><code>v</code> must be a <code>VectorField</code> with 3 components.</li><li>Replaces the entire i-th tensor row with the components of <code>v</code>.</li></ul><p><strong>3. Assign column vector</strong></p><p><code>T[:, j] = v</code></p><ul><li><code>v</code> must be a <code>VectorField</code>.</li><li>Replaces the entire j-th tensor column with the components of <code>v</code>.</li></ul><p><strong>Requirements</strong></p><ul><li>Assigned field(s) must belong to the <strong>same problem</strong> as <code>T</code>.</li><li>The number of time steps must match.</li><li>Storage mode must match:<ul><li>Elementwise tensor → only elementwise scalar/vector may be assigned.</li><li>Nodal tensor → only nodal scalar/vector may be assigned.</li></ul></li><li>Element counts or nodal sizes must be identical.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># scalar insertion
T[1,1] = s1
T[2,3] = s2

# row insertion
T[1,:] = v1    # v1 is VectorField([s11, s12, s13])

# column insertion
T[:,3] = v2</code></pre><p><strong>Errors</strong></p><p>Errors are thrown when:</p><ul><li>indices are out of bounds</li><li>shapes do not match (nodal vs elementwise mismatch)</li><li>component sizes differ</li><li>attempting unsupported forms like <code>T[1] = ...</code> or <code>T[:, :] = ...</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2245-L2302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{VectorField, ScalarField, Int64}" href="#Base.setindex!-Tuple{VectorField, ScalarField, Int64}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">v[k] = s</code></pre><p>Assign a scalar component into a <code>VectorField</code>.</p><p>This operation overwrites the k-th component (k = 1, 2, 3) of the vector field.</p><p><strong>Requirements</strong></p><ul><li><code>v</code> must be a <code>VectorField</code></li><li><code>s</code> must be a <code>ScalarField</code></li><li>both fields must belong to the <strong>same problem</strong></li><li>both must have the <strong>same number of time steps</strong></li><li>storage layout must match:<ul><li>If <code>v</code> is <strong>elementwise</strong> (<code>v.A ≠ []</code>), then <code>s</code> must also be elementwise and must have the same number of elements (<code>numElem</code>).</li><li>If <code>v</code> is <strong>nodal</strong> (<code>v.a ≠ [;;]</code>), then <code>s</code> must also be nodal and must have the same nodal size.</li></ul></li></ul><p>Only the rows belonging to component <code>k</code> are modified.   Other components remain unchanged.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">v = VectorField([s1, s2, s3])

v[1] = s4       # overwrite first component
v[3] = 2s1      # scale and assign into third component</code></pre><p><strong>Errors</strong></p><p>An informative error is thrown if:</p><ul><li>k ∉ 1:3</li><li>the fields belong to different problems</li><li>storage layouts do not match (nodal vs. elementwise)</li><li>nodal or element counts differ</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2169-L2206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}" href="#Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, M::SystemMatrix)</code></pre><p>Internal function to display <code>SystemMatrix</code> as a <code>SparseMatrixCSC{Float64}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L388-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Union{ScalarField, TensorField, VectorField}}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, Union{ScalarField, TensorField, VectorField}}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, ::MIME&quot;text/plain&quot;, M::Union{ScalarField,VectorField,TensorField})</code></pre><p>Plain-text display in REPL and notebooks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1519-L1523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.DoFs-Tuple{LowLevelFEM.AbstractField}" href="#LowLevelFEM.DoFs-Tuple{LowLevelFEM.AbstractField}"><code>LowLevelFEM.DoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoFs(f::AbstractField)</code></pre><p>Return the vector of degrees of freedom (DOFs) associated with a field.</p><p>This corresponds to the nodal representation used in linear algebra operations (assembly, solving, post-processing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1494-L1501">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.allDoFs-Tuple{Any}" href="#LowLevelFEM.allDoFs-Tuple{Any}"><code>LowLevelFEM.allDoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allDoFs(problem)</code></pre><p>Returns the serial numbers of degrees of freedom of the whole model.</p><p>Return: <code>DoFs</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>DoFs</code>: Vector{Int64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3789-L3799">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.constrainedDoFs-Tuple{Any, Any}" href="#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}"><code>LowLevelFEM.constrainedDoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constrainedDoFs(problem, supports)</code></pre><p>Returns the serial numbers of constrained degrees of freedom. Support is a vector of boundary conditions given with the function <code>displacementConstraint</code>.</p><p>Return: <code>DoFs</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>supports</code>: Vector{BoundaryCondition}</li><li><code>DoFs</code>: Vector{Int64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3656-L3667">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.displacementConstraint-Tuple{Any}" href="#LowLevelFEM.displacementConstraint-Tuple{Any}"><code>LowLevelFEM.displacementConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displacementConstraint(name; ux=..., uy=..., uz=...)</code></pre><p>Specifies displacement constraints on the physical group <code>name</code>. At least one of <code>ux</code>, <code>uy</code>, or <code>uz</code> must be provided (depending on the problem dimension). <code>ux</code>, <code>uy</code>, or <code>uz</code> can be a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code>. (e.g., <code>fn(x,y,z) = 5*(5-x); displacementConstraint(&quot;support1&quot;, ux=fn)</code>)</p><p>Returns: BoundaryCondition</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">hc = heatConvection(&quot;outer&quot;, h=10.0, T∞=20.0)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">src = heatSource(&quot;body&quot;, h=1.0e6)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">q = heatFlux(&quot;out&quot;, qn=500.0)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">bcT = temperatureConstraint(&quot;hot_face&quot;, T=100.0)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ld = load(&quot;load&quot;, fy=-1.0)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">bc = displacementConstraint(&quot;supp&quot;, ux=0, uy=0)</code></pre><p>Types:</p><ul><li><code>name</code>: String</li><li><code>ux</code>: Float64 or Function</li><li><code>uy</code>: Float64 or Function</li><li><code>uz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2592-L2643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elasticSupport-Tuple{Any}" href="#LowLevelFEM.elasticSupport-Tuple{Any}"><code>LowLevelFEM.elasticSupport</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elasticSupport(name; kx=..., ky=..., kz=...)</code></pre><p>Specifies distributed stiffness for an elastic support on the physical group <code>name</code>. <code>kx</code>, <code>ky</code>, or <code>kz</code> can be a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code>. (e.g., <code>fn(x,y,z) = 5*(5-x); elasticSupport(&quot;supp1&quot;, kx=fn)</code>) Default values are 1.</p><p>Returns: BoundaryCondition</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>kx</code>: Float64 or Function</li><li><code>ky</code>: Float64 or Function</li><li><code>kz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2730-L2745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elementsToNodes-Tuple{Any}" href="#LowLevelFEM.elementsToNodes-Tuple{Any}"><code>LowLevelFEM.elementsToNodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elementsToNodes(T)</code></pre><p>Solves the nodal results <code>F</code> from the elemental results <code>T</code>. <code>T</code> can be ScalarField, VectorField or TensorField.</p><p>Return: <code>F</code></p><p>Types:</p><ul><li><code>T</code>: ScalarField, VectorField or TensorField</li><li><code>F</code>: ScalarField, VectorField or TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3837-L3848">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.expandTo3D-Tuple{VectorField}" href="#LowLevelFEM.expandTo3D-Tuple{VectorField}"><code>LowLevelFEM.expandTo3D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expandTo3D(v2D::VectorField)</code></pre><p>Expand a 2D vector field into 3D by adding a zero z-component.</p><p>return: VectorField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">V3D = expandTo3D(V2D)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4068-L4079">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.field-Tuple{Any}" href="#LowLevelFEM.field-Tuple{Any}"><code>LowLevelFEM.field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">field(name; f=..., fx=..., fy=..., fz=..., fxy=..., fyz=..., fzx=...)</code></pre><p>Specifies the value of a scalar, vector, or tensor field on the physical group <code>name</code>. At least one of <code>fx</code>, <code>fy</code>, or <code>fz</code> etc. must be provided (depending on the problem dimension). Each component can be a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code>. (e.g., <code>fn(x,y,z) = 5*(5-x); field(&quot;surf1&quot;, fx=fn)</code>)</p><p>Returns: BoundaryCondition</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>f</code>: Float64 or Function</li><li><code>fx</code>: Float64 or Function</li><li><code>fy</code>: Float64 or Function</li><li><code>fz</code>: Float64 or Function</li><li><code>fxy</code>: Float64 or Function</li><li><code>fyz</code>: Float64 or Function</li><li><code>fzx</code>: Float64 or Function</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = y
f2 = field(&quot;face1&quot;, f=f1)
qq = scalarField(problem, [f2])
qqq = showDoFResults(qq, :scalar)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2880-L2908">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.fieldError-Tuple{Any}" href="#LowLevelFEM.fieldError-Tuple{Any}"><code>LowLevelFEM.fieldError</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fieldError(F)</code></pre><p>Computes the deviation of field results <code>F</code> (stresses, strains, heat flux components) at nodes where the field has jumps. The result can be displayed with the <code>showDoFResults</code> function.</p><p>Returns: <code>e</code></p><p>Types:</p><ul><li><code>F</code>: VectorField or TensorField</li><li><code>e</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4140-L4151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.freeDoFs-Tuple{Any, Any}" href="#LowLevelFEM.freeDoFs-Tuple{Any, Any}"><code>LowLevelFEM.freeDoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">freeDoFs(problem, supports)</code></pre><p>Returns the serial numbers of unconstrained degrees of freedom. Support is  a vector of boundary conditions given with the function <code>displacementConstraint</code>.</p><p>Return: <code>DoFs</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>supports</code>: Vector{BoundaryCondition}</li><li><code>DoFs</code>: Vector{Int64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3817-L3829">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getDimForPhysicalName-Tuple{Any}" href="#LowLevelFEM.getDimForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getDimForPhysicalName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getDimForPhysicalName(name)</code></pre><p>Returns <code>dim</code> of elements of physical group <code>name</code>.</p><p>Returns: <code>dim</code></p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>dim</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2411-L2421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getEigenValues-Tuple{VectorField}" href="#LowLevelFEM.getEigenValues-Tuple{VectorField}"><code>LowLevelFEM.getEigenValues</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getEigenValues(A::VectorField)</code></pre><p>A function to extract the elements of a vector field to separate scalar fields.</p><p>Return: λ1, λ2, λ3</p><p>Types:</p><ul><li><code>A</code>: VectorField</li><li><code>λ1</code>: ScalarField</li><li><code>λ2</code>: ScalarField</li><li><code>λ3</code>: ScalarField</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">using LinearAlgebra
λ, Q = eigen(S)
λ1, λ2, λ2 = getEigenValues(λ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2535-L2555">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getEigenVectors-Tuple{TensorField}" href="#LowLevelFEM.getEigenVectors-Tuple{TensorField}"><code>LowLevelFEM.getEigenVectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getEigenVectors(A::TensorField)</code></pre><p>A function to extract the columns of a tensor field to separate vector fields.</p><p>Return: N1, N2, N3</p><p>Types:</p><ul><li><code>A</code>: TensorField</li><li><code>N1</code>: VectorField</li><li><code>N2</code>: VectorField</li><li><code>N3</code>: VectorField</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">using LinearAlgebra
λ, Q = eigen(S)
N1, N2, N2 = getEigenVectors(Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2478-L2498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getTagForPhysicalName-Tuple{Any}" href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getTagForPhysicalName(name)</code></pre><p>Returns <code>tag</code> of elements of physical group <code>name</code>.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2388-L2398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConvection-Tuple{Any}" href="#LowLevelFEM.heatConvection-Tuple{Any}"><code>LowLevelFEM.heatConvection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatConvection(name; h=..., T∞=...)</code></pre><p>Specifies convective boundary conditions on the surface in the physical group <code>name</code>. <code>h</code> is the heat transfer coefficient of the surrounding medium; <code>Tₐ</code> is the ambient temperature. <code>Tₐ</code> can be either a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code>.</p><p>Returns: BoundaryCondition</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>h</code>: Float64</li><li><code>Tₐ</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2835-L2848">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatFlux-Tuple{Any}" href="#LowLevelFEM.heatFlux-Tuple{Any}"><code>LowLevelFEM.heatFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatFlux(name; qn=...)</code></pre><p>Specifies the heat flux normal to the surface of the physical group <code>name</code>. <code>qn</code> can be a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code>. (e.g., <code>fn(x,y,z) = 5*(5-x); load(&quot;flux1&quot;, qn=fn)</code>)</p><p>Returns: BoundaryCondition</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>qn</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2783-L2795">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatSource-Tuple{Any}" href="#LowLevelFEM.heatSource-Tuple{Any}"><code>LowLevelFEM.heatSource</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatSource(name; h=...)</code></pre><p>Specifies the volumetric heat source in the physical group <code>name</code>. <code>h</code> can be a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code>. (e.g., <code>fn(x,y,z) = 5*(5-x); load(&quot;source1&quot;, h=fn)</code>)</p><p>Returns: BoundaryCondition</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>h</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2809-L2821">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.integrate-Tuple{Problem, String, Union{Function, ScalarField}}" href="#LowLevelFEM.integrate-Tuple{Problem, String, Union{Function, ScalarField}}"><code>LowLevelFEM.integrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(problem::Problem, phName::String, f::Union{Function,ScalarField}; step::Int64=1, order::Int64=...)
∫(problem::Problem, phName::String, f::Union{Function,ScalarField}; step::Int64=1, order::Int64=...)</code></pre><p>Integrates the function or scalar field <code>f</code> over the physical group <code>phName</code> defined in the geometry of <code>problem</code>. If <code>f</code> is a <code>ScalarField</code>, the time step <code>step</code> will be integrated. The optional parameter <code>order</code> controls the  numerical integration rule. If <code>order &gt; 0</code>, it is used as a hint for selecting the Gauss quadrature order (i.e. the number of integration points) employed during integration. The exactness of the integration depends  on the element geometry and the regularity of the integrand.</p><p>Returns: integral</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>phName</code>: String</li><li><code>f</code>: Function (of x, y and z) or ScalarField</li><li><code>integral</code>: Number</li></ul><p>Examples:</p><pre><code class="language-julia hljs">f(x, y, z) = x^2 + y^2
Iz = integrate(prob, &quot;body&quot;, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4400-L4424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.integrate-Tuple{Union{ScalarField, TensorField, VectorField}}" href="#LowLevelFEM.integrate-Tuple{Union{ScalarField, TensorField, VectorField}}"><code>LowLevelFEM.integrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(s::Union{ScalarField,VectorField,TensorField})
∫(s::Union{ScalarField,VectorField,TensorField})</code></pre><p>Compute the time integral of a time-dependent field using a discrete inverse of the central finite-difference time derivative.</p><p>The result reproduces the original field (up to a time-independent constant) when applied to a field obtained by <code>∂t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4577-L4586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.isElementwise-Tuple{Union{ScalarField, TensorField, VectorField}}" href="#LowLevelFEM.isElementwise-Tuple{Union{ScalarField, TensorField, VectorField}}"><code>LowLevelFEM.isElementwise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>isElementwise(field)</p><p>Check if a given field is defined per element (elementwise quantity).</p><p>Elementwise quantities are associated with finite elements as a whole, for example stresses, strains, or energy densities evaluated inside elements.</p><p>Examples</p><pre><code class="language-julia hljs">isElementwise(displacement_field)   # returns false
isElementwise(strain_field)         # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4043-L4056">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.isNodal-Tuple{Union{ScalarField, TensorField, VectorField}}" href="#LowLevelFEM.isNodal-Tuple{Union{ScalarField, TensorField, VectorField}}"><code>LowLevelFEM.isNodal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isNodal(field)</code></pre><p>Check if a given field is defined at nodes (nodal quantity).</p><p>Nodal quantities are associated with mesh nodes, for example displacements, nodal forces, or nodal temperatures.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">isNodal(displacement_field)   # returns true
isNodal(strain_field)         # returns false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4018-L4031">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.isSaved-Tuple{String}" href="#LowLevelFEM.isSaved-Tuple{String}"><code>LowLevelFEM.isSaved</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isSaved(fileName::String)</code></pre><p>Checks whether a variable has been saved or not.</p><p>Returns: Boolean</p><p>Types:</p><ul><li><code>fileName</code>: String</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5816-L5826">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.load-Tuple{Any}" href="#LowLevelFEM.load-Tuple{Any}"><code>LowLevelFEM.load</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load(name; fx=..., fy=..., fz=...)</code></pre><p>Specifies a distributed load on the physical group <code>name</code>. At least one of <code>fx</code>, <code>fy</code>, or <code>fz</code> must be provided (depending on the problem dimension). <code>fx</code>, <code>fy</code>, or <code>fz</code> can be a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code> or <code>ScalarField</code>. (e.g., <code>fn(x,y,z) = 5*(5-x); load(&quot;load1&quot;, fx=fn)</code>)</p><p>Returns: BoundaryCondition</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>fx</code>: Float64 or Function</li><li><code>fy</code>: Float64 or Function</li><li><code>fz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2656-L2671">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.loadField-Tuple{String}" href="#LowLevelFEM.loadField-Tuple{String}"><code>LowLevelFEM.loadField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadField(fileName::String)</code></pre><p>Loads a ScalarField, VectorField, or TensorField from a file named <code>fileName</code> (without &quot;-LLF-Data.jld2&quot;). </p><p>Returns: variable</p><p>Types:</p><ul><li><code>fileName</code>: String</li><li><code>variable</code>: ScalarField, VectorField or TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5799-L5810">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodesToElements-Tuple{Union{ScalarField, TensorField, VectorField}}" href="#LowLevelFEM.nodesToElements-Tuple{Union{ScalarField, TensorField, VectorField}}"><code>LowLevelFEM.nodesToElements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodesToElements(T, onPhysicalGroup=&quot;&quot;)</code></pre><p>Solves the element results <code>F</code> from the nodal results <code>T</code>. <code>T</code> can be ScalarField, VectorField or TensorField. If <code>onPhysicalGroup</code> is an existing physical group in gmsh, field <code>T</code> will be solve only on elements belonging to that physical group. Dimension of physical group can be different than the dimension of the problem. (eg. mapping from 3D volume to a 2D surface)</p><p>Return: <code>F</code></p><p>Types:</p><ul><li><code>T</code>: ScalarField, VectorField or TensorField</li><li><code>F</code>: ScalarField, VectorField or TensorField</li><li><code>onPhysicalGroup</code>: String</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3889-L3905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.normalVector-Tuple{Problem, String}" href="#LowLevelFEM.normalVector-Tuple{Problem, String}"><code>LowLevelFEM.normalVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalVector(problem::Problem, phName::String) -&gt; VectorField</code></pre><p>Compute outward unit normal vectors for all nodes belonging to a surface-type physical group in a 3D Gmsh model.</p><p>For curve-type physical groups, the function returns normal curvature vectors: the direction corresponds to the unit normal within the curve’s osculating plane, and the vector magnitude equals the local curvature of the curve.</p><p><strong>Arguments</strong></p><ul><li><code>problem::Problem</code>: A <code>Problem</code> structure containing the current Gmsh model  (name, dimension, number of nodes, etc.).</li><li><code>phName::String</code>: The name of a physical surface group in Gmsh for which the normal vectors are computed.</li></ul><p><strong>Description</strong></p><p>The function sets the current model, queries the elements and nodes that belong to the  given physical surface group, and evaluates the gradients of the Lagrange basis functions  to compute local tangent vectors of the surface. Normal vectors are obtained as cross  products of these tangents and normalized to unit length.</p><p>Each node belonging to the physical surface group is assigned its corresponding  3D unit normal vector.</p><p><strong>Returns</strong></p><ul><li><code>VectorField</code>: A <code>VectorField</code> structure that stores the nodal normal vectors  on the given physical surface.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the provided physical group is not of surface type (<code>dim != 2</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LowLevelFEM

# Load a 3D geometry and mesh it in Gmsh
gmsh.initialize()
gmsh.open(&quot;box_with_surface.msh&quot;)

# Define a 3D model on the volume physical group &quot;body&quot;
mat = material(&quot;body&quot;)
prob = Problem([mat])

# Compute nodal normals on a physical surface named &quot;leftWall&quot;
nv = normalVector(problem, &quot;leftWall&quot;)

# Show the normal vectors on the model
showDoFResults(nv)
openPostProcessor()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3255-L3306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.openPostProcessor-Tuple{}" href="#LowLevelFEM.openPostProcessor-Tuple{}"><code>LowLevelFEM.openPostProcessor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">openPostProcessor(; model=...)</code></pre><p>Launches the Gmsh postprocessor window with the postprocessor tree opened (of <code>model</code>).</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>model</code>: Int64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5639-L5648">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.openPreProcessor-Tuple{}" href="#LowLevelFEM.openPreProcessor-Tuple{}"><code>LowLevelFEM.openPreProcessor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">openPreProcessor(; openGL=...)</code></pre><p>Launches the Gmsh preprocessor window with OpenGL disabled by default.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>openGL</code>: Boolean</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5620-L5629">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.plotOnPath-Tuple{Any, Any}" href="#LowLevelFEM.plotOnPath-Tuple{Any, Any}"><code>LowLevelFEM.plotOnPath</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotOnPath(pathName, field; points=100, step=..., plot=..., name=..., visible=..., offsetX=..., offsetY=..., offsetZ=...)</code></pre><p>Loads a 2D plot along a path into a View in Gmsh. <code>field</code> is the View id in Gmsh from which the field data is imported. <code>pathName</code> is the name of a physical group that contains a curve. The curve is divided into equal-length segments with <code>points</code> sampling points. The field is shown at these points. <code>step</code> is the sequence number of the displayed step. If no step is given, it shows all available steps as an animation. If <code>plot</code> is true, an additional return parameter (a tuple of vectors) is returned, where <code>x</code> is the horizontal axis and <code>y</code> is the vertical axis of the plot (see the <code>Plots</code> package). <code>name</code> is the title of the graph, and <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off. This function returns the tag of the View.</p><p>Returns: <code>tag</code></p><p>or</p><p>Returns: <code>tag</code>, <code>xy</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>pathName</code>: String</li><li><code>field</code>: Integer</li><li><code>points</code>: Integer</li><li><code>step</code>: Integer</li><li><code>plot</code>: Boolean</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li><li><code>xy</code>: Tuples{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5388-L5419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.probe-Tuple{TensorField, Any, Any, Any}" href="#LowLevelFEM.probe-Tuple{TensorField, Any, Any, Any}"><code>LowLevelFEM.probe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">probe(A::Union{ScalarField,VectorField,TensorField}, x::Number, y::Number, z::Number; step=Int)</code></pre><p>Get the value of the field <code>A</code> at point coordinates <code>x</code>, <code>y</code>, <code>z</code> at time step <code>step</code>.</p><p>Returns: Float64 or Vector{Float64} or Matrix{Float64}</p><p>Types:</p><ul><li><code>A</code>: ScalarField or VectorField or TensorField</li><li><code>x</code>: Number</li><li><code>y</code>: Number</li><li><code>z</code>: Number</li><li><code>step</code>: Int</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5684-L5698">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.probe-Tuple{Union{ScalarField, TensorField, VectorField}, String}" href="#LowLevelFEM.probe-Tuple{Union{ScalarField, TensorField, VectorField}, String}"><code>LowLevelFEM.probe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">probe(A::Union{ScalarField,VectorField,TensorField}, s::String; step=Int)</code></pre><p>Get the value of the field <code>A</code> at a point given by its physical name in Gmsh at time step <code>step</code>.</p><p>Returns: Float64 or Vector{Float64} or Matrix{Float64}</p><p>Types:</p><ul><li><code>A</code>: ScalarField or VectorField or TensorField</li><li><code>x</code>: Number</li><li><code>y</code>: Number</li><li><code>z</code>: Number</li><li><code>step</code>: Int</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5760-L5774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.projectTo2D-Tuple{VectorField}" href="#LowLevelFEM.projectTo2D-Tuple{VectorField}"><code>LowLevelFEM.projectTo2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">projectTo2D(v3D::VectorField)</code></pre><p>Project a 3D vector field onto the xy-plane by discarding the z-component.</p><p>return: VectorField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">V2D = expandTo3D(V3D)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4104-L4115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.resultant-Tuple{VectorField, String}" href="#LowLevelFEM.resultant-Tuple{VectorField, String}"><code>LowLevelFEM.resultant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resultant(field, phName)</code></pre><p>Computes the resultant of vector field <code>field</code> on the physical group <code>phName</code>. Returns the resultant(s) in a <code>tuple</code>. The number of elements in the tuple depends on the dimension of problem (dimension of <code>field</code>). It can solve for example the resultant of a load vector (sum of the elements of the vector).</p><p>Return: <code>resx</code></p><p>or</p><p>Return: <code>resx</code>, <code>resy</code></p><p>or</p><p>Return: <code>resx</code>, <code>resy</code>, <code>resz</code></p><p>Types:</p><ul><li><code>field</code>: VectorField</li><li><code>phName</code>: String </li><li><code>resx</code>: Float64 </li><li><code>resy</code>: Float64 </li><li><code>resz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4205-L4229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}" href="#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}"><code>LowLevelFEM.rotateNodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotateNodes(problem, phName, CoordSys)</code></pre><p>Creates the <code>T</code> transformation matrix, which rotates the nodal coordinate system of the nodes in <code>phName</code> physical group to the coordinate systen defined by <code>CoordSys</code>. The mesh belongs to <code>problem</code>.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>phName</code>: String</li><li><code>CoordSys</code>: CoordinateSystem</li><li><code>T</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4610-L4624">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.saveField-Tuple{String, Union{Number, ScalarField, TensorField, VectorField}}" href="#LowLevelFEM.saveField-Tuple{String, Union{Number, ScalarField, TensorField, VectorField}}"><code>LowLevelFEM.saveField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">saveField(fileName::String, variable::Union{ScalarField,VectorField,TensorField,Number})</code></pre><p>Saves <code>variable</code> of type ScalarField, VectorField, or TensorField to a file named <code>fileName</code>. The name of the file will be complemented with the string &quot;-LLF-Data.jld2&quot;</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>fileName</code>: String</li><li><code>variable</code>: ScalarField, VectorField or TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5782-L5794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.scalarField-Tuple{Any, Any}" href="#LowLevelFEM.scalarField-Tuple{Any, Any}"><code>LowLevelFEM.scalarField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scalarField(problem, dataField)</code></pre><p>Defines a scalar field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>.</p><p>Return: Vector{Float64}</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{BoundaryCondition}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f2 = field(&quot;face1&quot;, f=1)
qq = scalarField(problem, [f2])
qqq = showDoFResults(qq)

qq2 = scalarField(problem, &quot;body&quot;, 2.0)</code></pre><p>Here ScalarField is defined in nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2916-L2939">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.setParameter-Tuple{Any, Any}" href="#LowLevelFEM.setParameter-Tuple{Any, Any}"><code>LowLevelFEM.setParameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setParameter(name, value)</code></pre><p>Defines a parameter <code>name</code> and sets its value to <code>value</code>. </p><p>Returns: nothing</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>value</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5654-L5664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.setParameters-Tuple{Any, Any}" href="#LowLevelFEM.setParameters-Tuple{Any, Any}"><code>LowLevelFEM.setParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setParameters(name, value)</code></pre><p>Defines a parameter <code>name</code> and sets its value to <code>value</code>, which is a <code>Vector{Float64}</code>. </p><p>Returns: nothing</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>value</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5669-L5679">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}" href="#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showBucklingResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showBucklingResults(Φ, name=..., visible=...)</code></pre><p>Loads buckling results into a View in Gmsh. <code>Φ</code> is an <code>Eigen</code> struct. <code>name</code> is a title to display and <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off. Click on ▷| to change the results. This function returns the tag of the View.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>Φ</code>: Eigen</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4920-L4934">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showDoFResults-Tuple{Union{ScalarField, TensorField, VectorField}, Symbol}" href="#LowLevelFEM.showDoFResults-Tuple{Union{ScalarField, TensorField, VectorField}, Symbol}"><code>LowLevelFEM.showDoFResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showDoFResults(q, comp; name=..., visible=..., factor=0)</code></pre><p>Loads nodal results into a View in Gmsh. <code>q</code> is the field to show, <code>comp</code> is the component of the field (:vector, :uvec, :ux, :uy, :uz, :vvec, :vx, :vy, :vz, :qvec, :qx, :qy, :qz, :T, :p, :qn, :s, :sx, :sy, :sz, :sxy, :syx, :syz, :szy, :szx, :sxz, :e, :ex, :ey, :ez, :exy, :eyx, :eyz, :ezy, :ezx, :exz, :seqv, :scalar, :tensor), <code>name</code> is a title to display and <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off. If <code>q</code> has more columns, then a sequence of results will be shown (e.g., as an animation). <code>factor</code> multiplies the DoF result to increase for better visibility. This function returns the tag of the View.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>q</code>: ScalarField, VectorField or TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4730-L4750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showElementResults-Tuple{Union{ScalarField, TensorField, VectorField}, Any}" href="#LowLevelFEM.showElementResults-Tuple{Union{ScalarField, TensorField, VectorField}, Any}"><code>LowLevelFEM.showElementResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showElementResults(F, comp; name=..., visible=..., smooth=...)</code></pre><p>Same as <code>ShowStressResults</code> or <code>showStrainResults</code>, depending on the type of <code>F</code> data field.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>F</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5039-L5053">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showHeatFluxResults-Tuple{VectorField, Any}" href="#LowLevelFEM.showHeatFluxResults-Tuple{VectorField, Any}"><code>LowLevelFEM.showHeatFluxResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showHeatFluxResults(Q, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads heat flux results into a View in Gmsh. <code>Q</code> is a heat flux field to show, <code>comp</code> is the component of the field (:qvec, :qx, :qy, :qz, :q), <code>name</code> is a title to display, <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off, and <code>smooth</code> is a Boolean to toggle smoothing on or off. If <code>Q</code> contains more than one time step, a sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>S</code>: VectorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5216-L5234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}" href="#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showModalResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showModalResults(Φ, name=..., visible=...)</code></pre><p>Loads modal results into a View in Gmsh. <code>Φ</code> is an <code>Eigen</code> struct. <code>name</code> is a title to display and <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off. Click on ▷| to change the results. This function returns the tag of the View.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>Φ</code>: Eigen</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4901-L4915">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showOnSurface-Tuple{Number, String}" href="#LowLevelFEM.showOnSurface-Tuple{Number, String}"><code>LowLevelFEM.showOnSurface</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showOnSurface(field, phName; grad=false, component=:x, offsetX=0, offsetY=0, offsetZ=0, name=phName, visible=false)</code></pre><p>Shows the values of a scalar field on a surface with physical name <code>phName</code>. <code>field</code> is the tag of a View in Gmsh. The values of the field are calculated at the intersection with the surface. <code>grad</code> is a Boolean to toggle the gradient of the field on or off. <code>component</code> is the component of the gradient of <code>field</code> (:x, :y, :z) to be shown. <code>offsetX</code>, <code>offsetY</code>, <code>offsetZ</code> are the offsets in the x, y, and z directions where the values are sampled. <code>name</code> is a title to display, and <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>field</code>: Integer</li><li><code>phName</code>: String</li><li><code>grad</code>: Boolean</li><li><code>component</code>: Symbol</li><li><code>offsetX</code>: Float64</li><li><code>offsetY</code>: Float64</li><li><code>offsetZ</code>: Float64</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5513-L5536">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStrainResults-Tuple{Any, Any}" href="#LowLevelFEM.showStrainResults-Tuple{Any, Any}"><code>LowLevelFEM.showStrainResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showStrainResults(E, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads strain results into a View in Gmsh. <code>E</code> is a strain field to show, <code>comp</code> is the component of the field (:e, :ex, :ey, :ez, :exy, :eyz, :ezx), <code>name</code> is a title to display, <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off and <code>smooth</code> is a Boolean to toggle smoothing the stress field on or off. If <code>E</code> contains more than one time steps, then a  sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>E</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L4939-L4959">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStressResults-Tuple{TensorField, Any}" href="#LowLevelFEM.showStressResults-Tuple{TensorField, Any}"><code>LowLevelFEM.showStressResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showStressResults(S, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads stress results into a View in Gmsh. <code>S</code> is a stress field to show, <code>comp</code> is the component of the field (:s, :sx, :sy, :sz, :sxy, :syz, :szx, :seqv), <code>name</code> is a title to display, <code>visible</code> is a Boolean to toggle the initial visibility in Gmsh on or off, and <code>smooth</code> is a Boolean to toggle smoothing the stress field on or off. If <code>S</code> contains more than one time step, a sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.</p><p>Returns: <code>tag</code></p><p>Types:</p><ul><li><code>S</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L5106-L5125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.tangentVector-Tuple{Problem, String}" href="#LowLevelFEM.tangentVector-Tuple{Problem, String}"><code>LowLevelFEM.tangentVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tangentVector(problem::Problem, phName::String) -&gt; VectorField</code></pre><p>Compute unit tangent vectors for all nodes of a curve-type physical group in a 3D Gmsh model.</p><p><strong>Arguments</strong></p><ul><li><code>problem::Problem</code>: A <code>Problem</code> structure containing the current Gmsh model (name, dimension, number of nodes, etc.).</li><li><code>phName::String</code>: The name of a physical curve group in Gmsh for which the tangent vectors are computed.</li></ul><p><strong>Description</strong></p><p>The function sets the current model, queries the elements and nodes that belong to the given 1D physical group, and evaluates the gradients of the Lagrange basis functions to determine the local mapping derivative ∂x/∂ξ. Since this derivative represents the geometric tangent direction of the curve at each evaluation point, it is normalized to produce a unit tangent vector.</p><p>Each node belonging to the physical curve group is assigned the corresponding 3D unit tangent vector aligned with the parametric direction of the curve.</p><p><strong>Returns</strong></p><ul><li><code>VectorField</code>: A <code>VectorField</code> structure that stores the nodal tangent vectors on the given physical curve.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if the provided physical group is not of curve type (<code>dim != 1</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using LowLevelFEM

# Load a 3D geometry containing a curved edge
gmsh.initialize()
gmsh.open(&quot;curve_geometry.msh&quot;)

# Create a problem structure
mat = material(&quot;body&quot;)
prob = Problem([mat])

# Compute tangent vectors along the curve named &quot;leadingEdge&quot;
tv = tangentVector(prob, &quot;leadingEdge&quot;)

# Visualize the tangent field
showDoFResults(tv)
openPostProcessor()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3398-L3446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.temperatureConstraint-Tuple{Any}" href="#LowLevelFEM.temperatureConstraint-Tuple{Any}"><code>LowLevelFEM.temperatureConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">temperatureConstraint(name; T=...)</code></pre><p>Specifies temperature constraints on the physical group <code>name</code>. <code>T</code> can be a constant or a function of <code>x</code>, <code>y</code>, and <code>z</code>. (e.g., <code>fn(x,y,z) = 5*(5-x); temperatureConstraint(&quot;surf1&quot;, T=fn)</code>)</p><p>Returns: BoundaryCondition</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>T</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2758-L2770">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.tensorField-Tuple{Any, Any}" href="#LowLevelFEM.tensorField-Tuple{Any, Any}"><code>LowLevelFEM.tensorField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensorField(problem, dataField; type=...)</code></pre><p>Defines a vector field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>. <code>type</code> can be an arbitrary <code>Symbol</code>, e.g., <code>:u</code> or <code>:f</code>.</p><p>Return: TensorField</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{BoundaryCondition}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = sin(x)
f2(x, y, z) = 5y
ff1 = field(&quot;face1&quot;, fx=f1, fy=f2, fz=0, fxy=1, fyz=1, fzx=f2)
ff2 = field(&quot;face2&quot;, fx=f2, fy=f1, fz=1, fxy=1, fyz=f1, fzx=1)
qq = tensorField(problem, [ff1, ff2])
qq0 = showDoFResults(qq)

qq2 = tensorField(problem, &quot;body&quot;, [1 0 0; 0 2 0; 0 0 f1])</code></pre><p>Here TensorField is defined in nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L3088-L3115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.vectorField-Tuple{Any, Any}" href="#LowLevelFEM.vectorField-Tuple{Any, Any}"><code>LowLevelFEM.vectorField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vectorField(problem, dataField; type=...)</code></pre><p>Defines a vector field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>. <code>type</code> can be an arbitrary <code>Symbol</code>, e.g., <code>:u</code> or <code>:f</code>.</p><p>Return: VectorField</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{BoundaryCondition}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = sin(x)
f2(x, y, z) = 5y
ff1 = field(&quot;face1&quot;, fx=f1, fy=f2, fz=0)
ff2 = field(&quot;face2&quot;, fx=f2, fy=f1, fz=1)
qq = vectorField(problem, [ff1, ff2])
qq0 = showDoFResults(qq)

qq2 = vectorField(problem, &quot;body&quot;, [1, 2, ff2])</code></pre><p>Here VectorField is defined in nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L2983-L3010">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.∂-Tuple{ScalarField, Int64}" href="#LowLevelFEM.∂-Tuple{ScalarField, Int64}"><code>LowLevelFEM.∂</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂(r::ScalarField, dir::Int) -&gt; ScalarField</code></pre><p>Compute the spatial derivative of a scalar field in the global <code>x</code>, <code>y</code>, or <code>z</code> direction. The input field may be nodal or elementwise; nodal fields are automatically converted to elementwise form using <code>nodesToElements(r)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>r::ScalarField</code>: scalar field to differentiate.</li><li><code>dir::Int</code>: spatial direction:<ul><li><code>1</code> → ∂/∂x  </li><li><code>2</code> → ∂/∂y  </li><li><code>3</code> → ∂/∂z</li></ul></li></ul><p><strong>Returns</strong></p><p>A new <code>ScalarField</code> in <strong>elementwise representation</strong>, containing   the gradient component ∂r/∂(dir) at all nodes of each element.</p><p><strong>Notes</strong></p><ul><li>Works for 1D, 2D, and 3D meshes.</li><li>Uses the element Jacobian and shape-function derivatives in global coordinates.</li><li>The global problem mesh is accessed via <code>r.model</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1546-L1568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.∂e-Tuple{ScalarField, Int64}" href="#LowLevelFEM.∂e-Tuple{ScalarField, Int64}"><code>LowLevelFEM.∂e</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂e(r::ScalarField, dir::Int) -&gt; ScalarField</code></pre><p>Compute the spatial derivative of an <strong>elementwise</strong> scalar field purely at the element level, without nodal conversion. This avoids mixing contributions from neighboring elements and is suitable for discontinuous fields or post-processing of elementwise quantities.</p><p><strong>Arguments</strong></p><ul><li><code>r::ScalarField</code>: must already be elementwise (<code>isElementwise(r) == true</code>).</li><li><code>dir::Int</code>: spatial direction (1 → x, 2 → y, 3 → z).</li></ul><p><strong>Returns</strong></p><p>An elementwise <code>ScalarField</code> containing the derivative ∂r/∂(dir) at the local nodes of each element.</p><p><strong>Notes</strong></p><ul><li>Uses the element-local Jacobian per integration point.</li><li>Safer for interfaces or discontinuities than nodal differentiation.</li><li>Only elementwise → elementwise transformations are performed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1688-L1708">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.∂x-Tuple{ScalarField}" href="#LowLevelFEM.∂x-Tuple{ScalarField}"><code>LowLevelFEM.∂x</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂x(r::ScalarField)
∂y(r::ScalarField)
∂z(r::ScalarField)</code></pre><p>Compute directional derivatives of a scalar field <code>r</code> with respect to the global coordinates x, y, or z.</p><p>These functions are convenience wrappers that automatically choose between   the nodal differentiation (<code>∂</code>) and the elementwise differentiation (<code>∂e</code>) depending on the representation of the input field.</p><p><strong>Dispatch logic</strong></p><ul><li>If <code>isNodal(r)</code> is <code>true</code>:  <ul><li><code>∂x(r)</code> → <code>∂(r, 1)</code>  </li><li><code>∂y(r)</code> → <code>∂(r, 2)</code>  </li><li><code>∂z(r)</code> → <code>∂(r, 3)</code>  </li></ul></li><li>Otherwise (elementwise field):  <ul><li><code>∂x(r)</code> → <code>∂e(r, 1)</code>  </li><li><code>∂y(r)</code> → <code>∂e(r, 2)</code>  </li><li><code>∂z(r)</code> → <code>∂e(r, 3)</code></li></ul></li></ul><p><strong>Coordinate conventions</strong></p><ul><li>In <strong>3D</strong>: <code>(x, y, z)</code> are the global Cartesian coordinates.</li><li>In <strong>2D (plane stress/strain)</strong>:  <ul><li><code>∂x</code> and <code>∂y</code> operate in the plane.  </li><li><code>∂z</code> is mathematically allowed and returns zero for planar meshes.</li></ul></li></ul><p><strong>Returns</strong></p><p>A <code>ScalarField</code> storing the derivative in <strong>elementwise</strong> representation.</p><p><strong>Examples</strong></p><p><strong>1) Derivative of a nodal field (automatic nodal→element conversion)</strong></p><pre><code class="language-julia hljs">s = ScalarField(prob, &quot;vol&quot;, (x,y,z) -&gt; x^2 + y)

dxs = ∂x(s)      # computes 2x
dys = ∂y(s)      # computes 1
dzs = ∂z(s)      # computes 0</code></pre><p><strong>2) Derivative of an elementwise field</strong></p><pre><code class="language-julia hljs">se = elementsToNodes(s) |&gt; r -&gt; ∂e(r, 1)  # manually
dxs = ∂x(se)                              # same result, auto-detected</code></pre><p><strong>3) Works on 2D meshes as well</strong></p><pre><code class="language-julia hljs">s = ScalarField(prob2D, &quot;surf&quot;, (x,y,z) -&gt; x - y)

dxs = ∂x(s)      # = 1 everywhere
dys = ∂y(s)      # = -1 everywhere
dzs = ∂z(s)      # = zero field (2D mesh)</code></pre><p><strong>4) Using derivatives to build a gradient vector field</strong></p><pre><code class="language-julia hljs">s = ScalarField(prob, &quot;vol&quot;, (x,y,z) -&gt; sin(x)*y)

gx = ∂x(s)       # y*cos(x)
gy = ∂y(s)       # sin(x)
gz = ∂z(s)       # 0

grad_s = VectorField([gx, gy, gz])</code></pre><p><strong>Notes</strong></p><ul><li>The output is always <strong>elementwise</strong>, enabling consistent post-processing.</li><li>Direction indices follow FEM convention: 1 → x, 2 → y, 3 → z.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/116de94cd862514c076163e09bec0e841fda49d2/src/general.jl#L1830-L1907">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../Linear/">Linear »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 20 January 2026 07:52">Tuesday 20 January 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
