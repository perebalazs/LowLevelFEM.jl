<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · LowLevelFEM</title><meta name="title" content="Functions · LowLevelFEM"/><meta property="og:title" content="Functions · LowLevelFEM"/><meta property="twitter:title" content="Functions · LowLevelFEM"/><meta name="description" content="Documentation for LowLevelFEM."/><meta property="og:description" content="Documentation for LowLevelFEM."/><meta property="twitter:description" content="Documentation for LowLevelFEM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelFEM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../Examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/main/docs/src/Functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LowLevelFEM.jl"><a class="docs-heading-anchor" href="#LowLevelFEM.jl">LowLevelFEM.jl</a><a id="LowLevelFEM.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LowLevelFEM.jl" title="Permalink"></a></h1><p>Documentation for LowLevelFEM.jl</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CoordinateSystem" href="#LowLevelFEM.CoordinateSystem"><code>LowLevelFEM.CoordinateSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoordinateSystem(vec1, vec2)</code></pre><p>A structure containing the data of a coordinate system.</p><ul><li><code>vec1</code>: direction of the new x axis.</li><li><code>vec2</code>: together with <code>vec1</code> determine the xy plane</li></ul><p>If the problem is two dimensional, it is enough to give the first two elements of <code>vec1</code>. Elements of <code>vec1</code> and <code>vec2</code> can be functions. In 3D case the functions have three arguments (x, y, and z coordinates), otherwise (in 2D case) the number of arguments is two (x and y coordinates).</p><p>Types:</p><ul><li><code>vec1</code>: Vector{Float64}</li><li><code>vec2</code>: Vector{Float64}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 2D case
nx(x, y) = x
ny(x, y) = y
cs = FEM.CoordinateSystem([nx, ny])
Q = FEM.rotateNodes(problem, &quot;body&quot;, cs)
q2 = Q&#39; * q1 # where `q1` is in Cartesian, `q2` is in Axisymmetric coordinate system and
             # `q1` is a nodal displacement vector.
S2 = Q&#39; * S1 * Q # where `S1` is a stress field in Cartesian coordinate system while
                 # `S2` is in Axisymmetric coordinate system.

# 3D case
n1x(x, y, z) = x
n1y(x, y, z) = y
n2x(x, y, z) = -y
n2y = n1x
cs = FEM.CoordinateSystem([n1x, n1y, 0], [n2x, n2y, 0])
Q = FEM.rotateNodes(problem, &quot;body&quot;, cs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L413-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Eigen" href="#LowLevelFEM.Eigen"><code>LowLevelFEM.Eigen</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Eigen(f, ϕ)</code></pre><p>A structure containing the eigenfrequencies and eigen modes.</p><ul><li>f: eigenfrequencies</li><li>ϕ: eigen modes</li></ul><p>Types:</p><ul><li><code>f</code>: Matrix{Float64}</li><li><code>ϕ</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L491-L501">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Material" href="#LowLevelFEM.Material"><code>LowLevelFEM.Material</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Material(phName, type, E, ν, ρ, k, c, α, λ, μ, κ)</code></pre><p>A structure containing the material constants.</p><ul><li>type: constitutive law: <code>:Hooke</code>, <code>:StVenantKirchhoff</code>, <code>:NeoHookeCompressible</code></li><li>E: elastic modulus,</li><li>ν: Poisson&#39;s ratio,</li><li>ρ: mass density,</li><li>k: heat conductivity,</li><li>c: specific heat,</li><li>α: heat expansion coefficient</li><li>λ: Lamé parameter</li><li>μ: Lamé parameter</li><li>κ: Bulk modulus</li></ul><p><code>phName</code> is the name of the physical group where the given material is used.</p><p>Types:</p><ul><li><code>phName</code>: String</li><li><code>type</code>: Symbol</li><li><code>E</code>: Float64</li><li><code>ν</code>: Float64</li><li><code>ρ</code>: Float64</li><li><code>k</code>: Float64</li><li><code>c</code>: Float64</li><li><code>α</code>: Float64</li><li><code>λ</code>: Float64</li><li><code>μ</code>: Float64</li><li><code>κ</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Problem" href="#LowLevelFEM.Problem"><code>LowLevelFEM.Problem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Problem(materials; thickness=..., type=..., bandwidth=...)</code></pre><p>A structure containing the most important data of the problem. </p><ul><li>Parts of the model with their material constants. More materials can be given. (see <code>material</code> function)</li><li>type of the problem: 3D <code>:Solid</code>, <code>:PlaneStrain</code>, <code>:PlaneStress</code>, <code>:AxiSymmetric</code>, <code>:PlaneHeatConduction</code>, <code>:HeatConduction</code>, <code>:AxiSymmetricHeatConduction</code>. In the case of <code>:AxiSymmetric</code>, the axis of symmetry is the &quot;y&quot; axis,  while the geometry must be drawn in the positive &quot;x&quot; half-plane.</li><li>bandwidth optimization using built-in <code>gmsh</code> function. Possibilities: <code>:RCMK</code>, <code>:Hilbert</code>, <code>:Metis</code> or <code>:none</code> (default)</li><li>dimension of the problem, determined from <code>type</code></li><li>material constants: Young&#39;s modulus, Poisson&#39;s ratio, mass density, heat conduction corfficient, specific heat, heat  expansion coefficient (in a vector of material structure <code>materials</code>)</li><li>thickness of the plate</li><li>number of nodes (non)</li></ul><p>Types:</p><ul><li><code>materials</code>: Material</li><li><code>type</code>: Symbol</li><li><code>bandwidth</code>: String</li><li><code>dim</code>: Integer</li><li><code>thickness</code>: Float64</li><li><code>non</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L48-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.ScalarField" href="#LowLevelFEM.ScalarField"><code>LowLevelFEM.ScalarField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScalarField(A, a, t, numElem, nsteps, type)
ScalarField(problem, dataField)</code></pre><p>A structure containing the data of a heat flux field. </p><ul><li>A: vector of ElementNodeData type scalar data (see gmsh.jl)</li><li>numElem: vector of tags of elements</li><li>nsteps: number of stress fields stored in <code>A</code> (for animations).</li><li>type: type of data (eg. heat flux <code>:q</code>)</li></ul><p>Types:</p><ul><li><code>A</code>: Vector{Vector{Float64}}</li><li><code>a</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li><li><code>numElem</code>: Vector{Integer}</li><li><code>nsteps</code>: Integer</li><li><code>type</code>: Symbol</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L244-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.TensorField" href="#LowLevelFEM.TensorField"><code>LowLevelFEM.TensorField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TensorField(A, a, t, numElem, nsteps, type)</code></pre><p>A structure containing the data of a stress or strain field. </p><ul><li>A: vector of ElementNodeData type stress data (see gmsh.jl)</li><li>numElem: vector of tags of elements</li><li>nsteps: number of stress fields stored in <code>A</code> (for animations).</li><li>type: type of data (eg. stress <code>:s</code> and strain <code>:e</code>)</li></ul><p>Types:</p><ul><li><code>A</code>: Vector{Matrix{Float64}}</li><li><code>a</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li><li><code>numElem</code>: Vector{Integer}</li><li><code>nsteps</code>: Integer</li><li><code>type</code>: Symbol</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L352-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.VectorField" href="#LowLevelFEM.VectorField"><code>LowLevelFEM.VectorField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorField(A, a, t, numElem, nsteps, type)</code></pre><p>A structure containing the data of a heat flux field. </p><ul><li>A: vector of ElementNodeData type heat flux data (see gmsh.jl)</li><li>numElem: vector of tags of elements</li><li>nsteps: number of stress fields stored in <code>A</code> (for animations).</li><li>type: type of data (eg. heat flux <code>:q</code>)</li></ul><p>Types:</p><ul><li><code>A</code>: Vector{Matrix{Float64}}</li><li><code>a</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li><li><code>numElem</code>: Vector{Integer}</li><li><code>nsteps</code>: Integer</li><li><code>type</code>: Symbol</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L325-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDM-NTuple{8, Any}" href="#LowLevelFEM.CDM-NTuple{8, Any}"><code>LowLevelFEM.CDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.CDM(K, M, C, f, u0, v0, T, Δt)</code></pre><p>Solves a transient dynamic problem using central difference method (CDM) (explicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>C</code> is the damping matrix, <code>f</code> is the load vector, <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the upper bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time step size. Returns the displacement vectors and velocity vectors in each time step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code> of the time instants used.</p><p>The critical (largest allowed) time step is <code>Δtₘₐₓ = Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ)</code> where <code>Tₘᵢₙ</code> is the time period of the largest eigenfrequency and <code>ξₘₐₓ</code> is the largest modal damping.</p><p>Return: <code>u</code>, <code>v</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>C</code>: SparseMatrix</li><li><code>f</code>: VectorField</li><li><code>u0</code>: VectorField</li><li><code>v0</code>: VectorField</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>u</code>: VectorField</li><li><code>v</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2455-L2483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the CDM method.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:PDR</code>: physical damping ratio</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. The damping matrix is assembled in the  following ways: <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. If <code>show_β</code> or <code>show_ξ</code> is <code>true</code>, the corresponding <code>β</code> or <code>ξ</code> values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>show_β</code>: Boolean</li><li><code>show_ξ</code>: Boolean</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2618-L2658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.FDM-NTuple{6, Any}" href="#LowLevelFEM.FDM-NTuple{6, Any}"><code>LowLevelFEM.FDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.FDM(K, C, q, T0, tₘₐₓ, Δt; ϑ=...)</code></pre><p>Solves a transient heat conduction problem using Finite Difference Method (FDM). Introducing a <code>ϑ</code> parameter, special cases can be used as the Forward Euler (explicit, ϑ=0), Backward Euler (implicit, ϑ=1), Crank-Nicolson (ϑ=0.5) and intermediate cases (0&lt;ϑ&lt;1). (This method is known as ϑ-method. See <sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup>.) <code>K</code> is the heat conduction matrix, <code>C</code> is the heat capacity matrix, <code>q</code> is the heat flux vector, <code>T0</code> is the initial temperature, <code>tₘₐₓ</code> is the upper  bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time step size. Returns the nodal temperature vectors in each time  step arranged in the columns of the matrix <code>T</code> and a vector <code>t</code> of the time instants used.</p><p>The critical (largest allowed) time step is <code>Δtₘₐₓ = 2 / ((1-2ϑ)*λₘₐₓ)</code> where <code>λₘₐₓ</code> is the largest eigenvalue of (<strong>K</strong>+λ<strong>C</strong>)<strong>θ</strong>=<strong>0</strong>  eigenvalue problem and <code>ϑ</code> is the parameter of the ϑ-method. Default value of <code>ϑ</code> is 1/2.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>C</code>: SparseMatrix</li><li><code>q</code>: ScalarField</li><li><code>T0</code>: ScalarField</li><li><code>tₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L1271-L1302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHT-NTuple{7, Any}" href="#LowLevelFEM.HHT-NTuple{7, Any}"><code>LowLevelFEM.HHT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.HHT(K, M, f, u0, v0, T, Δt; α=..., δ=..., γ=..., β=...)</code></pre><p>Solves a transient dynamic problem using HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (implicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>f</code> is the load vector,  <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the  upper bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time  step size. Returns the displacement vectors and velocity vectors in each time  step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code>  of the time instants used. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)².</p><p>Return: <code>u</code>, <code>v</code>, <code>t</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>f</code>: Vector{Float64}</li><li><code>u0</code>: Vector{Float64}</li><li><code>v0</code>: Vector{Float64}</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>u</code>: Matrix{Float64}</li><li><code>v</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2530-L2563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> and <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2717-L2751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{Any, Matrix, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{Any, Matrix, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions!(problem, dispVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a displacement vector <code>dispVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dispVec</code>: Vector{Float64}</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1323-L1336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions!(problem, stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>loadVec</code>: Vector </li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1043-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions!(problem, heatCondMat, heatCapMat, heatFluxVec, supports)</code></pre><p>Applies boundary conditions <code>supports</code> on a heat conduction matrix <code>heatCondMat</code>, heat capacity matrix <code>heatCapMat</code> and heat flux vector <code>heatFluxVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed temperature <code>T</code>.</p><p>Return: <code>stiffMat</code>, <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>loadVec</code>: Vector </li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1103-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions!(problem, stiffMat, massMat, dampMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code>, mass matrix <code>massMat</code>, damping matrix <code>dampMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>massMat</code>: SparseMatrix </li><li><code>dampMat</code>: SparseMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1152-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions(problem, stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>. Creates a new stiffness matrix and load vector.</p><p>Return: <code>stiffMat</code>, <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>loadVec</code>: Vector </li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1072-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}" href="#LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}"><code>LowLevelFEM.applyDeformationBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyDeformationBoundaryConditions!(problem, deformVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on deformation vector <code>deformVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>deformVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/nonlinear.jl#L977-L990">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}" href="#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}"><code>LowLevelFEM.applyElasticSupport!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyElasticSupport!(problem, stiffMat, elastSupp)</code></pre><p>Applies elastic support boundary conditions <code>elastSupp</code> on a stiffness matrix <code>stiffMat</code>. Mesh details are in <code>problem</code>. <code>elastSupp</code> is a tuple of <code>name</code> of physical group and prescribed <code>kx</code>, <code>ky</code> and <code>kz</code> stiffnesses.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>elastSupp</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1392-L1405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyHeatConvection!-NTuple{4, Any}" href="#LowLevelFEM.applyHeatConvection!-NTuple{4, Any}"><code>LowLevelFEM.applyHeatConvection!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyHeatConvection!(problem, heatCondMat, heatFluxVec, heatConv)</code></pre><p>Applies heat convectiom boundary conditions <code>heatConv</code> on a heat conduction matrix <code>heatCondMat</code> and heat flux vector <code>heatFluxVec</code>. Mesh details are in <code>problem</code>. <code>heatConv</code> is a tuple of <code>name</code> of physical group and prescribed heat transfer coefficient <code>h</code> and ambient temperature <code>Tₐ</code>. The ambient temperature can be either a constant or a  function of x, y and z coordinates.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatCondMat</code>: SparseMatrix </li><li><code>heatFluxVec</code>: Vector </li><li><code>heatConv</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L900-L916">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.constrainedDoFs-Tuple{Any, Any}" href="#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}"><code>LowLevelFEM.constrainedDoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.constrainedDoFs(problem, supports)</code></pre><p>Returns the serial numbers of constrained degrees of freedom. Support is a vector of boundary conditions given with the function <code>displacementConstraint</code>.</p><p>Return: <code>DoFs</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>DoFs</code>: Vector{Int64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2360-L2371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}" href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)</code></pre><p>Generates the damping matrix for proportional damping case. <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅. The latter corresponds  to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. <code>K</code> is the stiffness matrix, <code>M</code> is the mass matrix and <code>ωₘₐₓ</code> is the  largest natural frequency.</p><p>Return: <code>dampingMatrix</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>α</code>: Float64</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>dampingMatrix</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L677-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.displacementConstraint-Tuple{Any}" href="#LowLevelFEM.displacementConstraint-Tuple{Any}"><code>LowLevelFEM.displacementConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.displacementConstraint(name; ux=..., uy=..., uz=...)</code></pre><p>Gives the displacement constraints on <code>name</code> physical group. At least one <code>ux</code>,  <code>uy</code> or <code>uz</code> value have to be given (depending on the dimension of the problem). <code>ux</code>, <code>uy</code> or <code>uz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.displacementConstraint(&quot;support1&quot;, ux=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>ux</code>: Float64 or Function</li><li><code>uy</code>: Float64 or Function</li><li><code>uz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1870-L1885">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elasticSupport-Tuple{Any}" href="#LowLevelFEM.elasticSupport-Tuple{Any}"><code>LowLevelFEM.elasticSupport</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.elasticSupport(name; kx=..., ky=..., kz=...)</code></pre><p>Gives the distributed stiffness of the elastic support on <code>name</code> physical group. <code>kx</code>, <code>ky</code> or <code>kz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.elasticSupport(&quot;supp1&quot;, kx=fn)</code>) Default values are 1.</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>kx</code>: Float64 or Function</li><li><code>ky</code>: Float64 or Function</li><li><code>kz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1912-L1927">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}" href="#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}"><code>LowLevelFEM.elasticSupportMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.elasticSupportMatrix(problem, elSupp)</code></pre><p>Solves the elastic support matrix of the <code>problem</code>. <code>elSupp</code> is a vector of elastic supports defined in function <code>FEM.elasticSupport</code>. With the displacementent vector <code>q</code> in hand the reaction force vector <code>fR</code> arising from the elastic support can be solved. (<code>fR = heatConvMat * q</code>)</p><p>Return: <code>elSuppMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>elSupp</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>elSuppMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L726-L740">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elementsToNodes-Tuple{Any}" href="#LowLevelFEM.elementsToNodes-Tuple{Any}"><code>LowLevelFEM.elementsToNodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.elementsToNodes(problem, T)</code></pre><p>Solves the nodal results <code>F</code> from the elemental results <code>T</code>. <code>T</code> can be tensor field or vector field.</p><p>Return: <code>F</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>T</code>: TensorField or VectorField</li><li><code>F</code>: TensorField or VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2428-L2440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.field-Tuple{Any}" href="#LowLevelFEM.field-Tuple{Any}"><code>LowLevelFEM.field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.field(name; f=..., fx=..., fy=..., fz=..., fxy=..., fyz=..., fzx=...)</code></pre><p>Gives the value of scalar, vector or tensor field on <code>name</code> physical group. At least one <code>fx</code>,  <code>fy</code> or <code>fz</code> etc. value have to be given (depending on the dimension of the problem). <code>fx</code>,  <code>fy</code> or <code>fz</code> etc. can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.field(&quot;surf1&quot;, fx=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function,...x7}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>f</code>: Float64 or Function</li><li><code>fx</code>: Float64 or Function</li><li><code>fy</code>: Float64 or Function</li><li><code>fz</code>: Float64 or Function</li><li><code>fxy</code>: Float64 or Function</li><li><code>fyz</code>: Float64 or Function</li><li><code>fzx</code>: Float64 or Function</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = y
f2 = FEM.field(&quot;face1&quot;, f=f1)
qq = FEM.scalarField(problem, [f2])
qqq = FEM.showDoFResults(problem, qq, :scalar)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2041-L2069">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.fieldError-Tuple{Any, Any}" href="#LowLevelFEM.fieldError-Tuple{Any, Any}"><code>LowLevelFEM.fieldError</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.fieldError(problem, F)</code></pre><p>Solves the deviation of field results <code>F</code> (stresses, strains, heat flux components) at nodes, where the field has jumps. The result can be displayed with the <code>showDoFResults</code> function.</p><p>Return: <code>e</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>F</code>: TensorField or VectorField</li><li><code>e</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2704-L2716">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.freeDoFs-Tuple{Any, Any}" href="#LowLevelFEM.freeDoFs-Tuple{Any, Any}"><code>LowLevelFEM.freeDoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.freeDoFs(problem, supports)</code></pre><p>Returns the serial numbers of unconstrained degrees of freedom. Support is a vector of boundary conditions given with the function <code>displacementConstraint</code>.</p><p>Return: <code>DoFs</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>DoFs</code>: Vector{Int64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2409-L2420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.generateMesh-Tuple{Any, Any}" href="#LowLevelFEM.generateMesh-Tuple{Any, Any}"><code>LowLevelFEM.generateMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.generateMesh(problem, surf, elemSize; approxOrder=1, algorithm=6, quadrangle=0, internalNodes=0)</code></pre><p>Obsolate, use gmsh script (.geo) instead.</p><p>Return: none</p><p>Types:</p><ul><li>``: x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2014-L2023">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getTagForPhysicalName-Tuple{Any}" href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.getTagForPhysicalName(name)</code></pre><p>Returns <code>tags</code> of elements of physical group <code>name</code>.</p><p>Return: <code>tags</code></p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>tags</code>: Vector{Integer}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1129-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatCapacityMatrix-Tuple{Any}" href="#LowLevelFEM.heatCapacityMatrix-Tuple{Any}"><code>LowLevelFEM.heatCapacityMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatCapacityMatrix(problem; lumped=...)</code></pre><p>Solves the heat capacity matrix of the <code>problem</code>. If <code>lumped</code> is true, solves lumped heat capacity matrix.</p><p>Return: <code>heatCapMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>lumped</code>: Boolean</li><li><code>massMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L228-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConductionMatrix-Tuple{Any}" href="#LowLevelFEM.heatConductionMatrix-Tuple{Any}"><code>LowLevelFEM.heatConductionMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatConductionMatrix(problem)</code></pre><p>Solves the heat conduction matrix of the <code>problem</code>.</p><p>Return: <code>heatCondMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatCondMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConvection-Tuple{Any}" href="#LowLevelFEM.heatConvection-Tuple{Any}"><code>LowLevelFEM.heatConvection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatConvection(name; h=..., Tₐ=...)</code></pre><p>Gives the heat convection of the surface given with <code>name</code> physical group. <code>h</code> is the heat transfer coefficient of the surrounding media, <code>Tₐ</code> is the ambient temperature. The ambient temperature can be either a constant or a function of x, y and z.</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>h</code>: Float64</li><li><code>Tₐ</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1993-L2007">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}" href="#LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatConvectionMatrix(problem, heatConvection)</code></pre><p>Solves the heat convection matrix of the <code>problem</code>. <code>heatConvection</code>  is a vector of heat convection boundary condicions defined in function <code>FEM.heatConduction</code>. With the heat convection vector (see the <code>heatConvectionVector</code> function) <code>heatConvVec</code>, temperature field vector <code>T</code> in hand the heat flux vector <code>qCV</code> arising from the heat convection boundary condition can be solved. <code>qCV = heatConvMat * T - heatConvVec</code></p><p>Return: <code>heatConvMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatConvection</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatConvMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L526-L541">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConvectionVector-Tuple{Any, Any}" href="#LowLevelFEM.heatConvectionVector-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatConvectionVector(problem, heatConvection)</code></pre><p>Solves a heat convection vector of <code>problem</code>. <code>heatConvection</code>  is a vector of heat convection boundary condicions defined in function <code>FEM.heatConduction</code>. With the heat convection matrix (see the <code>heatConvectionMatrix</code> function) <code>heatConvMat</code>, temperature field vector <code>T</code> in hand the heat flux vector <code>qCV</code> arising from the heat convection boundary condition can be solved. <code>qCV = heatConvMat * T - heatConvVec</code></p><p>Return: <code>heatConvVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatConvection</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatConvVec</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L606-L621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatFlux-Tuple{Any}" href="#LowLevelFEM.heatFlux-Tuple{Any}"><code>LowLevelFEM.heatFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatFlux(name; qn=...)</code></pre><p>Gives the heat flux normal to the surface of <code>name</code> physical group. <code>qn</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.load(&quot;flux1&quot;, qn=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>qn</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1951-L1963">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatFluxVector-Tuple{Any, Any}" href="#LowLevelFEM.heatFluxVector-Tuple{Any, Any}"><code>LowLevelFEM.heatFluxVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatFluxVector(problem, heatFlux)</code></pre><p>Solves a heat flux or heat source vector of <code>problem</code>. <code>heatFlux</code> is a tuple of name of physical group  <code>name</code>, heat flux <code>qn</code> normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.</p><ul><li>In case of 2D problems and Point physical group means concentrated heat flux.</li><li>In case of 2D problems and Line physical group means surface heat flux.</li><li>In case of 2D problems and Surface physical group means body heat source.</li><li>In case of 3D problems and Point physical group means concentrated heat flux.</li><li>In case of 3D problems and Line physical group means edge heat source.</li><li>In case of 3D problems and Surface physical group means surface heat flux.</li><li>In case of 3D problems and Volume physical group means body heat source.</li></ul><p>Return: <code>heatFluxVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatFlux</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatFluxVec</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L549-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatSource-Tuple{Any}" href="#LowLevelFEM.heatSource-Tuple{Any}"><code>LowLevelFEM.heatSource</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatSource(name; h=...)</code></pre><p>Gives the body heat source in <code>name</code> physical group. <code>h</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.load(&quot;source1&quot;, h=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>h</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1972-L1984">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatSourceVector-Tuple{Any, Any}" href="#LowLevelFEM.heatSourceVector-Tuple{Any, Any}"><code>LowLevelFEM.heatSourceVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.heatSourceVector(problem, heatSource)</code></pre><p>Solves a heat flux or heat source vector of <code>problem</code>. <code>heatSource</code> is a tuple of name of physical group  <code>name</code>, heat flux <code>qn</code> normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.</p><ul><li>In case of 2D problems and Point physical group means concentrated heat flux.</li><li>In case of 2D problems and Line physical group means surface heat flux.</li><li>In case of 2D problems and Surface physical group means body heat source.</li><li>In case of 3D problems and Point physical group means concentrated heat flux.</li><li>In case of 3D problems and Line physical group means edge heat source.</li><li>In case of 3D problems and Surface physical group means surface heat flux.</li><li>In case of 3D problems and Volume physical group means body heat source.</li></ul><p>Same as the <code>heatFluxVector</code> function.</p><p>Return: <code>heatSourceVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatSource</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatSourceVec</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L577-L598">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement!-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialDisplacement!(problem, name, u0; ux=..., uy=..., uz=...)</code></pre><p>Changes the displacement values to <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in displacement vector <code>u0</code>.</p><p>Return: u0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li><li><code>u0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2231-L2247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialDisplacement(problem, name; ux=..., uy=..., uz=...)</code></pre><p>Sets the displacement values <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial displacement vector <code>u0</code>.</p><p>Return: u0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>u0</code>: VectorField</li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2183-L2199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialTemperature!-Tuple{Any, Any}" href="#LowLevelFEM.initialTemperature!-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialTemperature!(problem, name, T0; T=...)</code></pre><p>Changes the tempetature value to <code>T</code> at nodes belonging to physical group <code>name</code>. Original values are in temperature vector <code>T0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>T0</code>: ScalarField</li><li><code>T</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L1245-L1258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialTemperature-Tuple{Any, Any}" href="#LowLevelFEM.initialTemperature-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialTemperature(problem, name; T=...)</code></pre><p>Sets the temperature value <code>T</code> at nodes belonging to physical group <code>name</code>. Returns the <code>T0</code> initial nodal temperature vector.</p><p>Return: T0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>T</code>: Float64 </li><li><code>T0</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L1218-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity!-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialVelocity!(problem, name, v0; vx=..., vy=..., vz=...)</code></pre><p>Changes the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in velocity vector <code>v0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>v0</code>: Vector{Float64}</li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2292-L2308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialVelocity(problem, name; vx=..., vy=..., vz=...)</code></pre><p>Sets the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial velocity vector <code>v0</code>.</p><p>Return: v0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li><li><code>v0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2271-L2287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestEigenValue-Tuple{Any, Any}" href="#LowLevelFEM.largestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.largestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.largestEigenValue(K, M)</code></pre><p>Solves the smallest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘᵢₙ</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>λₘᵢₙ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2431-L2443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.largestPeriodTime(K, M)</code></pre><p>Solves the largest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2355-L2367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}" href="#LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.latentHeatMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.latentHeatMatrix(problem, u, v, T0)</code></pre><p>Solves the latent heat matrix of the <code>problem</code>. With this matrix the generated heat due to deformations (given with displacement field <code>u</code> and velocity field <code>v</code>) can be solved. <code>T0</code> is the current temperature field which is given in absolute temperature scale (Kelvin).</p><p>Return: <code>latHeatMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>u</code>: VectorField</li><li><code>v</code>: VectorField</li><li><code>T0</code>: ScalarField</li><li><code>latHeatMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L360-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.load-Tuple{Any}" href="#LowLevelFEM.load-Tuple{Any}"><code>LowLevelFEM.load</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.load(name; fx=..., fy=..., fz=...)</code></pre><p>Gives the intensity of distributed load on <code>name</code> physical group. At least one <code>fx</code>,  <code>fy</code> or <code>fz</code> value have to be given (depending on the dimension of the problem). <code>fx</code>,  <code>fy</code> or <code>fz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.load(&quot;load1&quot;, fx=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>fx</code>: Float64 or Function</li><li><code>fy</code>: Float64 or Function</li><li><code>fz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1891-L1906">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.loadVector-Tuple{Any, Any}" href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.loadVector(problem, loads)</code></pre><p>Solves a load vector of <code>problem</code>. <code>loads</code> is a tuple of name of physical group  <code>name</code>, coordinates <code>fx</code>, <code>fy</code> and <code>fz</code> of the intensity of distributed force. It can solve traction or body force depending on the problem.</p><ul><li>In case of 2D problems and Point physical group means concentrated force.</li><li>In case of 2D problems and Line physical group means surface force.</li><li>In case of 2D problems and Surface physical group means body force.</li><li>In case of 3D problems and Point physical group means concentrated force.</li><li>In case of 3D problems and Line physical group means edge force.</li><li>In case of 3D problems and Surface physical group means surface force.</li><li>In case of 3D problems and Volume physical group means body force.</li></ul><p>Return: <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>loadVec</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L885-L905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.massMatrix-Tuple{Any}" href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.massMatrix(problem; lumped=...)</code></pre><p>Solves the mass matrix of the <code>problem</code>. If <code>lumped</code> is true, solves lumped mass matrix.</p><p>Return: <code>massMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>lumped</code>: Boolean</li><li><code>massMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L543-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.material-Tuple{Any}" href="#LowLevelFEM.material-Tuple{Any}"><code>LowLevelFEM.material</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.material(name; type=:Hooke, E=2.0e5, ν=0.3, ρ=7.85e-9, k=45, c=4.2e8, α=1.2e-5, λ=νE/(1+ν)/(1-2ν), μ=E/(1+ν)/2, κ=E/(1-2ν)/3)</code></pre><p>Returns a structure in which <code>name</code> is the name of a physical group, <code>type</code> is the name of the constitutive law (eg. <code>:Hooke</code>), <code>E</code> is the modulus of elasticity, <code>ν</code> Poisson&#39;s ratio and <code>ρ</code> is the mass density, <code>k</code> is the heat conductivity, <code>c</code> is the specific heat, <code>α</code> is the coefficient of heat expansion, <code>λ</code> and <code>μ</code> are the  Lamé parameters, <code>κ</code> is the Bulk modulus.</p><p>Return: mat</p><p>Types:</p><ul><li><code>mat</code>: Material</li><li><code>name</code>: String</li><li><code>type</code>: Symbol</li><li><code>E</code>: Float64</li><li><code>ν</code>: Float64</li><li><code>ρ</code>: Float64</li><li><code>k</code>: Float64</li><li><code>c</code>: Float64</li><li><code>α</code>: Float64</li><li><code>λ</code>: Float64</li><li><code>μ</code>: Float64</li><li><code>κ</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L508-L533">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalAcceleration!-Tuple{Any, Any}" href="#LowLevelFEM.nodalAcceleration!-Tuple{Any, Any}"><code>LowLevelFEM.nodalAcceleration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.nodalAcceleration!(problem, name, a0; ax=..., ay=..., az=...)</code></pre><p>Changes the acceleration values <code>ax</code>, <code>ay</code> and <code>az</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in acceleration vector <code>a0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>a0</code>: Vector{Float64}</li><li><code>ax</code>: Float64</li><li><code>ay</code>: Float64</li><li><code>az</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2334-L2350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalForce!-Tuple{Any, Any}" href="#LowLevelFEM.nodalForce!-Tuple{Any, Any}"><code>LowLevelFEM.nodalForce!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.nodalForce!(problem, name, f0; fx=..., fy=..., fz=...)</code></pre><p>Changes the force values <code>fx</code>, <code>fy</code> and <code>fz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in load vector <code>f0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>f0</code>: Vector{Float64}</li><li><code>fx</code>: Float64 </li><li><code>fy</code>: Float64 </li><li><code>fz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2313-L2329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.nonLinearStiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.nonLinearStiffnessMatrix(problem, q)</code></pre><p>Solves the nonlinear stiffness matrix of the <code>problem</code>. <code>q</code> is a displacement field.</p><p>Return: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: Vector{Float64}</li><li><code>stiffMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L256-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.openPostProcessor-Tuple{}" href="#LowLevelFEM.openPostProcessor-Tuple{}"><code>LowLevelFEM.openPostProcessor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.openPostProcessor(; model=...)</code></pre><p>Launches the GMSH postprocessor window with open postprocessor tree (of <code>model</code>).</p><p>Return: none</p><p>Types:</p><ul><li><code>model</code>: Int64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3848-L3857">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.openPreProcessor-Tuple{}" href="#LowLevelFEM.openPreProcessor-Tuple{}"><code>LowLevelFEM.openPreProcessor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.openPreProcessor(; openGL=...)</code></pre><p>Launches the GMSH preprocessor window with openGL disabled by default.</p><p>Return: none</p><p>Types:</p><ul><li><code>openGL</code>: Boolean</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3829-L3838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.plotOnPath-Tuple{Any, Any}" href="#LowLevelFEM.plotOnPath-Tuple{Any, Any}"><code>LowLevelFEM.plotOnPath</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.plotOnPath(problem, pathName, field; points=100, step=..., plot=..., name=..., visible=..., offsetX=..., offsetY=..., offsetZ=...)</code></pre><p>Load a 2D plot on a path into a View in gmsh. <code>field</code> is the number of View in gmsh from which the data of a field is imported. <code>pathName</code> is the name of a physical group which contains a curve. The curve is devided into equal length intervals with number of <code>points</code> points. The field is shown at this points. <code>step</code> is the sequence number of displayed step. If no step is given, shows all  the aviable steps as an animation. If <code>plot</code> is true, additional return parameter, a tuple of vectors is given back, in which <code>x</code> is a vector of values in horizontal axis, <code>y</code> is a vector of values in vertical axis of a plot (see <code>Plots</code> package). <code>name</code> is the title of graph and <code>visible</code> is a true or false value to toggle on or off the initial visibility  in gmsh. This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>or</p><p>Return: <code>tag</code>, <code>xy</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>pathName</code>: String</li><li><code>field</code>: Integer</li><li><code>points</code>: Integer</li><li><code>step</code>: Integer</li><li><code>plot</code>: Boolean</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li><li><code>xy</code>: Tuples{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3599-L3630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.resultant-Tuple{Any, Any, Any}" href="#LowLevelFEM.resultant-Tuple{Any, Any, Any}"><code>LowLevelFEM.resultant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.resultant(problem, field, phName; grad=false, component=:x)</code></pre><p>Solves the resultant of <code>field</code> on <code>phName</code> physical group. Return the resultant(s) in <code>tuple</code>. Number of the members in <code>tuple</code> depends on the dimension of <code>problem</code>. It can solve the resultant of a load vector (sum of the elements of the vector), if <code>field</code> is a vector of floats. If <code>field</code> is a view (tag of a view in gmsh), then the integral of the field is solved. <code>field</code> must have only one component. If <code>grad</code> is <code>true</code>, then the gradient of the <code>field</code> will be evaluated and <code>component</code> of the gradient (<code>:x</code>, <code>:y</code> or <code>:z</code>) will be used to solve the resultant.</p><p>Return: <code>res</code></p><p>or</p><p>Return: <code>resx</code>, <code>resy</code></p><p>or</p><p>Return: <code>resx</code>, <code>resy</code>, <code>resz</code></p><p>Types:</p><ul><li><code>field</code>: Vector{Float64}</li><li><code>phName</code>: String </li><li><code>dim</code>: Int64</li><li><code>res</code>: Float64 </li><li><code>resx</code>: Float64 </li><li><code>resy</code>: Float64 </li><li><code>resz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2773-L2803">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}" href="#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}"><code>LowLevelFEM.rotateNodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.rotateNodes(problem, phName, CoordSys)</code></pre><p>Creates the <code>T</code> transformation matrix, which rotates the nodal coordinate system of the nodes in <code>phName</code> physical group to the coordinate systen defined by <code>CoordSys</code>. The mesh belongs to <code>problem</code>.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>phName</code>: String</li><li><code>CoordSys</code>: CoordinateSystem</li><li><code>T</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2945-L2959">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.scalarField-Tuple{Any, Any}" href="#LowLevelFEM.scalarField-Tuple{Any, Any}"><code>LowLevelFEM.scalarField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.scalarField(problem, dataField)</code></pre><p>Defines a scalar field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>.</p><p>Return: Vector{Float64}</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{Tuple{String, Float64,...}}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f2 = FEM.field(&quot;face1&quot;, f=1)
qq = FEM.scalarField(problem, [f2])
qqq = FEM.showDoFResults(problem, qq, :scalar)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2078-L2097">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.setParameter-Tuple{Any, Any}" href="#LowLevelFEM.setParameter-Tuple{Any, Any}"><code>LowLevelFEM.setParameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.setParameter(name, value)</code></pre><p>Defines a parameter <code>name</code> and sets its value to <code>value</code>. </p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>value</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3863-L3873">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.setParameters-Tuple{Any, Any}" href="#LowLevelFEM.setParameters-Tuple{Any, Any}"><code>LowLevelFEM.setParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.setParameters(name, value)</code></pre><p>Defines a parameter <code>name</code> and sets its value to <code>value</code>, which is a Vector{Float64}. </p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>value</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3878-L3888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}" href="#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showBucklingResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showBucklingResults(problem, Φ, name=..., visible=...)</code></pre><p>Loads buckling results into a View in gmsh. <code>Φ</code> is a struct of Eigen. <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the  initial visibility in gmsh. Click on ▷| to change the results. This function  returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>Φ</code>: Eigen</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3231-L3247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showElementResults-Tuple{Any, Any}" href="#LowLevelFEM.showElementResults-Tuple{Any, Any}"><code>LowLevelFEM.showElementResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showElementResults(problem, F, comp; name=..., visible=..., smooth=...)</code></pre><p>Same as <code>ShowStressResults</code> or <code>showStrainResults</code>, depending on the type of <code>F</code> data field.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>F</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3347-L3362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}" href="#LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}"><code>LowLevelFEM.showHeatFluxResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showHeatFluxResults(problem, Q, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads heat flux results into a View in gmsh. <code>Q</code> is a heat flux field to show, <code>comp</code> is the component of the field (:qvec, :qx, :qy, :qz, :q), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If <code>Q</code> contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>S</code>: VectorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3487-L3508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}" href="#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showModalResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showModalResults(problem, Φ, name=..., visible=...)</code></pre><p>Loads modal results into a View in gmsh. <code>Φ</code> is a struct of Eigen. <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the  initial visibility in gmsh. Click on ▷| to change the results. This function  returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>Φ</code>: Eigen</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3210-L3226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showOnSurface-Tuple{Any, Any}" href="#LowLevelFEM.showOnSurface-Tuple{Any, Any}"><code>LowLevelFEM.showOnSurface</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showOnSurface(field, phName; grad=false, component=:x, offsetX=0, offsetY=0, offsetZ=0, name=phName, visible=false)</code></pre><p>Shows the values of a scalar field at a surface which has a physical name <code>phName</code>. <code>field</code> is the tag of a view in GMSH. The values of the field are calculated at the intersection with the surface. <code>grad</code> has a true or false value to toggle on or off the gradient of the field. <code>component</code> is the component of the gradient of <code>field</code> (:x, :y, :z) to be shown. <code>offsetX</code>, <code>offsetY</code>, <code>offsetZ</code> are the offsets in the x, y and z directions where the values are picked from. <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>field</code>: Integer</li><li><code>phName</code>: String</li><li><code>grad</code>: Boolean</li><li><code>component</code>: Symbol</li><li><code>offsetX</code>: Float64</li><li><code>offsetY</code>: Float64</li><li><code>offsetZ</code>: Float64</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3727-L3751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStrainResults-Tuple{Any, Any}" href="#LowLevelFEM.showStrainResults-Tuple{Any, Any}"><code>LowLevelFEM.showStrainResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showStrainResults(problem, E, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads strain results into a View in gmsh. <code>E</code> is a strain field to show, <code>comp</code> is the component of the field (:e, :ex, :ey, :ez, :exy, :eyz, :ezx), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If <code>E</code> contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>E</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3252-L3273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStressResults-Tuple{Any, Any}" href="#LowLevelFEM.showStressResults-Tuple{Any, Any}"><code>LowLevelFEM.showStressResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showStressResults(problem, S, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads stress results into a View in gmsh. <code>S</code> is a stress field to show, <code>comp</code> is the component of the field (:s, :sx, :sy, :sz, :sxy, :syz, :szx, :seqv), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If <code>S</code> contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>S</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L3375-L3396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestEigenValue-Tuple{Any, Any}" href="#LowLevelFEM.smallestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.smallestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.smallestEigenValue(K, M)</code></pre><p>Solves the largest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘₐₓ</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>λₘₐₓ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2405-L2417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.smallestPeriodTime(K, M)</code></pre><p>Solves the smallest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2381-L2393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveBuckling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveBuckling(problem, loads, constraints; n=6)</code></pre><p>Solves the multipliers for the first <code>n</code> critical forces and the corresponding  buckling shapes for the instability of the <code>problem</code>, when <code>loads</code> and  <code>constraints</code> are applied. Result can be presented by <code>showBucklingResults</code> function. <code>loads</code> and <code>constraints</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively.</p><p>Return: <code>buckling</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{tuples}</li><li><code>constraints</code>: Vector{tuples}</li><li><code>n</code>: Int64</li><li><code>buckling</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2140-L2157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBucklingModes-Tuple{Any, Any}" href="#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}"><code>LowLevelFEM.solveBucklingModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveBucklingModes(problem, K, Knl; n=6)</code></pre><p>Solves the critical force multipliers and buckling mode shapes of a problem given by stiffness matrix <code>K</code> and the nonlinear stiffness matrix <code>Knl</code>. <code>n</code> is the number of buckling modes to solve. Returns the struct of critical forces and buckling modes. Results can be presented by <code>showBucklingResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>Knl</code>: SparseMatrix</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2032-L2046">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-NTuple{4, Any}" href="#LowLevelFEM.solveDisplacement-NTuple{4, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveDisplacement(problem, load, supp, elasticSupp)</code></pre><p>Solves the displacement vector <code>q</code> of <code>problem</code> with loads <code>load</code>,  supports <code>supp</code> and elastic supports <code>elasticSupp</code>.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>load</code>: Vector{Tuple} </li><li><code>supp</code>: Vector{Tuple}</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1468-L1481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveDisplacement(problem, load, supp)</code></pre><p>Solves the displacement vector <code>q</code> of <code>problem</code> with loads <code>load</code> and supports <code>supp</code>.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>load</code>: Vector{Tuple} </li><li><code>supp</code>: Vector{Tuple}</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1439-L1452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveDisplacement(K, q)</code></pre><p>Solves the equation K*q=f for the displacement vector <code>q</code>. <code>K</code> is the stiffness Matrix, <code>q</code> is the load vector.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix </li><li><code>f</code>: VectorField </li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1414-L1426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveEigenModes-Tuple{Any, Any}" href="#LowLevelFEM.solveEigenModes-Tuple{Any, Any}"><code>LowLevelFEM.solveEigenModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveEigenModes(problem, K, M; n=6, fₘᵢₙ=1.01)</code></pre><p>Solves the eigen frequencies and mode shapes of a problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>. <code>n</code> is the number of eigenfrequencies to solve, and solves the eigenfrequencies greater than <code>fₘᵢₙ</code>. Returns the struct of eigenfrequencies and eigen modes. Results can be presented by <code>showModalResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>n</code>: Int64</li><li><code>fₘᵢₙ</code>: Float64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1996-L2012">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveHeatFlux-Tuple{Any}" href="#LowLevelFEM.solveHeatFlux-Tuple{Any}"><code>LowLevelFEM.solveHeatFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveHeatFlux(problem, T; DoFResults=false)</code></pre><p>Solves the heat flux field <code>q</code> from temperature vector <code>T</code>. heat flux is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>q</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results (otherwise <code>showHeatFluxResults</code> or <code>showElementResults</code>).</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>T</code>: ScalarField</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L1021-L1036">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveModalAnalysis-Tuple{Any}" href="#LowLevelFEM.solveModalAnalysis-Tuple{Any}"><code>LowLevelFEM.solveModalAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveModalAnalysis(problem; constraints=[]; loads=[], n=6)</code></pre><p>Solves the first <code>n</code> eigenfrequencies and the corresponding  mode shapes for the <code>problem</code>, when <code>loads</code> and  <code>constraints</code> are applied. <code>loads</code> and <code>contraints</code> are optional.  Result can be presented by <code>showModalResults</code> function.  <code>loads</code> and <code>constraints</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively. If <code>loads</code> are given, it solves the eigenfrequencies of a prestressed structure.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{tuples}</li><li><code>constraints</code>: Vector{tuples}</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L2065-L2083">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStrain-Tuple{Any}" href="#LowLevelFEM.solveStrain-Tuple{Any}"><code>LowLevelFEM.solveStrain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveStrain(problem, q; DoFResults=false)</code></pre><p>Solves the strain field <code>E</code> from displacement vector <code>q</code>. Strain field is given per elements, so it usually contains jumps at the boundaries of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>E</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStrainResults</code> or <code>showElementResults</code>).</p><p>Return: <code>E</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: Vector{Float64}</li><li><code>E</code>: TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1498-L1513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStress-Tuple{Any}" href="#LowLevelFEM.solveStress-Tuple{Any}"><code>LowLevelFEM.solveStress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveStress(problem, q; T=..., T₀=..., DoFResults=false)</code></pre><p>Solves the stress field <code>S</code> from displacement vector <code>q</code>. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>S</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStressResults</code> or <code>showElementResults</code>). If the <code>T</code> temperature field (and <code>T₀</code> initial temperature field if it differs from zero) is given, the function solves also the thermal stresses.</p><p>Return: <code>S</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: Vector{Float64}</li><li><code>T</code>: Vector{Float64}</li><li><code>T₀</code>: Vector{Float64}</li><li><code>S</code>: TensorField or Matrix{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1716-L1735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-NTuple{4, Any}" href="#LowLevelFEM.solveTemperature-NTuple{4, Any}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveTemperature(problem, flux, temp, heatconv)</code></pre><p>Solves the temperature field <code>T</code> of <code>problem</code> with given heat flux <code>flux</code>, temperature <code>temp</code> and heat convection <code>heatconv</code>.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>flux</code>: Vector{Tuple} </li><li><code>temp</code>: Vector{Tuple}</li><li><code>heatconv</code>: Vector{Tuple}</li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L968-L982">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveTemperature(problem, flux, temp)</code></pre><p>Solves the temperature field <code>T</code> of <code>problem</code> with given heat flux <code>flux</code> and temperature <code>temp</code>.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>flux</code>: Vector{Tuple} </li><li><code>temp</code>: Vector{Tuple}</li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L947-L960">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-Tuple{Any, LowLevelFEM.VectorField}" href="#LowLevelFEM.solveTemperature-Tuple{Any, LowLevelFEM.VectorField}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveTemperature(problem, u; T0=273.0)</code></pre><p>Solves the raise of temperature <code>T</code> during reversible (no dissipation) elastic deformations, where <code>u</code> is the displacement field, and <code>problem</code> is a heat cunduction problem.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>u</code>: VectorField </li><li><code>T0</code>: Float64</li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L991-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.ScalarField}" href="#LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.ScalarField}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveTemperature(K, q)</code></pre><p>Solves the equation K*T=q for the temperature field <code>T</code>. <code>K</code> is the heat conduction matrix, <code>q</code> is the heat flux vector.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix </li><li><code>q</code>: ScalarField </li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/heat.jl#L930-L942">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.stiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.stiffnessMatrix(problem)</code></pre><p>Solves the stiffness matrix of the <code>problem</code>.</p><p>Return: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/linear.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}" href="#LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.suppressDeformationAtBoundaries!(problem, stiffMat, massMat, dampMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code>, mass matrix <code>massMat</code>, damping matrix <code>dampMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>massMat</code>: SparseMatrix </li><li><code>dampMat</code>: SparseMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/nonlinear.jl#L1062-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}" href="#LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.suppressDeformationAtBoundaries(problem, stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code>, mass matrix <code>massMat</code>, damping matrix <code>dampMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/nonlinear.jl#L1235-L1250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.temperatureConstraint-Tuple{Any}" href="#LowLevelFEM.temperatureConstraint-Tuple{Any}"><code>LowLevelFEM.temperatureConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.temperatureConstraint(name; T=...)</code></pre><p>Gives the temperature constraints on <code>name</code> physical group.  <code>T</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.temperatureConstraint(&quot;surf1&quot;, T=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>T</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L1933-L1945">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.tensorField-Tuple{Any, Any}" href="#LowLevelFEM.tensorField-Tuple{Any, Any}"><code>LowLevelFEM.tensorField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.tensorField(problem, dataField; type=...)</code></pre><p>Defines a vector field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>. <code>type</code> can be an arbitrary <code>Symbol</code>, eg. <code>:u</code> or <code>:f</code>.</p><p>Return: TensorField</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{Tuple{String, Float64,...}}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = sin(x)
f2(x, y, z) = 5y
ff1 = FEM.field(&quot;face1&quot;, fx=f1, fy=f2, fz=0, fxy=1, fyz=1, fzx=f2)
ff2 = FEM.field(&quot;face2&quot;, fx=f2, fy=f1, fz=1, fxy=1, fyz=f1, fzx=1)
qq = FEM.tensorField(problem, [ff1, ff2])
qq0 = FEM.showDoFResults(problem, qq, :tensor)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2216-L2239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.vectorField-Tuple{Any, Any}" href="#LowLevelFEM.vectorField-Tuple{Any, Any}"><code>LowLevelFEM.vectorField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.vectorField(problem, dataField; type=...)</code></pre><p>Defines a vector field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>. <code>type</code> can be an arbitrary <code>Symbol</code>, eg. <code>:u</code> or <code>:f</code>.</p><p>Return: VectorField</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{Tuple{String, Float64,...}}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = sin(x)
f2(x, y, z) = 5y
ff1 = FEM.field(&quot;face1&quot;, fx=f1, fy=f2, fz=0)
ff2 = FEM.field(&quot;face2&quot;, fx=f2, fy=f1, fz=1)
qq = FEM.vectorField(problem, [ff1, ff2])
qq0 = FEM.showDoFResults(problem, qq, :vector)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/bfe2480d088b26a13e03680436634ea3a4999d4e/src/general.jl#L2131-L2154">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LowLevelFEM.CoordinateSystem"><code>LowLevelFEM.CoordinateSystem</code></a></li><li><a href="#LowLevelFEM.Eigen"><code>LowLevelFEM.Eigen</code></a></li><li><a href="#LowLevelFEM.Material"><code>LowLevelFEM.Material</code></a></li><li><a href="#LowLevelFEM.Problem"><code>LowLevelFEM.Problem</code></a></li><li><a href="#LowLevelFEM.ScalarField"><code>LowLevelFEM.ScalarField</code></a></li><li><a href="#LowLevelFEM.TensorField"><code>LowLevelFEM.TensorField</code></a></li><li><a href="#LowLevelFEM.VectorField"><code>LowLevelFEM.VectorField</code></a></li><li><a href="#LowLevelFEM.CDM-NTuple{8, Any}"><code>LowLevelFEM.CDM</code></a></li><li><a href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a></li><li><a href="#LowLevelFEM.FDM-NTuple{6, Any}"><code>LowLevelFEM.FDM</code></a></li><li><a href="#LowLevelFEM.HHT-NTuple{7, Any}"><code>LowLevelFEM.HHT</code></a></li><li><a href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{Any, Matrix, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}"><code>LowLevelFEM.applyDeformationBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}"><code>LowLevelFEM.applyElasticSupport!</code></a></li><li><a href="#LowLevelFEM.applyHeatConvection!-NTuple{4, Any}"><code>LowLevelFEM.applyHeatConvection!</code></a></li><li><a href="#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}"><code>LowLevelFEM.constrainedDoFs</code></a></li><li><a href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a></li><li><a href="#LowLevelFEM.displacementConstraint-Tuple{Any}"><code>LowLevelFEM.displacementConstraint</code></a></li><li><a href="#LowLevelFEM.elasticSupport-Tuple{Any}"><code>LowLevelFEM.elasticSupport</code></a></li><li><a href="#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}"><code>LowLevelFEM.elasticSupportMatrix</code></a></li><li><a href="#LowLevelFEM.elementsToNodes-Tuple{Any}"><code>LowLevelFEM.elementsToNodes</code></a></li><li><a href="#LowLevelFEM.field-Tuple{Any}"><code>LowLevelFEM.field</code></a></li><li><a href="#LowLevelFEM.fieldError-Tuple{Any, Any}"><code>LowLevelFEM.fieldError</code></a></li><li><a href="#LowLevelFEM.freeDoFs-Tuple{Any, Any}"><code>LowLevelFEM.freeDoFs</code></a></li><li><a href="#LowLevelFEM.generateMesh-Tuple{Any, Any}"><code>LowLevelFEM.generateMesh</code></a></li><li><a href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a></li><li><a href="#LowLevelFEM.heatCapacityMatrix-Tuple{Any}"><code>LowLevelFEM.heatCapacityMatrix</code></a></li><li><a href="#LowLevelFEM.heatConductionMatrix-Tuple{Any}"><code>LowLevelFEM.heatConductionMatrix</code></a></li><li><a href="#LowLevelFEM.heatConvection-Tuple{Any}"><code>LowLevelFEM.heatConvection</code></a></li><li><a href="#LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionMatrix</code></a></li><li><a href="#LowLevelFEM.heatConvectionVector-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionVector</code></a></li><li><a href="#LowLevelFEM.heatFlux-Tuple{Any}"><code>LowLevelFEM.heatFlux</code></a></li><li><a href="#LowLevelFEM.heatFluxVector-Tuple{Any, Any}"><code>LowLevelFEM.heatFluxVector</code></a></li><li><a href="#LowLevelFEM.heatSource-Tuple{Any}"><code>LowLevelFEM.heatSource</code></a></li><li><a href="#LowLevelFEM.heatSourceVector-Tuple{Any, Any}"><code>LowLevelFEM.heatSourceVector</code></a></li><li><a href="#LowLevelFEM.initialDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement</code></a></li><li><a href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a></li><li><a href="#LowLevelFEM.initialTemperature-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature</code></a></li><li><a href="#LowLevelFEM.initialTemperature!-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature!</code></a></li><li><a href="#LowLevelFEM.initialVelocity-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity</code></a></li><li><a href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a></li><li><a href="#LowLevelFEM.largestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.largestEigenValue</code></a></li><li><a href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a></li><li><a href="#LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.latentHeatMatrix</code></a></li><li><a href="#LowLevelFEM.load-Tuple{Any}"><code>LowLevelFEM.load</code></a></li><li><a href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a></li><li><a href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a></li><li><a href="#LowLevelFEM.material-Tuple{Any}"><code>LowLevelFEM.material</code></a></li><li><a href="#LowLevelFEM.nodalAcceleration!-Tuple{Any, Any}"><code>LowLevelFEM.nodalAcceleration!</code></a></li><li><a href="#LowLevelFEM.nodalForce!-Tuple{Any, Any}"><code>LowLevelFEM.nodalForce!</code></a></li><li><a href="#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.nonLinearStiffnessMatrix</code></a></li><li><a href="#LowLevelFEM.openPostProcessor-Tuple{}"><code>LowLevelFEM.openPostProcessor</code></a></li><li><a href="#LowLevelFEM.openPreProcessor-Tuple{}"><code>LowLevelFEM.openPreProcessor</code></a></li><li><a href="#LowLevelFEM.plotOnPath-Tuple{Any, Any}"><code>LowLevelFEM.plotOnPath</code></a></li><li><a href="#LowLevelFEM.resultant-Tuple{Any, Any, Any}"><code>LowLevelFEM.resultant</code></a></li><li><a href="#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}"><code>LowLevelFEM.rotateNodes</code></a></li><li><a href="#LowLevelFEM.scalarField-Tuple{Any, Any}"><code>LowLevelFEM.scalarField</code></a></li><li><a href="#LowLevelFEM.setParameter-Tuple{Any, Any}"><code>LowLevelFEM.setParameter</code></a></li><li><a href="#LowLevelFEM.setParameters-Tuple{Any, Any}"><code>LowLevelFEM.setParameters</code></a></li><li><a href="#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showBucklingResults</code></a></li><li><a href="#LowLevelFEM.showElementResults-Tuple{Any, Any}"><code>LowLevelFEM.showElementResults</code></a></li><li><a href="#LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}"><code>LowLevelFEM.showHeatFluxResults</code></a></li><li><a href="#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showModalResults</code></a></li><li><a href="#LowLevelFEM.showOnSurface-Tuple{Any, Any}"><code>LowLevelFEM.showOnSurface</code></a></li><li><a href="#LowLevelFEM.showStrainResults-Tuple{Any, Any}"><code>LowLevelFEM.showStrainResults</code></a></li><li><a href="#LowLevelFEM.showStressResults-Tuple{Any, Any}"><code>LowLevelFEM.showStressResults</code></a></li><li><a href="#LowLevelFEM.smallestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.smallestEigenValue</code></a></li><li><a href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a></li><li><a href="#LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveBuckling</code></a></li><li><a href="#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}"><code>LowLevelFEM.solveBucklingModes</code></a></li><li><a href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a></li><li><a href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a></li><li><a href="#LowLevelFEM.solveDisplacement-NTuple{4, Any}"><code>LowLevelFEM.solveDisplacement</code></a></li><li><a href="#LowLevelFEM.solveEigenModes-Tuple{Any, Any}"><code>LowLevelFEM.solveEigenModes</code></a></li><li><a href="#LowLevelFEM.solveHeatFlux-Tuple{Any}"><code>LowLevelFEM.solveHeatFlux</code></a></li><li><a href="#LowLevelFEM.solveModalAnalysis-Tuple{Any}"><code>LowLevelFEM.solveModalAnalysis</code></a></li><li><a href="#LowLevelFEM.solveStrain-Tuple{Any}"><code>LowLevelFEM.solveStrain</code></a></li><li><a href="#LowLevelFEM.solveStress-Tuple{Any}"><code>LowLevelFEM.solveStress</code></a></li><li><a href="#LowLevelFEM.solveTemperature-Tuple{Any, LowLevelFEM.VectorField}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.solveTemperature-NTuple{4, Any}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.ScalarField}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a></li><li><a href="#LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries</code></a></li><li><a href="#LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries!</code></a></li><li><a href="#LowLevelFEM.temperatureConstraint-Tuple{Any}"><code>LowLevelFEM.temperatureConstraint</code></a></li><li><a href="#LowLevelFEM.tensorField-Tuple{Any, Any}"><code>LowLevelFEM.tensorField</code></a></li><li><a href="#LowLevelFEM.vectorField-Tuple{Any, Any}"><code>LowLevelFEM.vectorField</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>Serfőző, D., Pere, B.: An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems, preprint, <a href="https://doi.org/10.21203/rs.3.rs-3930320/v1">https://doi.org/10.21203/rs.3.rs-3930320/v1</a></li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a>Bathe, K. J.: Finite element procedures, Wiley, 1983, <a href="https://doi.org/10.1002/nag.1610070412">https://doi.org/10.1002/nag.1610070412</a></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. &quot;Improved  numerical dissipation for time integration algorithms in structural  dynamics.&quot; Earthquake Engineering &amp; Structural Dynamics 5.3 (1977): 283-292.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Belytschko, Ted, and Thomas JR, Hughes: &quot;Computational methods for  transient analysis&quot;, North-Holland, (1983).</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Serfőző, D., Pere, B.: A method to accurately define arbitrary algorithmic damping character as viscous damping. Arch Appl Mech 93, 3581–3595 (2023). <a href="https://doi.org/10.1007/s00419-023-02454-9">https://doi.org/10.1007/s00419-023-02454-9</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../Examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 7 August 2025 22:10">Thursday 7 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
