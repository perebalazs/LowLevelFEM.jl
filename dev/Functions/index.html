<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · LowLevelFEM</title><meta name="title" content="Functions · LowLevelFEM"/><meta property="og:title" content="Functions · LowLevelFEM"/><meta property="twitter:title" content="Functions · LowLevelFEM"/><meta name="description" content="Documentation for LowLevelFEM."/><meta property="og:description" content="Documentation for LowLevelFEM."/><meta property="twitter:description" content="Documentation for LowLevelFEM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelFEM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../Examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/main/docs/src/Functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LowLevelFEM.jl"><a class="docs-heading-anchor" href="#LowLevelFEM.jl">LowLevelFEM.jl</a><a id="LowLevelFEM.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LowLevelFEM.jl" title="Permalink"></a></h1><p>Documentation for LowLevelFEM.jl</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Problem" href="#LowLevelFEM.Problem"><code>LowLevelFEM.Problem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Problem(names; thickness=..., type=..., bandwidth=...)</code></pre><p>A structure containing the most important data of the problem. </p><ul><li>name of the model (in gmsh)</li><li>type of the problem: 3D &quot;Solid&quot;, &quot;PlaneStrain&quot;, &quot;PlaneStress&quot; or &quot;AxiSymmetric&quot; In the case of &quot;AxiSymmetric&quot;, the axis of symmetry is the &quot;y&quot; axis,  while the geometry must be drawn in the positive &quot;x&quot; half-plane.</li><li>bandwidth optimization using built-in <code>gmsh</code> function. Possibilities: &quot;RCMK&quot; (default), &quot;Hilbert&quot;, &quot;Metis&quot; or &quot;none&quot;</li><li>dimension of the problem, determined from <code>type</code></li><li>material constants: Physical group, Young&#39;s modulus, Poisson&#39;s ratio, mass density (in vector of tuples <code>names</code>)</li><li>thickness of the plate</li><li>number of nodes (non)</li></ul><p>Types:</p><ul><li><code>names</code>: Vector{Touple{String, Float64, Float64, Float64}}</li><li><code>type</code>: String</li><li><code>bandwidth</code>: String</li><li><code>dim</code>: Integer</li><li><code>thickness</code>: Float64</li><li><code>non</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L10-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.StressField" href="#LowLevelFEM.StressField"><code>LowLevelFEM.StressField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StressField(sigma, numElem, nsteps)</code></pre><p>A structure containing the data of a stress or strain field. </p><ul><li>sigma: vector of ElementNodeData type stress data (see gmsh.jl)</li><li>numElem: vector of tags of elements</li><li>nsteps: number of stress fields stored in sigma (for animations).</li></ul><p>Types:</p><ul><li><code>sigma</code>: Vector{Matrix{Float64}}</li><li><code>numElem</code>: Vector{Integer}</li><li><code>nsteps</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L96-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDM-NTuple{8, Any}" href="#LowLevelFEM.CDM-NTuple{8, Any}"><code>LowLevelFEM.CDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.CDM(K, M, C, f, u0, v0, T, Δt)</code></pre><p>Solves a transient dynamic problem using central difference method (CDM) (explicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>C</code> is the damping matrix, <code>f</code> is the load vector, <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the upper bound ot the time intervall (lower bound is zero) and <code>Δt</code> is the time step size. Returns the displacement vectors and velocity vectors in each time step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code> of the time instants used.</p><p>Return: <code>u</code>, <code>v</code>, <code>t</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>C</code>: SparseMatrix</li><li><code>f</code>: Vector{Float64}</li><li><code>u0</code>: Vector{Float64}</li><li><code>v0</code>: Vector{Float64}</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>u</code>: Matrix{Float64}</li><li><code>v</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1516-L1541">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the CDM method.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li>&quot;SR&quot;: spectral radius</li><li>&quot;PDR&quot;: physical damping ratio</li><li>&quot;ADR&quot;: algorithmic damping ratio</li><li>&quot;PE&quot;: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. The damping matrix is assembled in the  following ways: <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. If <code>show_β</code> or <code>show_ξ</code> is <code>true</code>, the corresponding <code>β</code> or <code>ξ</code> values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>show_β</code>: Boolean</li><li><code>show_ξ</code>: Boolean</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1748-L1788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHT-NTuple{7, Any}" href="#LowLevelFEM.HHT-NTuple{7, Any}"><code>LowLevelFEM.HHT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.HHT(K, M, f, u0, v0, T, Δt; α=..., δ=..., γ=..., β=...)</code></pre><p>Solves a transient dynamic problem using HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (implicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>f</code> is the load vector,  <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the  upper bound ot the time intervall (lower bound is zero) and <code>Δt</code> is the time  step size. Returns the displacement vectors and velocity vectors in each time  step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code>  of the time instants used. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see [1]. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)².</p><p>Return: <code>u</code>, <code>v</code>, <code>t</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>f</code>: Vector{Float64}</li><li><code>u0</code>: Vector{Float64}</li><li><code>v0</code>: Vector{Float64}</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>u</code>: Matrix{Float64}</li><li><code>v</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1578-L1611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li>&quot;SR&quot;: spectral radius</li><li>&quot;ADR&quot;: algorithmic damping ratio</li><li>&quot;PE&quot;: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> and <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see [1]. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1664-L1700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-NTuple{4, Any}" href="#LowLevelFEM.applyBoundaryConditions!-NTuple{4, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions!(problem, stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>loadVec</code>: Vector </li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L768-L783">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-NTuple{6, Any}" href="#LowLevelFEM.applyBoundaryConditions!-NTuple{6, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions!(problem, stiffMat, massMat, dampMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code>, mass matrix <code>massMat</code>, damping matrix <code>dampMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>massMat</code>: SparseMatrix </li><li><code>dampMat</code>: SparseMatrix </li><li><code>loadVec</code>: Vector{Float64}</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L845-L862">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions-NTuple{4, Any}" href="#LowLevelFEM.applyBoundaryConditions-NTuple{4, Any}"><code>LowLevelFEM.applyBoundaryConditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.applyBoundaryConditions(problem, stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>. Creates a new stiffness matrix and load vector.</p><p>Return: <code>stiffMat</code>, <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix </li><li><code>loadVec</code>: Vector </li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L794-L809">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}" href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)</code></pre><p>Generates the damping matrix for proportional damping case. <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅. The latter corresponds  to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. <code>K</code> is the stiffness matrix, <code>M</code> is the mass matrix and <code>ωₘₐₓ</code> is the  largest natural frequency.</p><p>Return: <code>dampingMatrix</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>α</code>: Float64</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>dampingMatrix</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L591-L613">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.displacementConstraint-Tuple{Any}" href="#LowLevelFEM.displacementConstraint-Tuple{Any}"><code>LowLevelFEM.displacementConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.displacementConstraint(name; ux=..., uy=..., uz=...)</code></pre><p>Gives the displacement constraints on <code>name</code> physical group. At least one <code>ux</code>,  <code>uy</code> or <code>uz</code> value have to be given (depending on the dimension of the problem). <code>ux</code>, <code>uy</code> or <code>uz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.displacementConstraint(&quot;support1&quot;, ux=fn)</code>) Return: none</p><p>Types:</p><ul><li><code>name</code>: string</li><li><code>ux</code>: Float64 of Function</li><li><code>uy</code>: Float64 of Function</li><li><code>uz</code>: Float64 of Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L136-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.generateMesh-Tuple{Any, Any}" href="#LowLevelFEM.generateMesh-Tuple{Any, Any}"><code>LowLevelFEM.generateMesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.generateMesh(problem, surf, elemSize; approxOrder=1, algorithm=6, quadrangle=0, internalNodes=0)</code></pre><p>Obsolate, use gmsh script (.geo) instead.</p><p>Return: none</p><p>Types:</p><ul><li>``: x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L178-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getTagForPhysicalName-Tuple{Any}" href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.getTagForPhysicalName(name)</code></pre><p>Returns <code>tags</code> of elements of physical group <code>name</code>.</p><p>Return: <code>tags</code></p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>tags</code>: Vector{Integer}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L822-L832">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement!-Tuple{Any, Any, Any}" href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialDisplacement!(problem, name, u0; ux=..., uy=..., uz=...)</code></pre><p>Changes the displacement values <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in displacement vector <code>u0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>u0</code>: Vector{Float64}</li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1365-L1381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity!-Tuple{Any, Any, Any}" href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.initialVelocity!(problem, name, v0; vx=..., vy=..., vz=...)</code></pre><p>Changes the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in velocity vector <code>v0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>v0</code>: Vector{Float64}</li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1403-L1419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.largestPeriodTime(K, M)</code></pre><p>Solves the largest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.`</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1466-L1478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.load-Tuple{Any}" href="#LowLevelFEM.load-Tuple{Any}"><code>LowLevelFEM.load</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.load(name; fx=..., fy=..., fz=...)</code></pre><p>Gives the intensity of distributed load on <code>name</code> physical group. At least one <code>fx</code>,  <code>fy</code> or <code>fz</code> value have to be given (depending on the dimension of the problem). <code>fx</code>,  <code>fy</code> or <code>fz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); FEM.load(&quot;load1&quot;, fx=fn)</code>)</p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: string</li><li><code>fx</code>: Float64 of Function</li><li><code>fy</code>: Float64 of Function</li><li><code>fz</code>: Float64 of Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L156-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.loadVector-Tuple{Any, Any}" href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.loadVector(problem, loads)</code></pre><p>Solves a load vector of <code>problem</code>. <code>loads</code> is a tuple of name of physical group  <code>name</code>, coordinates <code>fx</code>, <code>fy</code> and <code>fz</code> of the intensity of distributed force. It can solve traction or body force depending on the problem. In case of 2D problems and Point physical group means concentrated force. In case of 2D problems and Line physical group means surface force. In case of 2D problems and Surface physical group means body force. In case of 3D problems and Point physical group means concentrated force. In case of 3D problems and Line physical group means edge force. In case of 3D problems and Surface physical group means surface force. In case of 3D problems and Volume physical group means body force.</p><p>Return: <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>loadVec</code>: Vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L637-L657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.massMatrix-Tuple{Any}" href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.massMatrix(problem; lumped=...)</code></pre><p>Solves the mass matrix of the <code>problem</code>. If <code>lumped</code> is true, solves lumped mass matrix.</p><p>Return: <code>massMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>lumped</code>: Boolean</li><li><code>massMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L455-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.material-Tuple{Any}" href="#LowLevelFEM.material-Tuple{Any}"><code>LowLevelFEM.material</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.material(name; E=2.0e5, ν=0.3, ρ=7.85e-9)</code></pre><p>Returns a tuple in which <code>name</code> is the name of a physical group,  <code>E</code> is the modulus of elasticity, <code>ν</code> Poisson&#39;s ratio and <code>ρ</code> is the mass density.</p><p>Return: mat</p><p>Types:</p><ul><li><code>mat</code>: Tuple(String, Float64, Float64, Float64)</li><li><code>name</code>: String</li><li><code>E</code>: Float64</li><li><code>ν</code>: Float64</li><li><code>ρ</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L115-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalAcceleration!-Tuple{Any, Any, Any}" href="#LowLevelFEM.nodalAcceleration!-Tuple{Any, Any, Any}"><code>LowLevelFEM.nodalAcceleration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.nodalAcceleration!(problem, name, a0; ax=..., ay=..., az=...)</code></pre><p>Changes the acceleration values <code>ax</code>, <code>ay</code> and <code>az</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in acceleration vector <code>a0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>a0</code>: Vector{Float64}</li><li><code>ax</code>: Float64</li><li><code>ay</code>: Float64</li><li><code>az</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1445-L1461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalForce!-Tuple{Any, Any, Any}" href="#LowLevelFEM.nodalForce!-Tuple{Any, Any, Any}"><code>LowLevelFEM.nodalForce!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.nodalForce!(problem, name, f0; fx=..., fy=..., fz=...)</code></pre><p>Changes the force values <code>fx</code>, <code>fy</code> and <code>fz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in load vector <code>f0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>f0</code>: Vector{Float64}</li><li><code>fx</code>: Float64 </li><li><code>fy</code>: Float64 </li><li><code>fz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1424-L1440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.plotOnPath-NTuple{4, Any}" href="#LowLevelFEM.plotOnPath-NTuple{4, Any}"><code>LowLevelFEM.plotOnPath</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.plotOnPath(problem, pathName, field, points; step=..., plot=..., name=..., visible=...)</code></pre><p>Load a 2D plot on a path into a View in gmsh. <code>field</code> is the number of View in gmsh from which the data of a field is imported. <code>pathName</code> is the name of a physical group which contains a curve. The curve is devided into equal length intervals with number of <code>points</code> points. The field is shown at this points. <code>step</code> is the sequence number of displayed step. If no step is given, shows all  the aviable steps as an animation. If <code>plot</code> is true, additional return parameter, a tuple of vectors is given back, in which <code>x</code> is a vector of values in horizontal axis, <code>y</code> is a vector of values in vertical axis of a plot (see <code>Plots</code> package). <code>name</code> is the title of graph and <code>visible</code> is a true or false value to toggle on or off the initial visibility  in gmsh. This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>or</p><p>Return: <code>tag</code>, <code>xy</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>pathName</code>: String</li><li><code>field</code>: Integer</li><li><code>points</code>: Integer</li><li><code>step</code>: Integer</li><li><code>plot</code>: Boolean</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li><li><code>xy</code>: Tuples{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L2118-L2149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showDoFResults-Tuple{Any, Any, Any}" href="#LowLevelFEM.showDoFResults-Tuple{Any, Any, Any}"><code>LowLevelFEM.showDoFResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showDoFResults(problem, q, comp; t=..., name=..., visible=...)</code></pre><p>Loads nodal results into a View in gmsh. <code>q</code> is the field to show, <code>comp</code> is the component of the field (&quot;uvec&quot;, &quot;ux&quot;, &quot;uy&quot;, &quot;uz&quot;, &quot;vvec&quot;, &quot;vx&quot;, &quot;vy&quot;, &quot;vz&quot;), <code>t</code> is a vector of time steps (same number of columns as <code>q</code>), <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the  initial visibility in gmsh. If <code>q</code> has more columns, then a sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: Vector{Matrix}</li><li><code>comp</code>: String</li><li><code>t</code>: Vector{Float64}</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1848-L1868">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStrainResults-Tuple{Any, Any, Any}" href="#LowLevelFEM.showStrainResults-Tuple{Any, Any, Any}"><code>LowLevelFEM.showStrainResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showStrainResults(problem, E, comp; t=..., name=..., visible=..., smooth=...)</code></pre><p>Loads strain results into a View in gmsh. <code>E</code> is a strain field to show, <code>comp</code> is the component of the field (&quot;e&quot;, &quot;ex&quot;, &quot;ey&quot;, &quot;ez&quot;, &quot;exy&quot;, &quot;eyz&quot;, &quot;ezx&quot;), <code>t</code> is a vector of time steps (same length as the number of stress states), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If length of <code>t</code> is more than one, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>E</code>: StressField</li><li><code>comp</code>: String</li><li><code>t</code>: Vector{Float64}</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1927-L1950">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStressResults-Tuple{Any, Any, Any}" href="#LowLevelFEM.showStressResults-Tuple{Any, Any, Any}"><code>LowLevelFEM.showStressResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.showStressResults(problem, S, comp; t=..., name=..., visible=..., smooth=...)</code></pre><p>Loads stress results into a View in gmsh. <code>S</code> is a stress field to show, <code>comp</code> is the component of the field (&quot;s&quot;, &quot;sx&quot;, &quot;sy&quot;, &quot;sz&quot;, &quot;sxy&quot;, &quot;syz&quot;, &quot;szx&quot;, &quot;seqv&quot;), <code>t</code> is a vector of time steps (same length as the number of stress states), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If length of <code>t</code> is more than one, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>S</code>: StressField</li><li><code>comp</code>: String</li><li><code>t</code>: Vector{Float64}</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L2014-L2037">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.smallestPeriodTime(K, M)</code></pre><p>Solves the smallest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.`</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix</li><li><code>M</code>: SparseMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1492-L1504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveDisplacement(K, q)</code></pre><p>Solves the equation K*q=f for the displacement vector <code>q</code>. <code>K</code> is the stiffness Matrix, <code>q</code> is the load vector.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>K</code>: SparseMatrix </li><li><code>f</code>: Vector{Float64} </li><li><code>q</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1010-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStrain-Tuple{Any, Any}" href="#LowLevelFEM.solveStrain-Tuple{Any, Any}"><code>LowLevelFEM.solveStrain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveStrain(problem, q)</code></pre><p>Solves the strain field <code>E</code> from displacement vector <code>q</code>. Strain field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>.</p><p>Return: <code>E</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: Vector{Float64}</li><li><code>E</code>: StressField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1027-L1040">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStress-Tuple{Any, Any}" href="#LowLevelFEM.solveStress-Tuple{Any, Any}"><code>LowLevelFEM.solveStress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.solveStress(problem, q)</code></pre><p>Solves the stress field <code>S</code> from displacement vector <code>q</code>. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>.</p><p>Return: <code>S</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: Vector{Float64}</li><li><code>S</code>: StressField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L1187-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.stiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FEM.stiffnessMatrix(problem)</code></pre><p>Solves the stiffness matrix of the <code>problem</code>.</p><p>Return: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/62aa3e2f405a8966b92de2302553fe21cc94c12d/src/LowLevelFEM.jl#L206-L216">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LowLevelFEM.Problem"><code>LowLevelFEM.Problem</code></a></li><li><a href="#LowLevelFEM.StressField"><code>LowLevelFEM.StressField</code></a></li><li><a href="#LowLevelFEM.CDM-NTuple{8, Any}"><code>LowLevelFEM.CDM</code></a></li><li><a href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a></li><li><a href="#LowLevelFEM.HHT-NTuple{7, Any}"><code>LowLevelFEM.HHT</code></a></li><li><a href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions-NTuple{4, Any}"><code>LowLevelFEM.applyBoundaryConditions</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-NTuple{4, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-NTuple{6, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a></li><li><a href="#LowLevelFEM.displacementConstraint-Tuple{Any}"><code>LowLevelFEM.displacementConstraint</code></a></li><li><a href="#LowLevelFEM.generateMesh-Tuple{Any, Any}"><code>LowLevelFEM.generateMesh</code></a></li><li><a href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a></li><li><a href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a></li><li><a href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a></li><li><a href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a></li><li><a href="#LowLevelFEM.load-Tuple{Any}"><code>LowLevelFEM.load</code></a></li><li><a href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a></li><li><a href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a></li><li><a href="#LowLevelFEM.material-Tuple{Any}"><code>LowLevelFEM.material</code></a></li><li><a href="#LowLevelFEM.nodalAcceleration!-Tuple{Any, Any, Any}"><code>LowLevelFEM.nodalAcceleration!</code></a></li><li><a href="#LowLevelFEM.nodalForce!-Tuple{Any, Any, Any}"><code>LowLevelFEM.nodalForce!</code></a></li><li><a href="#LowLevelFEM.plotOnPath-NTuple{4, Any}"><code>LowLevelFEM.plotOnPath</code></a></li><li><a href="#LowLevelFEM.showDoFResults-Tuple{Any, Any, Any}"><code>LowLevelFEM.showDoFResults</code></a></li><li><a href="#LowLevelFEM.showStrainResults-Tuple{Any, Any, Any}"><code>LowLevelFEM.showStrainResults</code></a></li><li><a href="#LowLevelFEM.showStressResults-Tuple{Any, Any, Any}"><code>LowLevelFEM.showStressResults</code></a></li><li><a href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a></li><li><a href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a></li><li><a href="#LowLevelFEM.solveStrain-Tuple{Any, Any}"><code>LowLevelFEM.solveStrain</code></a></li><li><a href="#LowLevelFEM.solveStress-Tuple{Any, Any}"><code>LowLevelFEM.solveStress</code></a></li><li><a href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>Serfőző, D., Pere, B.: An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems, preprint, <a href="https://doi.org/10.21203/rs.3.rs-3930320/v1">https://doi.org/10.21203/rs.3.rs-3930320/v1</a></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. &quot;Improved  numerical dissipation for time integration algorithms in structural  dynamics.&quot; Earthquake Engineering &amp; Structural Dynamics 5.3 (1977): 283-292.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Belytschko, Ted, and Thomas JR, Hughes: &quot;Computational methods for  transient analysis&quot;, North-Holland, (1983).</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Serfőző, D., Pere, B.: A method to accurately define arbitrary algorithmic damping character as viscous damping. Arch Appl Mech 93, 3581–3595 (2023). <a href="https://doi.org/10.1007/s00419-023-02454-9">https://doi.org/10.1007/s00419-023-02454-9</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../Examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 1 November 2024 20:13">Friday 1 November 2024</span>. Using Julia version 1.10.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
