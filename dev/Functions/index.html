<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · LowLevelFEM</title><meta name="title" content="Functions · LowLevelFEM"/><meta property="og:title" content="Functions · LowLevelFEM"/><meta property="twitter:title" content="Functions · LowLevelFEM"/><meta name="description" content="Documentation for LowLevelFEM."/><meta property="og:description" content="Documentation for LowLevelFEM."/><meta property="twitter:description" content="Documentation for LowLevelFEM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelFEM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../Examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/main/docs/src/Functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LowLevelFEM.jl"><a class="docs-heading-anchor" href="#LowLevelFEM.jl">LowLevelFEM.jl</a><a id="LowLevelFEM.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LowLevelFEM.jl" title="Permalink"></a></h1><p>Documentation for LowLevelFEM.jl</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CoordinateSystem" href="#LowLevelFEM.CoordinateSystem"><code>LowLevelFEM.CoordinateSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoordinateSystem(vec1, vec2)</code></pre><p>A structure containing the data of a coordinate system.</p><ul><li><code>vec1</code>: direction of the new x axis.</li><li><code>vec2</code>: together with <code>vec1</code> determine the xy plane</li></ul><p>If the problem is two dimensional, it is enough to give the first two elements of <code>vec1</code>. Elements of <code>vec1</code> and <code>vec2</code> can be functions. In 3D case the functions have three arguments (x, y, and z coordinates), otherwise (in 2D case) the number of arguments is two (x and y coordinates).</p><p>Types:</p><ul><li><code>vec1</code>: Vector{Float64}</li><li><code>vec2</code>: Vector{Float64}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 2D case
nx(x, y) = x
ny(x, y) = y
cs = CoordinateSystem([nx, ny])
Q = rotateNodes(problem, &quot;body&quot;, cs)
q2 = Q&#39; * q1 # where `q1` is in Cartesian, `q2` is in Axisymmetric coordinate system and
             # `q1` is a nodal displacement vector.
S2 = Q&#39; * S1 * Q # where `S1` is a stress field in Cartesian coordinate system while
                 # `S2` is in Axisymmetric coordinate system.

# 3D case
n1x(x, y, z) = x
n1y(x, y, z) = y
n2x(x, y, z) = -y
n2y = n1x
cs = CoordinateSystem([n1x, n1y, 0], [n2x, n2y, 0])
Q = rotateNodes(problem, &quot;body&quot;, cs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L397-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Eigen" href="#LowLevelFEM.Eigen"><code>LowLevelFEM.Eigen</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Eigen(f, ϕ, model)</code></pre><p>A structure containing the eigenfrequencies and eigen modes.</p><ul><li>f: eigenfrequencies</li><li>ϕ: eigen modes</li><li>model: same as <code>Problem</code></li></ul><p>Types:</p><ul><li><code>f</code>: Matrix{Float64}</li><li><code>ϕ</code>: Vector{Float64}</li><li><code>model</code>: Problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L475-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Material" href="#LowLevelFEM.Material"><code>LowLevelFEM.Material</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Material(phName, type, E, ν, ρ, k, c, α, λ, μ, κ)</code></pre><p>A structure containing the material type and constants.</p><ul><li>type: constitutive law: <code>:Hooke</code>, <code>:StVenantKirchhoff</code>, <code>:NeoHookeCompressible</code></li><li>E: elastic modulus,</li><li>ν: Poisson&#39;s ratio,</li><li>ρ: mass density,</li><li>k: heat conductivity,</li><li>c: specific heat,</li><li>α: heat expansion coefficient</li><li>λ: Lamé parameter</li><li>μ: Lamé parameter</li><li>κ: Bulk modulus</li></ul><p><code>phName</code> is the name of the physical group where the given material is used.</p><p>Types:</p><ul><li><code>phName</code>: String</li><li><code>type</code>: Symbol</li><li><code>E</code>: Float64</li><li><code>ν</code>: Float64</li><li><code>ρ</code>: Float64</li><li><code>k</code>: Float64</li><li><code>c</code>: Float64</li><li><code>α</code>: Float64</li><li><code>λ</code>: Float64</li><li><code>μ</code>: Float64</li><li><code>κ</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L16-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Problem" href="#LowLevelFEM.Problem"><code>LowLevelFEM.Problem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Problem(materials; thickness=..., type=..., bandwidth=...)</code></pre><p>A structure containing the most important data of the problem. </p><ul><li>Parts of the model with their material constants. More materials can be given. (see <code>material</code> function)</li><li>type of the problem: <code>:Solid</code>, <code>:PlaneStrain</code>, <code>:PlaneStress</code>, <code>:AxiSymmetric</code>, <code>:HeatConduction</code>, <code>:PlaneHeatConduction</code>, <code>:AxiSymmetricHeatConduction</code>. In the case of <code>:AxiSymmetric</code>, the axis of symmetry is the <code>y</code> axis,  while the geometry must be drawn in the positive <code>x</code> half-plane.</li><li>bandwidth optimization using built-in <code>gmsh</code> function. Possibilities: <code>:RCMK</code>, <code>:Hilbert</code>, <code>:Metis</code> or <code>:none</code> (default)</li><li>dimension of the problem, determined from <code>type</code></li><li>material constants (in a vector of material structure <code>materials</code>). See <code>Material</code> struct</li><li>thickness of the plate</li><li>number of nodes (non)</li><li>dimension of the geometry</li><li>dimension of the problem (eg. a 3D heat conduction problem is a 1D problem)</li></ul><p>Types:</p><ul><li><code>materials</code>: Material</li><li><code>type</code>: Symbol</li><li><code>bandwidth</code>: Symbol</li><li><code>dim</code>: Integer</li><li><code>thickness</code>: Float64</li><li><code>non</code>: Integer</li><li><code>dim</code>: Integer</li><li><code>pdim</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L63-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.ScalarField" href="#LowLevelFEM.ScalarField"><code>LowLevelFEM.ScalarField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScalarField(A, a, t, numElem, nsteps, type, model)
ScalarField(problem, dataField)</code></pre><p>A structure containing all data of a scalar field (eg. Temperature field). </p><ul><li>A: vector of ElementNodeData type scalar data (see gmsh.jl)</li><li>a: matrix of nodal data of scalar field</li><li>numElem: vector of tags of elements</li><li>nsteps: number of stress fields stored in <code>A</code> (for animations).</li><li>type: type of data (eg. temperature <code>:T</code>)</li><li>model: the same as <code>Problem</code></li></ul><p>Types:</p><ul><li><code>A</code>: Vector{Vector{Float64}}</li><li><code>a</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li><li><code>numElem</code>: Vector{Integer}</li><li><code>nsteps</code>: Integer</li><li><code>type</code>: Symbol</li><li><code>model</code>: Problem</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">s(x,y,z) = 2x + 3y
fs = field(&quot;body&quot;, f=s)
S = ScalarField(problem, [fs])</code></pre><p>Here <code>S</code> is defined element-wise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L231-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.SystemMatrix" href="#LowLevelFEM.SystemMatrix"><code>LowLevelFEM.SystemMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SystemMatrix(A::SparseMatrixCSC{Float64}, model::Problem)</code></pre><p>Structure which contains the stiffness/mass/heatconduction/heatcapacity/latentheat/... matrix and given <code>Problem</code>.</p><p>Types:</p><ul><li><code>A</code>: SparseMatrixCSC{Float64}</li><li><code>model</code>: Problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.TensorField" href="#LowLevelFEM.TensorField"><code>LowLevelFEM.TensorField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TensorField(A, a, t, numElem, nsteps, type, model)</code></pre><p>A structure containing the data of a tensor field (eg. stress field). </p><ul><li>A: vector of ElementNodeData type heat flux data (see gmsh.jl)</li><li>a: matrix of nodal data of scalar field</li><li>numElem: vector of tags of elements</li><li>nsteps: number of stress fields stored in <code>A</code> (for animations).</li><li>type: type of data (eg. stress <code>:s</code>)</li><li>model: the same as <code>Problem</code></li></ul><p>Types:</p><ul><li><code>A</code>: Vector{Matrix{Float64}}</li><li><code>a</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li><li><code>numElem</code>: Vector{Integer}</li><li><code>nsteps</code>: Integer</li><li><code>type</code>: Symbol</li><li><code>model</code>: Problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L354-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.Transformation" href="#LowLevelFEM.Transformation"><code>LowLevelFEM.Transformation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Transformation(T::SparseMatrixCSC{Float64}, non::Int64, dim::Int64)</code></pre><p>Structure which contains the transformation matrix <code>T</code> of each nodes in the FE mesh,  the number of nodes <code>non</code> and the dimension of the problem <code>dim</code>.</p><p>Types:</p><ul><li><code>T</code>: SparseMatrixCSC{Float64}</li><li><code>non</code>: Int64</li><li><code>dim</code>: Int64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L178-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.VectorField" href="#LowLevelFEM.VectorField"><code>LowLevelFEM.VectorField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorField(A, a, t, numElem, nsteps, type, model)</code></pre><p>A structure containing the data of a vector field (eg. displacement field). </p><ul><li>A: vector of ElementNodeData type heat flux data (see gmsh.jl)</li><li>a: matrix of nodal data of scalar field</li><li>numElem: vector of tags of elements</li><li>nsteps: number of stress fields stored in <code>A</code> (for animations).</li><li>type: type of data (eg. heat flux <code>:q</code>)</li><li>model: the same as <code>Problem</code></li></ul><p>Types:</p><ul><li><code>A</code>: Vector{Matrix{Float64}}</li><li><code>a</code>: Matrix{Float64}</li><li><code>t</code>: Vector{Float64}</li><li><code>numElem</code>: Vector{Integer}</li><li><code>nsteps</code>: Integer</li><li><code>type</code>: Symbol</li><li><code>model</code>: Problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L324-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}" href="#Base.:*-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(A::ScalarField, B::ScalarField)</code></pre><p>Performs element-wise multiplication of two ScalarField objects on the same finite elements.</p><p>Return: ScalarField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">C = A * B</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/operators.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{LowLevelFEM.ScalarField, Number}" href="#Base.:*-Tuple{LowLevelFEM.ScalarField, Number}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(A::ScalarField, b::Number)</code></pre><p>Performs multiplication of a ScalarField objects and a Number.</p><p>Return: ScalarField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">C = A * 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/operators.jl#L296-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{Number, LowLevelFEM.ScalarField}" href="#Base.:*-Tuple{Number, LowLevelFEM.ScalarField}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(b::Number, A::ScalarField)</code></pre><p>Performs multiplication of a ScalarField objects and a Number.</p><p>Return: ScalarField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">C = 2.0 * A</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/operators.jl#L323-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}" href="#Base.:+-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(A::ScalarField, B::ScalarField)</code></pre><p>Performs element-wise addition of two ScalarField objects on the same finite elements.</p><p>Return: ScalarField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">C = A + B</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/operators.jl#L134-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:--Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}" href="#Base.:--Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">-(A::ScalarField, B::ScalarField)</code></pre><p>Performs element-wise substruction of two ScalarField objects on the same finite elements.</p><p>Return: ScalarField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">C = A - B</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/operators.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:/-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}" href="#Base.:/-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">/(A::ScalarField, B::ScalarField)</code></pre><p>Performs element-wise division of two ScalarField objects on the same finite elements.</p><p>Return: ScalarField</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">C = A / B</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/operators.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{LowLevelFEM.SystemMatrix}" href="#Base.copy-Tuple{LowLevelFEM.SystemMatrix}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.copy(A::SystemMatrix)</code></pre><p>Internal function to copy the hole content of a <code>SystemMatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.div-Tuple{Union{LowLevelFEM.TensorField, LowLevelFEM.VectorField}}" href="#Base.div-Tuple{Union{LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>Base.div</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">div(r::Union{VectorField,TensorField})</code></pre><p>Solves the divergence of the vector field or tensor field <code>r</code>. An alternative way to solve <code>div</code> is to use <code>∇</code> as a differencial operator.</p><p>Return: ScalarField or VectorField</p><p>Types:</p><ul><li><code>r</code>: VectorField or TensorField</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x(X, Y, Z) = 2X + 3Y
y(X, Y, Z) = Y
z(X, Y, Z) = Z
fld = field(&quot;body&quot;, fx=x, fy=y, fz=z)
v = vectorField(problem, [fld])
D1 = div(v)
D2 = ∇ ⋅ v
println(D1 == D2)

fsz(X, Y, Z) = 10 - Z
s0 = field(&quot;body&quot;, fz=fsz)
S = tensorField(problem, [s0])
b1 = -div(S)
b2 = -S ⋅ ∇
println(b1 == b2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L362-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}" href="#Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, M::SystemMatrix)</code></pre><p>Internal function to display <code>SystemMatrix</code> as a SparseMatrixCSC{Float64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDM-NTuple{8, Any}" href="#LowLevelFEM.CDM-NTuple{8, Any}"><code>LowLevelFEM.CDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CDM(K, M, C, f, u0, v0, T, Δt)</code></pre><p>Solves a transient dynamic problem using central difference method (CDM) (explicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>C</code> is the damping matrix, <code>f</code> is the load vector, <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the upper bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time step size. Returns the displacement vectors and velocity vectors in each time step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code> of the time instants used.</p><p>The critical (largest allowed) time step is <code>Δtₘₐₓ = Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ)</code> where <code>Tₘᵢₙ</code> is the time period of the largest eigenfrequency and <code>ξₘₐₓ</code> is the largest modal damping.</p><p>Return: <code>u</code>, <code>v</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>C</code>: SystemMatrix</li><li><code>f</code>: VectorField</li><li><code>u0</code>: VectorField</li><li><code>v0</code>: VectorField</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>u</code>: VectorField</li><li><code>v</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2634-L2662">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the CDM method.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:PDR</code>: physical damping ratio</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. The damping matrix is assembled in the  following ways: <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. If <code>show_β</code> or <code>show_ξ</code> is <code>true</code>, the corresponding <code>β</code> or <code>ξ</code> values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>show_β</code>: Boolean</li><li><code>show_ξ</code>: Boolean</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2796-L2834">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.FDM-NTuple{6, Any}" href="#LowLevelFEM.FDM-NTuple{6, Any}"><code>LowLevelFEM.FDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FDM(K, C, q, T0, tₘₐₓ, Δt; ϑ=...)</code></pre><p>Solves a transient heat conduction problem using Finite Difference Method (FDM). Introducing a <code>ϑ</code> parameter, special cases can be used as the Forward Euler (explicit, ϑ=0), Backward Euler (implicit, ϑ=1), Crank-Nicolson (ϑ=0.5) and intermediate cases (0&lt;ϑ&lt;1). (This method is known as ϑ-method. See <sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup>.) <code>K</code> is the heat conduction matrix, <code>C</code> is the heat capacity matrix, <code>q</code> is the heat flux vector, <code>T0</code> is the initial temperature, <code>tₘₐₓ</code> is the upper  bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time step size. Returns the nodal temperature vectors in each time  step arranged in the columns of the matrix <code>T</code> and a vector <code>t</code> of the time instants used.</p><p>The critical (largest allowed) time step is <code>Δtₘₐₓ = 2 / ((1-2ϑ)*λₘₐₓ)</code> where <code>λₘₐₓ</code> is the largest eigenvalue of (<strong>K</strong>+λ<strong>C</strong>)<strong>θ</strong>=<strong>0</strong>  eigenvalue problem and <code>ϑ</code> is the parameter of the ϑ-method. Default value of <code>ϑ</code> is 1/2.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>C</code>: SystemMatrix</li><li><code>q</code>: ScalarField</li><li><code>T0</code>: ScalarField</li><li><code>tₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L1280-L1311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHT-NTuple{7, Any}" href="#LowLevelFEM.HHT-NTuple{7, Any}"><code>LowLevelFEM.HHT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HHT(K, M, f, u0, v0, T, Δt; α=..., δ=..., γ=..., β=...)</code></pre><p>Solves a transient dynamic problem using HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (implicit). <code>K</code> is the stiffness Matrix, <code>M</code> is the mass matrix, <code>f</code> is the load vector,  <code>u0</code> is the initial displacement, <code>v0</code> is the initial velocity, <code>T</code> is the  upper bound of the time intervall (lower bound is zero) and <code>Δt</code> is the time  step size. Returns the displacement vectors and velocity vectors in each time  step arranged in the columns of the two matrices <code>u</code> and <code>v</code> and a vector <code>t</code>  of the time instants used. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)².</p><p>Return: <code>u</code>, <code>v</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>f</code>: VectorField</li><li><code>u0</code>: VectorField</li><li><code>v0</code>: VectorField</li><li><code>T</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>u</code>: VectorField</li><li><code>v</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2709-L2741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> and <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2893-L2927">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1230-L1244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(heatCondMat, heatCapMat, heatFluxVec, supports)</code></pre><p>Applies boundary conditions <code>supports</code> on a heat conduction matrix <code>heatCondMat</code>, heat capacity matrix <code>heatCapMat</code> and heat flux vector <code>heatFluxVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed temperature <code>T</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1289-L1302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(stiffMat, massMat, dampMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code>, mass matrix <code>massMat</code>, damping matrix <code>dampMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>massMat</code>: SystemMatrix </li><li><code>dampMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1337-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{Matrix, Any}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{Matrix, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(dispVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a displacement vector <code>dispVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dispVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1507-L1520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}" href="#LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions(stiffMat, loadVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on a stiffness matrix <code>stiffMat</code> and load vector <code>loadVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>. Creates a new stiffness matrix and load vector.</p><p>Return: <code>stiffMat</code>, <code>loadVec</code></p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1258-L1272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}" href="#LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}"><code>LowLevelFEM.applyDeformationBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyDeformationBoundaryConditions!(deformVec, supports)</code></pre><p>Applies displacement boundary conditions <code>supports</code> on deformation vector <code>deformVec</code>. Mesh details are in <code>problem</code>. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>deformVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L1125-L1137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}" href="#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}"><code>LowLevelFEM.applyElasticSupport!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyElasticSupport!(stiffMat, elastSupp)</code></pre><p>Applies elastic support boundary conditions <code>elastSupp</code> on a stiffness matrix <code>stiffMat</code>. Mesh details are in <code>problem</code>. <code>elastSupp</code> is a tuple of <code>name</code> of physical group and prescribed <code>kx</code>, <code>ky</code> and <code>kz</code> stiffnesses.</p><p>Return: none</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>elastSupp</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1577-L1589">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyHeatConvection!-Tuple{Any, Any, Any}" href="#LowLevelFEM.applyHeatConvection!-Tuple{Any, Any, Any}"><code>LowLevelFEM.applyHeatConvection!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyHeatConvection!(heatCondMat, heatFluxVec, heatConv)</code></pre><p>Applies heat convectiom boundary conditions <code>heatConv</code> on a heat conduction matrix <code>heatCondMat</code> and heat flux vector <code>heatFluxVec</code>. Mesh details are in <code>problem</code>. <code>heatConv</code> is a tuple of <code>name</code> of physical group and prescribed heat transfer coefficient <code>h</code> and ambient temperature <code>Tₐ</code>. The ambient temperature can be either a constant or a  function of x, y and z coordinates.</p><p>Return: none</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatCondMat</code>: SystemMatrix </li><li><code>heatFluxVec</code>: VectorField</li><li><code>heatConv</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L909-L925">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.constrainedDoFs-Tuple{Any, Any}" href="#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}"><code>LowLevelFEM.constrainedDoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constrainedDoFs(problem, supports)</code></pre><p>Returns the serial numbers of constrained degrees of freedom. Support is a vector of boundary conditions given with the function <code>displacementConstraint</code>.</p><p>Return: <code>DoFs</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>DoFs</code>: Vector{Int64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1140-L1151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.curl-Tuple{LowLevelFEM.VectorField}" href="#LowLevelFEM.curl-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.curl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">curl(r::VectorField)</code></pre><p>Solves the rotation of the vector field <code>r</code>. An alternative way to solve <code>curl</code> is to use <code>∇</code> as a differencial operator.</p><p>Return: VectorField</p><p>Types:</p><ul><li><code>r</code>: VectorField</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x(X, Y, Z) = 2X + 3Y
y(X, Y, Z) = Y
z(X, Y, Z) = Z
fld = field(&quot;body&quot;, fx=x, fy=y, fz=z)
v = vectorField(problem, [fld])
D1 = curl(v)
D2 = ∇ × v
println(D1 == D2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L317-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}" href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)</code></pre><p>Generates the damping matrix for proportional damping case. <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅. The latter corresponds  to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. <code>K</code> is the stiffness matrix, <code>M</code> is the mass matrix and <code>ωₘₐₓ</code> is the  largest natural frequency.</p><p>Return: <code>dampingMatrix</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>α</code>: Float64</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>dampingMatrix</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L864-L886">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.displacementConstraint-Tuple{Any}" href="#LowLevelFEM.displacementConstraint-Tuple{Any}"><code>LowLevelFEM.displacementConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displacementConstraint(name; ux=..., uy=..., uz=...)</code></pre><p>Gives the displacement constraints on <code>name</code> physical group. At least one <code>ux</code>,  <code>uy</code> or <code>uz</code> value have to be given (depending on the dimension of the problem). <code>ux</code>, <code>uy</code> or <code>uz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); displacementConstraint(&quot;support1&quot;, ux=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>ux</code>: Float64 or Function</li><li><code>uy</code>: Float64 or Function</li><li><code>uz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L643-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elasticSupport-Tuple{Any}" href="#LowLevelFEM.elasticSupport-Tuple{Any}"><code>LowLevelFEM.elasticSupport</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elasticSupport(name; kx=..., ky=..., kz=...)</code></pre><p>Gives the distributed stiffness of the elastic support on <code>name</code> physical group. <code>kx</code>, <code>ky</code> or <code>kz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); elasticSupport(&quot;supp1&quot;, kx=fn)</code>) Default values are 1.</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>kx</code>: Float64 or Function</li><li><code>ky</code>: Float64 or Function</li><li><code>kz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L685-L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}" href="#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}"><code>LowLevelFEM.elasticSupportMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elasticSupportMatrix(problem, elSupp)</code></pre><p>Solves the elastic support matrix of the <code>problem</code>. <code>elSupp</code> is a vector of elastic supports defined in function <code>elasticSupport</code>. With the displacementent vector <code>q</code> in hand the reaction force vector <code>fR</code> arising from the elastic support can be solved. (<code>fR = heatConvMat * q</code>)</p><p>Return: <code>elSuppMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>elSupp</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>elSuppMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L913-L927">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elementsToNodes-Tuple{Any}" href="#LowLevelFEM.elementsToNodes-Tuple{Any}"><code>LowLevelFEM.elementsToNodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elementsToNodes(T)</code></pre><p>Solves the nodal results <code>F</code> from the elemental results <code>T</code>. <code>T</code> can be ScalarField, VectorField or TensorField.</p><p>Return: <code>F</code></p><p>Types:</p><ul><li><code>T</code>: ScalarField, VectorField or TensorField</li><li><code>F</code>: ScalarField, VectorField or TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1208-L1219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.equivalentNodalForce-Tuple{LowLevelFEM.VectorField}" href="#LowLevelFEM.equivalentNodalForce-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.equivalentNodalForce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equivalentNodalForce(r::VectorField)</code></pre><p>Solves the equivalent nodal force (when solving large deformation problems). (See <sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup>) <code>r</code> is the position vector field in the current configuration.</p><p>Return: VectorField</p><p>Types:</p><ul><li><code>r</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L788-L799">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.field-Tuple{Any}" href="#LowLevelFEM.field-Tuple{Any}"><code>LowLevelFEM.field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">field(name; f=..., fx=..., fy=..., fz=..., fxy=..., fyz=..., fzx=...)</code></pre><p>Gives the value of scalar, vector or tensor field on <code>name</code> physical group. At least one <code>fx</code>,  <code>fy</code> or <code>fz</code> etc. value have to be given (depending on the dimension of the problem). <code>fx</code>,  <code>fy</code> or <code>fz</code> etc. can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); field(&quot;surf1&quot;, fx=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function,...x7}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>f</code>: Float64 or Function</li><li><code>fx</code>: Float64 or Function</li><li><code>fy</code>: Float64 or Function</li><li><code>fz</code>: Float64 or Function</li><li><code>fxy</code>: Float64 or Function</li><li><code>fyz</code>: Float64 or Function</li><li><code>fzx</code>: Float64 or Function</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = y
f2 = field(&quot;face1&quot;, f=f1)
qq = scalarField(problem, [f2])
qqq = showDoFResults(problem, qq, :scalar)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L815-L843">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.fieldError-Tuple{Any}" href="#LowLevelFEM.fieldError-Tuple{Any}"><code>LowLevelFEM.fieldError</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fieldError(F)</code></pre><p>Solves the deviation of field results <code>F</code> (stresses, strains, heat flux components) at nodes, where the field has jumps. The result can be displayed with the <code>showDoFResults</code> function.</p><p>Return: <code>e</code></p><p>Types:</p><ul><li><code>F</code>: VectorField or TensorField</li><li><code>e</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1370-L1381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.freeDoFs-Tuple{Any, Any}" href="#LowLevelFEM.freeDoFs-Tuple{Any, Any}"><code>LowLevelFEM.freeDoFs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">freeDoFs(problem, supports)</code></pre><p>Returns the serial numbers of unconstrained degrees of freedom. Support is a vector of boundary conditions given with the function <code>displacementConstraint</code>.</p><p>Return: <code>DoFs</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>DoFs</code>: Vector{Int64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1189-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getEigenValues-Tuple{LowLevelFEM.VectorField}" href="#LowLevelFEM.getEigenValues-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.getEigenValues</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getEigenValues(A::VectorField)</code></pre><p>A function to extract the elements of a vector field to separate scalar fields.</p><p>Return: λ1, λ2, λ3</p><p>Types:</p><ul><li><code>A</code>: VectorField</li><li><code>λ1</code>: ScalarField</li><li><code>λ2</code>: ScalarField</li><li><code>λ3</code>: ScalarField</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">using LinearAlgebra
λ, Q = eigen(S)
λ1, λ2, λ2 = getEigenVectors(λ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L586-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getEigenVectors-Tuple{LowLevelFEM.TensorField}" href="#LowLevelFEM.getEigenVectors-Tuple{LowLevelFEM.TensorField}"><code>LowLevelFEM.getEigenVectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getEigenVectors(A::TensorField)</code></pre><p>A function to extract the columns of a tensor field to separate vector fields.</p><p>Return: N1, N2, N3</p><p>Types:</p><ul><li><code>A</code>: TensorField</li><li><code>N1</code>: VectorField</li><li><code>N2</code>: VectorField</li><li><code>N3</code>: VectorField</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">using LinearAlgebra
λ, Q = eigen(S)
N1, N2, N2 = getEigenVectors(Q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L529-L549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.getTagForPhysicalName-Tuple{Any}" href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getTagForPhysicalName(name)</code></pre><p>Returns <code>tags</code> of elements of physical group <code>name</code>.</p><p>Return: <code>tags</code></p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>tags</code>: Vector{Integer}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1314-L1324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.grad-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.VectorField}}" href="#LowLevelFEM.grad-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad(r::Union{ScalarField,VectorField})</code></pre><p>Solves the gradient of the scalar field or vector field <code>r</code>. An alternative way to solve <code>grad</code> is to use <code>∇</code> as a differencial operator.</p><p>Return: VectorField or TensorField</p><p>Types:</p><ul><li><code>r</code>: ScalarField or VectorField</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x(X, Y, Z) = 2X + 3Y
y(X, Y, Z) = Y
z(X, Y, Z) = Z
fld = field(&quot;body&quot;, fx=x, fy=y, fz=z)
v = vectorField(problem, [fld])
D1 = grad(v)
D2 = v ∘ ∇
println(D1 == D2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L398-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatCapacityMatrix-Tuple{Any}" href="#LowLevelFEM.heatCapacityMatrix-Tuple{Any}"><code>LowLevelFEM.heatCapacityMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatCapacityMatrix(problem; lumped=...)</code></pre><p>Solves the heat capacity matrix of the <code>problem</code>. If <code>lumped</code> is true, solves lumped heat capacity matrix.</p><p>Return: <code>heatCapMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>lumped</code>: Boolean</li><li><code>massMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L237-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConductionMatrix-Tuple{Any}" href="#LowLevelFEM.heatConductionMatrix-Tuple{Any}"><code>LowLevelFEM.heatConductionMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatConductionMatrix(problem)</code></pre><p>Solves the heat conduction matrix of the <code>problem</code>.</p><p>Return: <code>heatCondMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatCondMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConvection-Tuple{Any}" href="#LowLevelFEM.heatConvection-Tuple{Any}"><code>LowLevelFEM.heatConvection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatConvection(name; h=..., Tₐ=...)</code></pre><p>Gives the heat convection of the surface given with <code>name</code> physical group. <code>h</code> is the heat transfer coefficient of the surrounding media, <code>Tₐ</code> is the ambient temperature. The ambient temperature can be either a constant or a function of x, y and z.</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>h</code>: Float64</li><li><code>Tₐ</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L766-L780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}" href="#LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatConvectionMatrix(problem, heatConvection)</code></pre><p>Solves the heat convection matrix of the <code>problem</code>. <code>heatConvection</code>  is a vector of heat convection boundary condicions defined in function <code>heatConduction</code>. With the heat convection vector (see the <code>heatConvectionVector</code> function) <code>heatConvVec</code>, temperature field vector <code>T</code> in hand the heat flux vector <code>qCV</code> arising from the heat convection boundary condition can be solved. <code>qCV = heatConvMat * T - heatConvVec</code></p><p>Return: <code>heatConvMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatConvection</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatConvMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L535-L550">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatConvectionVector-Tuple{Any, Any}" href="#LowLevelFEM.heatConvectionVector-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatConvectionVector(problem, heatConvection)</code></pre><p>Solves a heat convection vector of <code>problem</code>. <code>heatConvection</code>  is a vector of heat convection boundary condicions defined in function <code>heatConduction</code>. With the heat convection matrix (see the <code>heatConvectionMatrix</code> function) <code>heatConvMat</code>, temperature field vector <code>T</code> in hand the heat flux vector <code>qCV</code> arising from the heat convection boundary condition can be solved. <code>qCV = heatConvMat * T - heatConvVec</code></p><p>Return: <code>heatConvVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatConvection</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatConvVec</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L615-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatFlux-Tuple{Any}" href="#LowLevelFEM.heatFlux-Tuple{Any}"><code>LowLevelFEM.heatFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatFlux(name; qn=...)</code></pre><p>Gives the heat flux normal to the surface of <code>name</code> physical group. <code>qn</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); load(&quot;flux1&quot;, qn=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>qn</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L724-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatFluxVector-Tuple{Any, Any}" href="#LowLevelFEM.heatFluxVector-Tuple{Any, Any}"><code>LowLevelFEM.heatFluxVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatFluxVector(problem, heatFlux)</code></pre><p>Solves a heat flux or heat source vector of <code>problem</code>. <code>heatFlux</code> is a tuple of name of physical group  <code>name</code>, heat flux <code>qn</code> normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.</p><ul><li>In case of 2D problems and Point physical group means concentrated heat flux.</li><li>In case of 2D problems and Line physical group means surface heat flux.</li><li>In case of 2D problems and Surface physical group means body heat source.</li><li>In case of 3D problems and Point physical group means concentrated heat flux.</li><li>In case of 3D problems and Line physical group means edge heat source.</li><li>In case of 3D problems and Surface physical group means surface heat flux.</li><li>In case of 3D problems and Volume physical group means body heat source.</li></ul><p>Return: <code>heatFluxVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatFlux</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatFluxVec</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L558-L578">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatSource-Tuple{Any}" href="#LowLevelFEM.heatSource-Tuple{Any}"><code>LowLevelFEM.heatSource</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatSource(name; h=...)</code></pre><p>Gives the body heat source in <code>name</code> physical group. <code>h</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); load(&quot;source1&quot;, h=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>h</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L745-L757">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.heatSourceVector-Tuple{Any, Any}" href="#LowLevelFEM.heatSourceVector-Tuple{Any, Any}"><code>LowLevelFEM.heatSourceVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heatSourceVector(problem, heatSource)</code></pre><p>Solves a heat flux or heat source vector of <code>problem</code>. <code>heatSource</code> is a tuple of name of physical group  <code>name</code>, heat flux <code>qn</code> normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.</p><ul><li>In case of 2D problems and Point physical group means concentrated heat flux.</li><li>In case of 2D problems and Line physical group means surface heat flux.</li><li>In case of 2D problems and Surface physical group means body heat source.</li><li>In case of 3D problems and Point physical group means concentrated heat flux.</li><li>In case of 3D problems and Line physical group means edge heat source.</li><li>In case of 3D problems and Surface physical group means surface heat flux.</li><li>In case of 3D problems and Volume physical group means body heat source.</li></ul><p>Same as the <code>heatFluxVector</code> function.</p><p>Return: <code>heatSourceVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>heatSource</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>heatSourceVec</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L586-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement!-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialDisplacement!(name, u0; ux=..., uy=..., uz=...)</code></pre><p>Changes the displacement values to <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in displacement vector <code>u0</code>.</p><p>Return: u0</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li><li><code>u0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2414-L2429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialDisplacement(problem, name; ux=..., uy=..., uz=...)</code></pre><p>Sets the displacement values <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial displacement vector <code>u0</code>.</p><p>Return: u0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>u0</code>: VectorField</li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2366-L2382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialTemperature!-Tuple{Any, Any}" href="#LowLevelFEM.initialTemperature!-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialTemperature!(name, T0; T=...)</code></pre><p>Changes the tempetature value to <code>T</code> at nodes belonging to physical group <code>name</code>. Original values are in temperature vector <code>T0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>T0</code>: ScalarField</li><li><code>T</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L1255-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialTemperature-Tuple{Any, Any}" href="#LowLevelFEM.initialTemperature-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialTemperature(problem, name; T=...)</code></pre><p>Sets the temperature value <code>T</code> at nodes belonging to physical group <code>name</code>. Returns the <code>T0</code> initial nodal temperature vector.</p><p>Return: T0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>T</code>: Float64 </li><li><code>T0</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L1228-L1241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity!-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialVelocity!(name, v0; vx=..., vy=..., vz=...)</code></pre><p>Changes the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in velocity vector <code>v0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>v0</code>: VectorField</li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2474-L2489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialVelocity(problem, name; vx=..., vy=..., vz=...)</code></pre><p>Sets the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial velocity vector <code>v0</code>.</p><p>Return: v0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li><li><code>v0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2453-L2469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.isSaved-Tuple{String}" href="#LowLevelFEM.isSaved-Tuple{String}"><code>LowLevelFEM.isSaved</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isSaved(fileName::String)</code></pre><p>Checks whether a variable has been saved or not.</p><p>Return: Boolean</p><p>Types:</p><ul><li><code>fileName</code>: String</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2677-L2687">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestEigenValue-Tuple{Any, Any}" href="#LowLevelFEM.largestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.largestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">largestEigenValue(K, M)</code></pre><p>Solves the smallest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘᵢₙ</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>λₘᵢₙ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2610-L2622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">largestPeriodTime(K, M)</code></pre><p>Solves the largest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2534-L2546">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}" href="#LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.latentHeatMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">latentHeatMatrix(problem, u, v, T0)</code></pre><p>Solves the latent heat matrix of the <code>problem</code>. With this matrix the generated heat due to deformations (given with displacement field <code>u</code> and velocity field <code>v</code>) can be solved. <code>T0</code> is the current temperature field which is given in absolute temperature scale (Kelvin).</p><p>Return: <code>latHeatMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>u</code>: VectorField</li><li><code>v</code>: VectorField</li><li><code>T0</code>: ScalarField</li><li><code>latHeatMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L369-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.load-Tuple{Any}" href="#LowLevelFEM.load-Tuple{Any}"><code>LowLevelFEM.load</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load(name; fx=..., fy=..., fz=...)</code></pre><p>Gives the intensity of distributed load on <code>name</code> physical group. At least one <code>fx</code>,  <code>fy</code> or <code>fz</code> value have to be given (depending on the dimension of the problem). <code>fx</code>,  <code>fy</code> or <code>fz</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); load(&quot;load1&quot;, fx=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>fx</code>: Float64 or Function</li><li><code>fy</code>: Float64 or Function</li><li><code>fz</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L664-L679">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.loadField-Tuple{String}" href="#LowLevelFEM.loadField-Tuple{String}"><code>LowLevelFEM.loadField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadField(fileName::String)</code></pre><p>Loads a ScalarField, VectorField, or TensorField from a file named <code>fileName</code> (without &quot;-LLF-Data.jld2&quot;). </p><p>Return: variabla</p><p>Types:</p><ul><li><code>fileName</code>: String</li><li><code>variable</code>: ScalarField, VectorField or TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2660-L2671">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.loadVector-Tuple{Any, Any}" href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadVector(problem, loads)</code></pre><p>Solves a load vector of <code>problem</code>. <code>loads</code> is a tuple of name of physical group  <code>name</code>, coordinates <code>fx</code>, <code>fy</code> and <code>fz</code> of the intensity of distributed force. It can solve traction or body force depending on the problem.</p><ul><li>In case of 2D problems and Point physical group means concentrated force.</li><li>In case of 2D problems and Line physical group means surface force.</li><li>In case of 2D problems and Surface physical group means body force.</li><li>In case of 3D problems and Point physical group means concentrated force.</li><li>In case of 3D problems and Line physical group means edge force.</li><li>In case of 3D problems and Surface physical group means surface force.</li><li>In case of 3D problems and Volume physical group means body force.</li></ul><p>Return: <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>loadVec</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1072-L1092">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.massMatrix-Tuple{Any}" href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">massMatrix(problem; lumped=...)</code></pre><p>Solves the mass matrix of the <code>problem</code>. If <code>lumped</code> is true, solves lumped mass matrix.</p><p>Return: <code>massMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>lumped</code>: Boolean</li><li><code>massMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L730-L741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.material-Tuple{Any}" href="#LowLevelFEM.material-Tuple{Any}"><code>LowLevelFEM.material</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">material(name; type=:Hooke, E=2.0e5, ν=0.3, ρ=7.85e-9, k=45, c=4.2e8, α=1.2e-5, λ=νE/(1+ν)/(1-2ν), μ=E/(1+ν)/2, κ=E/(1-2ν)/3)</code></pre><p>Returns a structure in which <code>name</code> is the name of a physical group, <code>type</code> is the name of the constitutive law (eg. <code>:Hooke</code>), <code>E</code> is the modulus of elasticity, <code>ν</code> Poisson&#39;s ratio and <code>ρ</code> is the mass density, <code>k</code> is the heat conductivity, <code>c</code> is the specific heat, <code>α</code> is the coefficient of heat expansion, <code>λ</code> and <code>μ</code> are the  Lamé parameters, <code>κ</code> is the Bulk modulus.</p><p>Return: mat</p><p>Types:</p><ul><li><code>mat</code>: Material</li><li><code>name</code>: String</li><li><code>type</code>: Symbol</li><li><code>E</code>: Float64</li><li><code>ν</code>: Float64</li><li><code>ρ</code>: Float64</li><li><code>k</code>: Float64</li><li><code>c</code>: Float64</li><li><code>α</code>: Float64</li><li><code>λ</code>: Float64</li><li><code>μ</code>: Float64</li><li><code>κ</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L494-L519">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalAcceleration!-Tuple{Any}" href="#LowLevelFEM.nodalAcceleration!-Tuple{Any}"><code>LowLevelFEM.nodalAcceleration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodalAcceleration!(name, a0; ax=..., ay=..., az=...)</code></pre><p>Changes the acceleration values <code>ax</code>, <code>ay</code> and <code>az</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in acceleration vector <code>a0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>a0</code>: VectorField</li><li><code>ax</code>: Float64</li><li><code>ay</code>: Float64</li><li><code>az</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2514-L2529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodalForce!-Tuple{Any}" href="#LowLevelFEM.nodalForce!-Tuple{Any}"><code>LowLevelFEM.nodalForce!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodalForce!(name, f0; fx=..., fy=..., fz=...)</code></pre><p>Changes the force values <code>fx</code>, <code>fy</code> and <code>fz</code> (depending on the dimension of the problem) at nodes belonging to physical group <code>name</code>. Original values are in load vector <code>f0</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>f0</code>: VectorField</li><li><code>fx</code>: Float64 </li><li><code>fy</code>: Float64 </li><li><code>fz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2494-L2509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodePositionVector-Tuple{Any}" href="#LowLevelFEM.nodePositionVector-Tuple{Any}"><code>LowLevelFEM.nodePositionVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodePositionVector(problem)</code></pre><p>Gives back the positiond vectors of all the nodes of the mesh as a VectorField. (Initial configuration)</p><p>Return: R</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>R</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nodesToElements-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}" href="#LowLevelFEM.nodesToElements-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.nodesToElements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodesToElements(T)</code></pre><p>Solves the element results <code>F</code> from the nodal results <code>T</code>. <code>T</code> can be ScalarField, VectorField or TensorField.</p><p>Return: <code>F</code></p><p>Types:</p><ul><li><code>T</code>: ScalarField, VectorField or TensorField</li><li><code>F</code>: ScalarField, VectorField or TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1260-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nonFollowerLoadVector-Tuple{LowLevelFEM.VectorField, Any}" href="#LowLevelFEM.nonFollowerLoadVector-Tuple{LowLevelFEM.VectorField, Any}"><code>LowLevelFEM.nonFollowerLoadVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonFollowerLoadVector(r::VectorField, load)</code></pre><p>Solves the non-follower load vector (when solving large deformation problems). <code>r</code> is the position vector field in the current configuration.</p><p>Return: VectorField</p><p>Types:</p><ul><li><code>r</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L963-L974">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.nonLinearStiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonLinearStiffnessMatrix(problem, q)</code></pre><p>Solves the nonlinear stiffness matrix of the <code>problem</code>. <code>q</code> is a displacement field.</p><p>Return: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: VectorField</li><li><code>stiffMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L443-L455">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.openPostProcessor-Tuple{}" href="#LowLevelFEM.openPostProcessor-Tuple{}"><code>LowLevelFEM.openPostProcessor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">openPostProcessor(; model=...)</code></pre><p>Launches the GMSH postprocessor window with open postprocessor tree (of <code>model</code>).</p><p>Return: none</p><p>Types:</p><ul><li><code>model</code>: Int64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2500-L2509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.openPreProcessor-Tuple{}" href="#LowLevelFEM.openPreProcessor-Tuple{}"><code>LowLevelFEM.openPreProcessor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">openPreProcessor(; openGL=...)</code></pre><p>Launches the GMSH preprocessor window with openGL disabled by default.</p><p>Return: none</p><p>Types:</p><ul><li><code>openGL</code>: Boolean</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2481-L2490">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.plotOnPath-Tuple{Any, Any}" href="#LowLevelFEM.plotOnPath-Tuple{Any, Any}"><code>LowLevelFEM.plotOnPath</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotOnPath(problem, pathName, field; points=100, step=..., plot=..., name=..., visible=..., offsetX=..., offsetY=..., offsetZ=...)</code></pre><p>Load a 2D plot on a path into a View in gmsh. <code>field</code> is the number of View in gmsh from which the data of a field is imported. <code>pathName</code> is the name of a physical group which contains a curve. The curve is devided into equal length intervals with number of <code>points</code> points. The field is shown at this points. <code>step</code> is the sequence number of displayed step. If no step is given, shows all  the aviable steps as an animation. If <code>plot</code> is true, additional return parameter, a tuple of vectors is given back, in which <code>x</code> is a vector of values in horizontal axis, <code>y</code> is a vector of values in vertical axis of a plot (see <code>Plots</code> package). <code>name</code> is the title of graph and <code>visible</code> is a true or false value to toggle on or off the initial visibility  in gmsh. This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>or</p><p>Return: <code>tag</code>, <code>xy</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>pathName</code>: String</li><li><code>field</code>: Integer</li><li><code>points</code>: Integer</li><li><code>step</code>: Integer</li><li><code>plot</code>: Boolean</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li><li><code>xy</code>: Tuples{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2254-L2285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.probe-Tuple{LowLevelFEM.TensorField, Any, Any, Any}" href="#LowLevelFEM.probe-Tuple{LowLevelFEM.TensorField, Any, Any, Any}"><code>LowLevelFEM.probe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">probe(A::Union{ScalarField,VectorField,TensorField}, x::Number, y::Number, z::Number; step=Int)</code></pre><p>Get a value of the field <code>A</code> in a point given with its coordinates <code>x</code>,<code>y</code>,<code>z</code> at time step <code>step</code>.</p><p>Return: Float64 or Vector{Float64} or Matrix{Float64}</p><p>Types:</p><ul><li><code>A</code>: ScalarField or VectorField or TensorField</li><li><code>x</code>: Number</li><li><code>y</code>: Number</li><li><code>z</code>: Number</li><li><code>step</code>: Int</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2545-L2559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.probe-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}, String}" href="#LowLevelFEM.probe-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}, String}"><code>LowLevelFEM.probe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">probe(A::Union{ScalarField,VectorField,TensorField}, s::String; step=Int)</code></pre><p>Get a value of the field <code>A</code> in a point given its physical name in GMSH at time step <code>step</code>.</p><p>Return: Float64 or Vector{Float64} or Matrix{Float64}</p><p>Types:</p><ul><li><code>A</code>: ScalarField or VectorField or TensorField</li><li><code>x</code>: Number</li><li><code>y</code>: Number</li><li><code>z</code>: Number</li><li><code>step</code>: Int</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2621-L2635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.resultant-Tuple{Any, Any, Any}" href="#LowLevelFEM.resultant-Tuple{Any, Any, Any}"><code>LowLevelFEM.resultant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resultant(problem, field, phName; grad=false, component=:x)</code></pre><p>Solves the resultant of <code>field</code> on <code>phName</code> physical group. Return the resultant(s) in <code>tuple</code>. Number of the members in <code>tuple</code> depends on the dimension of <code>problem</code>. It can solve the resultant of a load vector (sum of the elements of the vector), if <code>field</code> is a vector of floats. If <code>field</code> is a view (tag of a view in gmsh), then the integral of the field is solved. <code>field</code> must have only one component. If <code>grad</code> is <code>true</code>, then the gradient of the <code>field</code> will be evaluated and <code>component</code> of the gradient (<code>:x</code>, <code>:y</code> or <code>:z</code>) will be used to solve the resultant.</p><p>Return: <code>res</code></p><p>or</p><p>Return: <code>resx</code>, <code>resy</code></p><p>or</p><p>Return: <code>resx</code>, <code>resy</code>, <code>resz</code></p><p>Types:</p><ul><li><code>field</code>: Vector{Float64}</li><li><code>phName</code>: String </li><li><code>dim</code>: Int64</li><li><code>res</code>: Float64 </li><li><code>resx</code>: Float64 </li><li><code>resy</code>: Float64 </li><li><code>resz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1435-L1465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.rot-Tuple{LowLevelFEM.VectorField}" href="#LowLevelFEM.rot-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.rot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rot(r::VectorField)</code></pre><p>Solves the rotation of the vector field <code>r</code>. In some countries &quot;rot&quot; denotes the English &quot;curl&quot;. (See the <code>curl</code> function.)</p><p>Return: VectorField</p><p>Types:</p><ul><li><code>r</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L345-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}" href="#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}"><code>LowLevelFEM.rotateNodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotateNodes(problem, phName, CoordSys)</code></pre><p>Creates the <code>T</code> transformation matrix, which rotates the nodal coordinate system of the nodes in <code>phName</code> physical group to the coordinate systen defined by <code>CoordSys</code>. The mesh belongs to <code>problem</code>.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>phName</code>: String</li><li><code>CoordSys</code>: CoordinateSystem</li><li><code>T</code>: SparseMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1607-L1621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.saveField-Tuple{String, Union{Number, LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}" href="#LowLevelFEM.saveField-Tuple{String, Union{Number, LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.saveField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">saveField(fileName::String, variable::Union{ScalarField,VectorField,TensorField,Number})</code></pre><p>Saves <code>variable</code> of type ScalarField, VectorField, or TensorField to a file named <code>fileName</code>. The name of the file will be complemented with the string &quot;-LLF-Data.jld2&quot;</p><p>Return: none</p><p>Types:</p><ul><li><code>fileName</code>: String</li><li><code>variable</code>: ScalarField, VectorField or TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2643-L2655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.scalarField-Tuple{Any, Any}" href="#LowLevelFEM.scalarField-Tuple{Any, Any}"><code>LowLevelFEM.scalarField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scalarField(problem, dataField)</code></pre><p>Defines a scalar field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>.</p><p>Return: Vector{Float64}</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{Tuple{String, Float64,...}}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f2 = field(&quot;face1&quot;, f=1)
qq = scalarField(problem, [f2])
qqq = showDoFResults(problem, qq, :scalar)</code></pre><p>Here ScalarField is defined in nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L852-L873">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.setParameter-Tuple{Any, Any}" href="#LowLevelFEM.setParameter-Tuple{Any, Any}"><code>LowLevelFEM.setParameter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setParameter(name, value)</code></pre><p>Defines a parameter <code>name</code> and sets its value to <code>value</code>. </p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>value</code>: Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2515-L2525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.setParameters-Tuple{Any, Any}" href="#LowLevelFEM.setParameters-Tuple{Any, Any}"><code>LowLevelFEM.setParameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setParameters(name, value)</code></pre><p>Defines a parameter <code>name</code> and sets its value to <code>value</code>, which is a Vector{Float64}. </p><p>Return: none</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>value</code>: Vector{Float64}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2530-L2540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}" href="#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showBucklingResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showBucklingResults(Φ, name=..., visible=...)</code></pre><p>Loads buckling results into a View in gmsh. <code>Φ</code> is a struct of Eigen. <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the  initial visibility in gmsh. Click on ▷| to change the results. This function  returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>Φ</code>: Eigen</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1890-L1905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showDeformationResults-Tuple{LowLevelFEM.VectorField, Any}" href="#LowLevelFEM.showDeformationResults-Tuple{LowLevelFEM.VectorField, Any}"><code>LowLevelFEM.showDeformationResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showDeformationResults(r::VectorField, comp; name=String, visible=Boolean)</code></pre><p>Shows deformation result, where <code>r</code> contains the position vectors of nodes  in the <em>current configuration</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L1499-L1504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showDoFResults-Tuple{Any, Any}" href="#LowLevelFEM.showDoFResults-Tuple{Any, Any}"><code>LowLevelFEM.showDoFResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showDoFResults(q, comp; name=..., visible=...)</code></pre><p>Loads nodal results into a View in gmsh. <code>q</code> is the field to show, <code>comp</code> is the component of the field (:vector, :uvec, :ux, :uy, :uz, :vvec, :vx, :vy, :vz, :qvec, :qx, :qy, :qz, :T, :p, :qn, :s, :sx, :sy, :sz, :sxy, :syx, :syz, :szy, :szx, :sxz, :e, :ex, :ey, :ez, :exy, :eyx, :eyz, :ezy, :ezx, :exz, :seqv, :scalar, :tensor), <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the  initial visibility in gmsh. If <code>q</code> has more columns, then a sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>q</code>: ScalarField, VectorField or TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1727-L1746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showElementResults-Tuple{Any, Any}" href="#LowLevelFEM.showElementResults-Tuple{Any, Any}"><code>LowLevelFEM.showElementResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showElementResults(F, comp; name=..., visible=..., smooth=...)</code></pre><p>Same as <code>ShowStressResults</code> or <code>showStrainResults</code>, depending on the type of <code>F</code> data field.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>F</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2004-L2018">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}" href="#LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}"><code>LowLevelFEM.showHeatFluxResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showHeatFluxResults(Q, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads heat flux results into a View in gmsh. <code>Q</code> is a heat flux field to show, <code>comp</code> is the component of the field (:qvec, :qx, :qy, :qz, :q), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If <code>Q</code> contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>S</code>: VectorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2142-L2162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}" href="#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showModalResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showModalResults(Φ, name=..., visible=...)</code></pre><p>Loads modal results into a View in gmsh. <code>Φ</code> is a struct of Eigen. <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the  initial visibility in gmsh. Click on ▷| to change the results. This function  returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>Φ</code>: Eigen</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1870-L1885">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showOnSurface-Tuple{Any, Any}" href="#LowLevelFEM.showOnSurface-Tuple{Any, Any}"><code>LowLevelFEM.showOnSurface</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showOnSurface(field, phName; grad=false, component=:x, offsetX=0, offsetY=0, offsetZ=0, name=phName, visible=false)</code></pre><p>Shows the values of a scalar field at a surface which has a physical name <code>phName</code>. <code>field</code> is the tag of a view in GMSH. The values of the field are calculated at the intersection with the surface. <code>grad</code> has a true or false value to toggle on or off the gradient of the field. <code>component</code> is the component of the gradient of <code>field</code> (:x, :y, :z) to be shown. <code>offsetX</code>, <code>offsetY</code>, <code>offsetZ</code> are the offsets in the x, y and z directions where the values are picked from. <code>name</code> is a title to display and <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>field</code>: Integer</li><li><code>phName</code>: String</li><li><code>grad</code>: Boolean</li><li><code>component</code>: Symbol</li><li><code>offsetX</code>: Float64</li><li><code>offsetY</code>: Float64</li><li><code>offsetZ</code>: Float64</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2379-L2403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStrainResults-Tuple{Any, Any}" href="#LowLevelFEM.showStrainResults-Tuple{Any, Any}"><code>LowLevelFEM.showStrainResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showStrainResults(E, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads strain results into a View in gmsh. <code>E</code> is a strain field to show, <code>comp</code> is the component of the field (:e, :ex, :ey, :ez, :exy, :eyz, :ezx), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If <code>E</code> contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>E</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L1910-L1930">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.showStressResults-Tuple{Any, Any}" href="#LowLevelFEM.showStressResults-Tuple{Any, Any}"><code>LowLevelFEM.showStressResults</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">showStressResults(S, comp; name=..., visible=..., smooth=...)</code></pre><p>Loads stress results into a View in gmsh. <code>S</code> is a stress field to show, <code>comp</code> is the component of the field (:s, :sx, :sy, :sz, :sxy, :syz, :szx, :seqv), <code>name</code> is a title to display, <code>visible</code> is a true or false value to toggle on or off the initial visibility in gmsh and <code>smooth</code> is a true of false value to toggle smoothing the stress field on or off. If <code>S</code> contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.</p><p>Return: <code>tag</code></p><p>Types:</p><ul><li><code>S</code>: TensorField</li><li><code>comp</code>: Symbol</li><li><code>name</code>: String</li><li><code>visible</code>: Boolean</li><li><code>smooth</code>: Boolean</li><li><code>tag</code>: Integer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L2031-L2051">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestEigenValue-Tuple{Any, Any}" href="#LowLevelFEM.smallestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.smallestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smallestEigenValue(K, M)</code></pre><p>Solves the largest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘₐₓ</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>λₘₐₓ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2584-L2596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smallestPeriodTime(K, M)</code></pre><p>Solves the smallest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2560-L2572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveBuckling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveBuckling(problem, loads, constraints; n=6)</code></pre><p>Solves the multipliers for the first <code>n</code> critical forces and the corresponding  buckling shapes for the instability of the <code>problem</code>, when <code>loads</code> and  <code>constraints</code> are applied. Result can be presented by <code>showBucklingResults</code> function. <code>loads</code> and <code>constraints</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively.</p><p>Return: <code>buckling</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{tuples}</li><li><code>constraints</code>: Vector{tuples}</li><li><code>n</code>: Int64</li><li><code>buckling</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2323-L2340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBucklingModes-Tuple{Any, Any}" href="#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}"><code>LowLevelFEM.solveBucklingModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveBucklingModes(K, Knl; n=6)</code></pre><p>Solves the critical force multipliers and buckling mode shapes of a problem given by stiffness matrix <code>K</code> and the nonlinear stiffness matrix <code>Knl</code>. <code>n</code> is the number of buckling modes to solve. Returns the struct of critical forces and buckling modes. Results can be presented by <code>showBucklingResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>Knl</code>: SystemMatrix</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2215-L2229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDeformation-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveDeformation-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveDeformation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDeformation(problem::Problem, load, supp;
                followerLoad=false,
                loadSteps = 3,
                rampedLoad = true,
                rampedSupport = false,
                maxIteration = 10,
                saveSteps = false,
                saveIterations = false,
                plotConvergence = false,
                relativeError = 1e-5,
                initialDeformation=nodePositionVector(problem))</code></pre><p>Solves the deformed shape of a non-linearly elastic body...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L1409-L1423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-NTuple{4, Any}" href="#LowLevelFEM.solveDisplacement-NTuple{4, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(problem, load, supp, elasticSupp)</code></pre><p>Solves the displacement vector <code>q</code> of <code>problem</code> with loads <code>load</code>,  supports <code>supp</code> and elastic supports <code>elasticSupp</code>.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>load</code>: Vector{Tuple} </li><li><code>supp</code>: Vector{Tuple}</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1653-L1666">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(problem, load, supp)</code></pre><p>Solves the displacement vector <code>q</code> of <code>problem</code> with loads <code>load</code> and supports <code>supp</code>.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>load</code>: Vector{Tuple} </li><li><code>supp</code>: Vector{Tuple}</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1624-L1637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(K, q)</code></pre><p>Solves the equation K*q=f for the displacement vector <code>q</code>. <code>K</code> is the stiffness Matrix, <code>q</code> is the load vector.</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix </li><li><code>f</code>: VectorField </li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1599-L1611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveEigenModes-Tuple{Any, Any}" href="#LowLevelFEM.solveEigenModes-Tuple{Any, Any}"><code>LowLevelFEM.solveEigenModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveEigenModes(K, M; n=6, fₘᵢₙ=1.01)</code></pre><p>Solves the eigen frequencies and mode shapes of a problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>. <code>n</code> is the number of eigenfrequencies to solve, and solves the eigenfrequencies greater than <code>fₘᵢₙ</code>. Returns the struct of eigenfrequencies and eigen modes. Results can be presented by <code>showModalResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>n</code>: Int64</li><li><code>fₘᵢₙ</code>: Float64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2179-L2195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveHeatFlux-Tuple{Any}" href="#LowLevelFEM.solveHeatFlux-Tuple{Any}"><code>LowLevelFEM.solveHeatFlux</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveHeatFlux(T; DoFResults=false)</code></pre><p>Solves the heat flux field <code>q</code> from temperature vector <code>T</code>. heat flux is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>q</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results (otherwise <code>showHeatFluxResults</code> or <code>showElementResults</code>).</p><p>Return: <code>q</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>T</code>: ScalarField</li><li><code>q</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L1031-L1046">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveModalAnalysis-Tuple{Any}" href="#LowLevelFEM.solveModalAnalysis-Tuple{Any}"><code>LowLevelFEM.solveModalAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveModalAnalysis(problem; constraints=[]; loads=[], n=6)</code></pre><p>Solves the first <code>n</code> eigenfrequencies and the corresponding  mode shapes for the <code>problem</code>, when <code>loads</code> and  <code>constraints</code> are applied. <code>loads</code> and <code>contraints</code> are optional.  Result can be presented by <code>showModalResults</code> function.  <code>loads</code> and <code>constraints</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively. If <code>loads</code> are given, it solves the eigenfrequencies of a prestressed structure.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{tuples}</li><li><code>constraints</code>: Vector{tuples}</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L2248-L2266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStrain-Tuple{Any}" href="#LowLevelFEM.solveStrain-Tuple{Any}"><code>LowLevelFEM.solveStrain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveStrain(q; DoFResults=false)</code></pre><p>Solves the strain field <code>E</code> from displacement vector <code>q</code>. Strain field is given per elements, so it usually contains jumps at the boundaries of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>E</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStrainResults</code> or <code>showElementResults</code>).</p><p>Return: <code>E</code></p><p>Types:</p><ul><li><code>q</code>: VectorField</li><li><code>E</code>: TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1683-L1697">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStress-Tuple{Any}" href="#LowLevelFEM.solveStress-Tuple{Any}"><code>LowLevelFEM.solveStress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveStress(q; T=..., T₀=..., DoFResults=false)</code></pre><p>Solves the stress field <code>S</code> from displacement vector <code>q</code>. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>S</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStressResults</code> or <code>showElementResults</code>). If the <code>T</code> temperature field (and <code>T₀</code> initial temperature field if it differs from zero) is given, the function solves also the thermal stresses.</p><p>Return: <code>S</code></p><p>Types:</p><ul><li><code>q</code>: VectorField</li><li><code>T</code>: ScalarField</li><li><code>T₀</code>: ScalarField</li><li><code>S</code>: TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L1900-L1918">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-NTuple{4, Any}" href="#LowLevelFEM.solveTemperature-NTuple{4, Any}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveTemperature(problem, flux, temp, heatconv)</code></pre><p>Solves the temperature field <code>T</code> of <code>problem</code> with given heat flux <code>flux</code>, temperature <code>temp</code> and heat convection <code>heatconv</code>.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>flux</code>: Vector{Tuple} </li><li><code>temp</code>: Vector{Tuple}</li><li><code>heatconv</code>: Vector{Tuple}</li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L978-L992">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}" href="#LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveTemperature(problem, flux, temp)</code></pre><p>Solves the temperature field <code>T</code> of <code>problem</code> with given heat flux <code>flux</code> and temperature <code>temp</code>.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>flux</code>: Vector{Tuple} </li><li><code>temp</code>: Vector{Tuple}</li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L957-L970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-Tuple{Any, LowLevelFEM.VectorField}" href="#LowLevelFEM.solveTemperature-Tuple{Any, LowLevelFEM.VectorField}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveTemperature(problem, u; T0=273.0)</code></pre><p>Solves the raise of temperature <code>T</code> during reversible (no dissipation) elastic deformations, where <code>u</code> is the displacement field, and <code>problem</code> is a heat cunduction problem.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>problem</code>: Problem </li><li><code>u</code>: VectorField </li><li><code>T0</code>: Float64</li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L1001-L1014">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.ScalarField}" href="#LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.ScalarField}"><code>LowLevelFEM.solveTemperature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveTemperature(K, q)</code></pre><p>Solves the equation K*T=q for the temperature field <code>T</code>. <code>K</code> is the heat conduction matrix, <code>q</code> is the heat flux vector.</p><p>Return: <code>T</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix </li><li><code>q</code>: ScalarField </li><li><code>T</code>: ScalarField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/heat.jl#L940-L952">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.stiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stiffnessMatrix(problem)</code></pre><p>Solves the stiffness matrix of the <code>problem</code>.</p><p>Return: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/linear.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}" href="#LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">suppressDeformationAtBoundaries!(stiffMat, loadVec, supports)</code></pre><p>Suppresses the displacements given in <code>support</code> in <code>stiffMat</code> and <code>loadVec</code>  so that it is only necessary to consider them once during iteration. <code>stiffMat</code> is the stiffness matrix, <code>loadVec</code> is the load vector. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: none</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L1209-L1224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}" href="#LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">suppressDeformationAtBoundaries(stiffMat, loadVec, supports)</code></pre><p>Suppresses the displacements given in <code>support</code> in <code>stiffMat</code> and <code>loadVec</code>  so that it is only necessary to consider them once during iteration. <code>stiffMat</code> is the stiffness matrix, <code>loadVec</code> is the load vector. <code>supports</code> is a tuple of <code>name</code> of physical group and prescribed displacements <code>ux</code>, <code>uy</code> and <code>uz</code>.</p><p>Return: stiffMat1, loadVec1</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>loadVec</code>: VectorField</li><li><code>supports</code>: Vector{Tuple{String, Float64, Float64, Float64}}</li><li><code>stiffMat1</code>: SystemMatrix </li><li><code>loadVec1</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L1380-L1397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.tangentMatrixConstitutive-Tuple{LowLevelFEM.VectorField}" href="#LowLevelFEM.tangentMatrixConstitutive-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.tangentMatrixConstitutive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tangentMatrixConstitutive(r::VectorField)</code></pre><p>Solves the constitutive part of the tangent matrix (when solving large deformation problems). (See <sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup>) <code>r</code> is the position vector field in the current configuration.</p><p>Return: SystemMatrix</p><p>Types:     - <code>r</code>: VectorField</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L427-L440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.tangentMatrixInitialStress-Tuple{LowLevelFEM.VectorField}" href="#LowLevelFEM.tangentMatrixInitialStress-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.tangentMatrixInitialStress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tangentMatrixInitialStress(r::VectorField)</code></pre><p>Solves the initial stress part of the tangent matrix (when solving large deformation problems). (See <sup class="footnote-reference"><a id="citeref-6" href="#footnote-6">[6]</a></sup>) <code>r</code> is the position vector field in the current configuration.</p><p>Return: SystemMatrix</p><p>Types:</p><ul><li><code>r</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L619-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.temperatureConstraint-Tuple{Any}" href="#LowLevelFEM.temperatureConstraint-Tuple{Any}"><code>LowLevelFEM.temperatureConstraint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">temperatureConstraint(name; T=...)</code></pre><p>Gives the temperature constraints on <code>name</code> physical group.  <code>T</code> can be a constant value, or a function of <code>x</code>, <code>y</code> and <code>z</code>. (E.g. <code>fn(x,y,z)=5*(5-x)); temperatureConstraint(&quot;surf1&quot;, T=fn)</code>)</p><p>Return: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}</p><p>Types:</p><ul><li><code>name</code>: String</li><li><code>T</code>: Float64 or Function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L706-L718">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.tensorField-Tuple{Any, Any}" href="#LowLevelFEM.tensorField-Tuple{Any, Any}"><code>LowLevelFEM.tensorField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensorField(problem, dataField; type=...)</code></pre><p>Defines a vector field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>. <code>type</code> can be an arbitrary <code>Symbol</code>, eg. <code>:u</code> or <code>:f</code>.</p><p>Return: TensorField</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{Tuple{String, Float64,...}}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = sin(x)
f2(x, y, z) = 5y
ff1 = field(&quot;face1&quot;, fx=f1, fy=f2, fz=0, fxy=1, fyz=1, fzx=f2)
ff2 = field(&quot;face2&quot;, fx=f2, fy=f1, fz=1, fxy=1, fyz=f1, fzx=1)
qq = tensorField(problem, [ff1, ff2])
qq0 = showDoFResults(problem, qq, :tensor)</code></pre><p>Here TensorField is defined in nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L994-L1019">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.vectorField-Tuple{Any, Any}" href="#LowLevelFEM.vectorField-Tuple{Any, Any}"><code>LowLevelFEM.vectorField</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vectorField(problem, dataField; type=...)</code></pre><p>Defines a vector field from <code>dataField</code>, which is a tuple of <code>name</code> of physical group and prescribed values or functions. Mesh details are in <code>problem</code>. <code>type</code> can be an arbitrary <code>Symbol</code>, eg. <code>:u</code> or <code>:f</code>.</p><p>Return: VectorField</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>dataField</code>: Vector{Tuple{String, Float64,...}}</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">f1(x, y, z) = sin(x)
f2(x, y, z) = 5y
ff1 = field(&quot;face1&quot;, fx=f1, fy=f2, fz=0)
ff2 = field(&quot;face2&quot;, fx=f2, fy=f1, fz=1)
qq = vectorField(problem, [ff1, ff2])
qq0 = showDoFResults(problem, qq, :vector)</code></pre><p>Here VectorField is defined in nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/general.jl#L907-L932">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.∇-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}" href="#LowLevelFEM.∇-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.∇</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∇(rr::Union{VectorField, ScalarField, TensorField}; nabla=:grad)</code></pre><p>Solves the deriavatives of <code>rr</code>.</p><ul><li>If <code>rr</code> is a ScalarField, <code>nabla</code> is :grad, it solves the gradient of <code>rr</code>, which is a VectorField.</li><li>If <code>rr</code> is a VectorField, <code>nabla</code> is :grad, it solves the gradient of <code>rr</code>, which is a TensorField.</li><li>If <code>rr</code> is a VectorField, <code>nabla</code> is :curl, it solves the rotation of <code>rr</code>, which is a VectorField.</li><li>If <code>rr</code> is a VectorField, <code>nabla</code> is :div, it solves the divergence of <code>rr</code>, which is a ScalarField.</li><li>If <code>rr</code> is a TensorField, <code>nabla</code> is :div, it solves the divergence of <code>rr</code>, which is a VectorField.</li></ul><p>Return: ScalarField, VectorField or TensorField</p><p>Types:</p><ul><li><code>rr</code>: ScalarField, VectorField or TensorField</li><li><code>nabla</code>: Symbol</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/4c200d2af60b9d904f03502833e71052e5df9800/src/nonlinear.jl#L43-L58">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LowLevelFEM.CoordinateSystem"><code>LowLevelFEM.CoordinateSystem</code></a></li><li><a href="#LowLevelFEM.Eigen"><code>LowLevelFEM.Eigen</code></a></li><li><a href="#LowLevelFEM.Material"><code>LowLevelFEM.Material</code></a></li><li><a href="#LowLevelFEM.Problem"><code>LowLevelFEM.Problem</code></a></li><li><a href="#LowLevelFEM.ScalarField"><code>LowLevelFEM.ScalarField</code></a></li><li><a href="#LowLevelFEM.SystemMatrix"><code>LowLevelFEM.SystemMatrix</code></a></li><li><a href="#LowLevelFEM.TensorField"><code>LowLevelFEM.TensorField</code></a></li><li><a href="#LowLevelFEM.Transformation"><code>LowLevelFEM.Transformation</code></a></li><li><a href="#LowLevelFEM.VectorField"><code>LowLevelFEM.VectorField</code></a></li><li><a href="#Base.:*-Tuple{Number, LowLevelFEM.ScalarField}"><code>Base.:*</code></a></li><li><a href="#Base.:*-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:*</code></a></li><li><a href="#Base.:*-Tuple{LowLevelFEM.ScalarField, Number}"><code>Base.:*</code></a></li><li><a href="#Base.:+-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:+</code></a></li><li><a href="#Base.:--Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:-</code></a></li><li><a href="#Base.:/-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}"><code>Base.:/</code></a></li><li><a href="#Base.copy-Tuple{LowLevelFEM.SystemMatrix}"><code>Base.copy</code></a></li><li><a href="#Base.div-Tuple{Union{LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>Base.div</code></a></li><li><a href="#Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}"><code>Base.show</code></a></li><li><a href="#LowLevelFEM.CDM-NTuple{8, Any}"><code>LowLevelFEM.CDM</code></a></li><li><a href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a></li><li><a href="#LowLevelFEM.FDM-NTuple{6, Any}"><code>LowLevelFEM.FDM</code></a></li><li><a href="#LowLevelFEM.HHT-NTuple{7, Any}"><code>LowLevelFEM.HHT</code></a></li><li><a href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{Matrix, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}"><code>LowLevelFEM.applyBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}"><code>LowLevelFEM.applyDeformationBoundaryConditions!</code></a></li><li><a href="#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}"><code>LowLevelFEM.applyElasticSupport!</code></a></li><li><a href="#LowLevelFEM.applyHeatConvection!-Tuple{Any, Any, Any}"><code>LowLevelFEM.applyHeatConvection!</code></a></li><li><a href="#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}"><code>LowLevelFEM.constrainedDoFs</code></a></li><li><a href="#LowLevelFEM.curl-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.curl</code></a></li><li><a href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a></li><li><a href="#LowLevelFEM.displacementConstraint-Tuple{Any}"><code>LowLevelFEM.displacementConstraint</code></a></li><li><a href="#LowLevelFEM.elasticSupport-Tuple{Any}"><code>LowLevelFEM.elasticSupport</code></a></li><li><a href="#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}"><code>LowLevelFEM.elasticSupportMatrix</code></a></li><li><a href="#LowLevelFEM.elementsToNodes-Tuple{Any}"><code>LowLevelFEM.elementsToNodes</code></a></li><li><a href="#LowLevelFEM.equivalentNodalForce-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.equivalentNodalForce</code></a></li><li><a href="#LowLevelFEM.field-Tuple{Any}"><code>LowLevelFEM.field</code></a></li><li><a href="#LowLevelFEM.fieldError-Tuple{Any}"><code>LowLevelFEM.fieldError</code></a></li><li><a href="#LowLevelFEM.freeDoFs-Tuple{Any, Any}"><code>LowLevelFEM.freeDoFs</code></a></li><li><a href="#LowLevelFEM.getEigenValues-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.getEigenValues</code></a></li><li><a href="#LowLevelFEM.getEigenVectors-Tuple{LowLevelFEM.TensorField}"><code>LowLevelFEM.getEigenVectors</code></a></li><li><a href="#LowLevelFEM.getTagForPhysicalName-Tuple{Any}"><code>LowLevelFEM.getTagForPhysicalName</code></a></li><li><a href="#LowLevelFEM.grad-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.grad</code></a></li><li><a href="#LowLevelFEM.heatCapacityMatrix-Tuple{Any}"><code>LowLevelFEM.heatCapacityMatrix</code></a></li><li><a href="#LowLevelFEM.heatConductionMatrix-Tuple{Any}"><code>LowLevelFEM.heatConductionMatrix</code></a></li><li><a href="#LowLevelFEM.heatConvection-Tuple{Any}"><code>LowLevelFEM.heatConvection</code></a></li><li><a href="#LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionMatrix</code></a></li><li><a href="#LowLevelFEM.heatConvectionVector-Tuple{Any, Any}"><code>LowLevelFEM.heatConvectionVector</code></a></li><li><a href="#LowLevelFEM.heatFlux-Tuple{Any}"><code>LowLevelFEM.heatFlux</code></a></li><li><a href="#LowLevelFEM.heatFluxVector-Tuple{Any, Any}"><code>LowLevelFEM.heatFluxVector</code></a></li><li><a href="#LowLevelFEM.heatSource-Tuple{Any}"><code>LowLevelFEM.heatSource</code></a></li><li><a href="#LowLevelFEM.heatSourceVector-Tuple{Any, Any}"><code>LowLevelFEM.heatSourceVector</code></a></li><li><a href="#LowLevelFEM.initialDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement</code></a></li><li><a href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a></li><li><a href="#LowLevelFEM.initialTemperature-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature</code></a></li><li><a href="#LowLevelFEM.initialTemperature!-Tuple{Any, Any}"><code>LowLevelFEM.initialTemperature!</code></a></li><li><a href="#LowLevelFEM.initialVelocity-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity</code></a></li><li><a href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a></li><li><a href="#LowLevelFEM.isSaved-Tuple{String}"><code>LowLevelFEM.isSaved</code></a></li><li><a href="#LowLevelFEM.largestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.largestEigenValue</code></a></li><li><a href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a></li><li><a href="#LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.latentHeatMatrix</code></a></li><li><a href="#LowLevelFEM.load-Tuple{Any}"><code>LowLevelFEM.load</code></a></li><li><a href="#LowLevelFEM.loadField-Tuple{String}"><code>LowLevelFEM.loadField</code></a></li><li><a href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a></li><li><a href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a></li><li><a href="#LowLevelFEM.material-Tuple{Any}"><code>LowLevelFEM.material</code></a></li><li><a href="#LowLevelFEM.nodalAcceleration!-Tuple{Any}"><code>LowLevelFEM.nodalAcceleration!</code></a></li><li><a href="#LowLevelFEM.nodalForce!-Tuple{Any}"><code>LowLevelFEM.nodalForce!</code></a></li><li><a href="#LowLevelFEM.nodePositionVector-Tuple{Any}"><code>LowLevelFEM.nodePositionVector</code></a></li><li><a href="#LowLevelFEM.nodesToElements-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.nodesToElements</code></a></li><li><a href="#LowLevelFEM.nonFollowerLoadVector-Tuple{LowLevelFEM.VectorField, Any}"><code>LowLevelFEM.nonFollowerLoadVector</code></a></li><li><a href="#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.nonLinearStiffnessMatrix</code></a></li><li><a href="#LowLevelFEM.openPostProcessor-Tuple{}"><code>LowLevelFEM.openPostProcessor</code></a></li><li><a href="#LowLevelFEM.openPreProcessor-Tuple{}"><code>LowLevelFEM.openPreProcessor</code></a></li><li><a href="#LowLevelFEM.plotOnPath-Tuple{Any, Any}"><code>LowLevelFEM.plotOnPath</code></a></li><li><a href="#LowLevelFEM.probe-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}, String}"><code>LowLevelFEM.probe</code></a></li><li><a href="#LowLevelFEM.probe-Tuple{LowLevelFEM.TensorField, Any, Any, Any}"><code>LowLevelFEM.probe</code></a></li><li><a href="#LowLevelFEM.resultant-Tuple{Any, Any, Any}"><code>LowLevelFEM.resultant</code></a></li><li><a href="#LowLevelFEM.rot-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.rot</code></a></li><li><a href="#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}"><code>LowLevelFEM.rotateNodes</code></a></li><li><a href="#LowLevelFEM.saveField-Tuple{String, Union{Number, LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.saveField</code></a></li><li><a href="#LowLevelFEM.scalarField-Tuple{Any, Any}"><code>LowLevelFEM.scalarField</code></a></li><li><a href="#LowLevelFEM.setParameter-Tuple{Any, Any}"><code>LowLevelFEM.setParameter</code></a></li><li><a href="#LowLevelFEM.setParameters-Tuple{Any, Any}"><code>LowLevelFEM.setParameters</code></a></li><li><a href="#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showBucklingResults</code></a></li><li><a href="#LowLevelFEM.showDeformationResults-Tuple{LowLevelFEM.VectorField, Any}"><code>LowLevelFEM.showDeformationResults</code></a></li><li><a href="#LowLevelFEM.showDoFResults-Tuple{Any, Any}"><code>LowLevelFEM.showDoFResults</code></a></li><li><a href="#LowLevelFEM.showElementResults-Tuple{Any, Any}"><code>LowLevelFEM.showElementResults</code></a></li><li><a href="#LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}"><code>LowLevelFEM.showHeatFluxResults</code></a></li><li><a href="#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}"><code>LowLevelFEM.showModalResults</code></a></li><li><a href="#LowLevelFEM.showOnSurface-Tuple{Any, Any}"><code>LowLevelFEM.showOnSurface</code></a></li><li><a href="#LowLevelFEM.showStrainResults-Tuple{Any, Any}"><code>LowLevelFEM.showStrainResults</code></a></li><li><a href="#LowLevelFEM.showStressResults-Tuple{Any, Any}"><code>LowLevelFEM.showStressResults</code></a></li><li><a href="#LowLevelFEM.smallestEigenValue-Tuple{Any, Any}"><code>LowLevelFEM.smallestEigenValue</code></a></li><li><a href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a></li><li><a href="#LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveBuckling</code></a></li><li><a href="#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}"><code>LowLevelFEM.solveBucklingModes</code></a></li><li><a href="#LowLevelFEM.solveDeformation-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveDeformation</code></a></li><li><a href="#LowLevelFEM.solveDisplacement-NTuple{4, Any}"><code>LowLevelFEM.solveDisplacement</code></a></li><li><a href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a></li><li><a href="#LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveDisplacement</code></a></li><li><a href="#LowLevelFEM.solveEigenModes-Tuple{Any, Any}"><code>LowLevelFEM.solveEigenModes</code></a></li><li><a href="#LowLevelFEM.solveHeatFlux-Tuple{Any}"><code>LowLevelFEM.solveHeatFlux</code></a></li><li><a href="#LowLevelFEM.solveModalAnalysis-Tuple{Any}"><code>LowLevelFEM.solveModalAnalysis</code></a></li><li><a href="#LowLevelFEM.solveStrain-Tuple{Any}"><code>LowLevelFEM.solveStrain</code></a></li><li><a href="#LowLevelFEM.solveStress-Tuple{Any}"><code>LowLevelFEM.solveStress</code></a></li><li><a href="#LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.ScalarField}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.solveTemperature-NTuple{4, Any}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.solveTemperature-Tuple{Any, LowLevelFEM.VectorField}"><code>LowLevelFEM.solveTemperature</code></a></li><li><a href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a></li><li><a href="#LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries</code></a></li><li><a href="#LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}"><code>LowLevelFEM.suppressDeformationAtBoundaries!</code></a></li><li><a href="#LowLevelFEM.tangentMatrixConstitutive-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.tangentMatrixConstitutive</code></a></li><li><a href="#LowLevelFEM.tangentMatrixInitialStress-Tuple{LowLevelFEM.VectorField}"><code>LowLevelFEM.tangentMatrixInitialStress</code></a></li><li><a href="#LowLevelFEM.temperatureConstraint-Tuple{Any}"><code>LowLevelFEM.temperatureConstraint</code></a></li><li><a href="#LowLevelFEM.tensorField-Tuple{Any, Any}"><code>LowLevelFEM.tensorField</code></a></li><li><a href="#LowLevelFEM.vectorField-Tuple{Any, Any}"><code>LowLevelFEM.vectorField</code></a></li><li><a href="#LowLevelFEM.∇-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}"><code>LowLevelFEM.∇</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>Serfőző, D., Pere, B.: <em>An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems</em>, Meccanica, <a href="https://doi.org/10.1007/s11012-025-02036-9">https://doi.org/10.1007/s11012-025-02036-9</a></li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a>Bathe, K. J.: Finite element procedures, Wiley, 1983, <a href="https://doi.org/10.1002/nag.1610070412">https://doi.org/10.1002/nag.1610070412</a></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. <em>Improved  numerical dissipation for time integration algorithms in structural  dynamics</em>. Earthquake Engineering &amp; Structural Dynamics 5.3 (1977): 283-292.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Belytschko, Ted, and Thomas JR, Hughes: <em>Computational methods for  transient analysis</em>, North-Holland, (1983).</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Serfőző, D., Pere, B.: <em>A method to accurately define arbitrary algorithmic damping character as viscous damping</em>. Arch Appl Mech 93, 3581–3595 (2023). <a href="https://doi.org/10.1007/s00419-023-02454-9">https://doi.org/10.1007/s00419-023-02454-9</a></li><li class="footnote" id="footnote-6"><a class="tag is-link" href="#citeref-6">6</a>Javier Bonet, Richard D. Wood: <em>Nonlinear Continuum Mechanics for Finite Element Analysis</em>,  Cambridge University Press, 2008, <a href="https://doi.org/10.1017/CBO9780511755446">https://doi.org/10.1017/CBO9780511755446</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../Examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 4 September 2025 22:29">Thursday 4 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
