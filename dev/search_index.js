var documenterSearchIndex = {"docs":
[{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/#2D-Cantilever","page":"Examples","title":"2D Cantilever","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ on deformed shape)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ and $\\tau_{yx}$ on path)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever2D.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"import LowLevelFEM as FEM\nusing LowLevelFEM\n\ngmsh.initialize()\n\ngmsh.open(\"cantilever2D.geo\")\nmat = FEM.material(\"body\", E=2.e5, ν=0.3)\nproblem = FEM.Problem([mat], type=:PlaneStress)\n\nsupp = FEM.displacementConstraint(\"supp\", ux=0, uy=0)\nload = FEM.load(\"load\", fy=-1)\n\nq = FEM.solveDisplacement(problem, [load], [supp)\nS = FEM.solveStress(problem, q)\n\nu = FEM.showDoFResults(problem, q, :uvec)\nux = FEM.showDoFResults(problem, q, :ux)\nuy = FEM.showDoFResults(problem, q, :uy)\n\ns = FEM.showStressResults(problem, S, :s, visible=true, smooth=true)\nsx = FEM.showStressResults(problem, S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = FEM.showStressResults(problem, S, :sy, name=\"σy\", visible=false, smooth=true)\nsxy = FEM.showStressResults(problem, S, :sxy, name=\"τxy\", visible=false, smooth=true)\n\nFEM.plotOnPath(problem, \"path\", sx, name=\"σx\", visible=false);\nFEM.plotOnPath(problem, \"path\", sxy, name=\"τxy\", visible=false);\nFEM.plotOnPath(problem, \"path\", ux, name=\"ux\", visible=false);\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever2D.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"SetFactory(\"OpenCASCADE\");\n\nRectangle(1) = {0, 0, 0, 100, 10, 0};\n\nPhysical Curve(\"supp\", 5) = {4};\nPhysical Curve(\"load\", 6) = {2};\nPhysical Surface(\"body\", 7) = {1};\n\nRecombine Surface {1};\n\nTransfinite Line {2,4} = 4;\nTransfinite Line {1,3} = 31;\nTransfinite Surface {1};\n\nMesh.ElementOrder = 3;\n\nSetName \"cantilever2D\";\nMesh 2;\n\nPoint(5) = {10, 0, 0, 1.0};\nPoint(6) = {10, 10, 0, 1.0};\nLine(5) = {5, 6};\n\nPhysical Curve(\"path\", 8) = {5};","category":"page"},{"location":"Examples/#3D-Cantilever","page":"Examples","title":"3D Cantilever","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ on deformed shape)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever3D.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"import LowLevelFEM as FEM\nusing LowLevelFEM\n\ngmsh.initialize()\n\ngmsh.open(\"cantilever3D.geo\")\nmat = FEM.material(\"body\", E=2.e5, ν=0.3)\nproblem = FEM.Problem([mat])\n\nsupp = FEM.displacementConstraint(\"supp\", ux=0, uy=0, uz=0)\nload = FEM.load(\"load\", fy=-1)\n\nK = FEM.stiffnessMatrix(problem)\nf = FEM.loadVector(problem, [load])\n\nFEM.applyBoundaryConditions!(problem, K, f, [supp])\n\nq = FEM.solveDisplacement(K, f)\nS = FEM.solveStress(problem, q)\n\nu = FEM.showDoFResults(problem, q, :uvec, name=\"uvec\", visible=false)\nux = FEM.showDoFResults(problem, q, :ux, name=\"ux\", visible=false)\nuy = FEM.showDoFResults(problem, q, :uy, name=\"uy\", visible=false)\nuz = FEM.showDoFResults(problem, q, :uz, name=\"uz\", visible=false)\n\ns = FEM.showStressResults(problem, S, :s, name=\"σ\", visible=true, smooth=true)\nsx = FEM.showStressResults(problem, S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = FEM.showStressResults(problem, S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = FEM.showStressResults(problem, S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = FEM.showStressResults(problem, S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = FEM.showStressResults(problem, S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = FEM.showStressResults(problem, S, :szx, name=\"τzx\", visible=false, smooth=true)\n\nFEM.plotOnPath(problem, \"path\", sx, name=\"σx\", visible=false);\nFEM.plotOnPath(problem, \"path\", sxy, name=\"τxy\", visible=false);\nFEM.plotOnPath(problem, \"path\", ux, name=\"ux\", visible=false);\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever3D.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"SetFactory(\"OpenCASCADE\");\n\nBox(1) = {0, 0, 0, 100, 10, 10};\n\nPhysical Surface(\"supp\", 13) = {1};\nPhysical Surface(\"load\", 14) = {2};\nPhysical Volume(\"body\", 15) = {1};\n\nRecombine Surface {1:6};\n\nTransfinite Line {1:8} = 4;\nTransfinite Line {9:12} = 31;\nTransfinite Surface {1:6};\nTransfinite Volume {1};\n\nMesh.ElementOrder = 3;\n\nSetName \"cantilever3D\";\nMesh 3;\n\nPoint(9) = {10, 0, 5, 1.0};\nPoint(10) = {10, 10, 5, 1.0};\nLine(13) = {9, 10};\n\nPhysical Curve(\"path\", 16) = {13};","category":"page"},{"location":"Examples/#L-shaped-plate","page":"Examples","title":"L-shaped plate","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Mesh with a path for graphs)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Fillet)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Equivalent stress)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Equivalent stress on path)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"import LowLevelFEM as FEM\nusing LowLevelFEM\n\ngmsh.initialize()\n\n#gmsh.open(\"LshapedPlate.geo\")\ngmsh.open(\"LshapedPlate2.geo\")\n\nmat = FEM.material(\"body\", E=2.e5, ν=0.3)\nproblem = FEM.Problem([mat], type=:PlaneStress, thickness=1)\n\nbc1 = FEM.displacementConstraint(\"fix\", ux=0, uy=0)\nld1 = FEM.load(\"load\", fy=-1)\n\nK = FEM.stiffnessMatrix(problem)\nf = FEM.loadVector(problem, [ld1])\nFEM.applyBoundaryConditions!(problem, K, f, [bc1])\n\nq = FEM.solveDisplacement(K, f)\nS = FEM.solveStress(problem, q)\n\nu = FEM.showDoFResults(problem, q, :uvec, name=\"uvec\", visible=false)\nux = FEM.showDoFResults(problem, q, :ux, name=\"ux\", visible=false)\nuy = FEM.showDoFResults(problem, q, :uy, name=\"uy\", visible=false)\nuz = FEM.showDoFResults(problem, q, :uz, name=\"uz\", visible=false)\ns = FEM.showStressResults(problem, S, :s, name=\"σ red\", visible=false, smooth=false)\nss = FEM.showStressResults(problem, S, :s, name=\"σ red smooth\", visible=true, smooth=true)\nsx = FEM.showStressResults(problem, S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = FEM.showStressResults(problem, S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = FEM.showStressResults(problem, S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = FEM.showStressResults(problem, S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = FEM.showStressResults(problem, S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = FEM.showStressResults(problem, S, :szx, name=\"τzx\", visible=false, smooth=true)\n\nFEM.plotOnPath(problem, \"path\", s, name=\"σred\", visible=false);\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Point(1) = {0, 0, 0, 15.0};\nPoint(2) = {100, 0, 0, 15.0};\nPoint(3) = {100, 50, 0, 15.0};\nPoint(4) = {50, 50, 0, 0.5};\nPoint(5) = {50, 100, 0, 15.0};\nPoint(6) = {0, 100, 0, 15.0};\nLine(1) = {1, 2};\nLine(2) = {2, 3};\nLine(3) = {3, 4};\nLine(4) = {4, 5};\nLine(5) = {5, 6};\nLine(6) = {6, 1};\nCurve Loop(1) = {6, 1, 2, 3, 4, 5};\nPlane Surface(1) = {1};\n\nPhysical Curve(\"fix\", 7) = {5};\nPhysical Curve(\"load\", 8) = {2};\nPhysical Surface(\"body\", 11) = {1};\n\nSetName \"Lshape\";\n\nMesh.ElementOrder = 4;\nMesh.HighOrderOptimize = 1;\nMesh 2;\n\nPoint(7) = {0, 0, 0, 1.0};\nPoint(8) = {50, 50, 0, 1.0};\nLine(7) = {7, 8};\n\nPhysical Curve(\"path\", 9) = {7};","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate2.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"R=1;\n\nPoint(1) = {0, 0, 0, 15.0};\nPoint(2) = {100, 0, 0, 15.0};\nPoint(3) = {100, 50, 0, 15.0};\nPoint(4) = {50+R, 50, 0, R/1.6};\nPoint(5) = {50, 50+R, 0, R/1.6};\nPoint(6) = {50, 100, 0, 15.0};\nPoint(7) = {0, 100, 0, 15.0};\nPoint(8) = {50+R, 50+R, 0, 0.0};\nLine(1) = {1, 2};\nLine(2) = {2, 3};\nLine(3) = {3, 4};\nCircle(4) = {4, 8, 5};\nLine(5) = {5, 6};\nLine(6) = {6, 7};\nLine(7) = {7, 1};\nCurve Loop(1) = {1, 2, 3, 4, 5, 6, 7};\nPlane Surface(1) = {1};\n\nPhysical Curve(\"fix\", 8) = {6};\nPhysical Curve(\"load\", 9) = {2};\nPhysical Surface(\"body\", 11) = {1};\n\nSetName \"Lshape\";\nMesh.ElementOrder = 4;\nMesh.HighOrderOptimize = 1;\nMesh 2;\n\nPoint(9) = {0, 0, 0, 1.0};\nPoint(10) = {50+0.415*R, 50+0.415*R, 0, 1.0};\nLine(8) = {9, 10};\n\nPhysical Curve(\"path\", 10) = {8};","category":"page"},{"location":"Examples/#Wave-propagation-in-a-plate","page":"Examples","title":"Wave propagation in a plate","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"![velocity field](pic/wave.mp4)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"wavePropagation.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"import LowLevelFEM as FEM\nusing LowLevelFEM\n\ngmsh.initialize()\n\nE = 2e5\nν = 0.3\nρ = 7.85e-9\nthick = 1\nheight = 10\nbase = 100\nelemSize = 2 #22\n\napproxOrder = 2\ninternalNodes = true\nquadElements = true\n\ngmsh.model.add(\"rectangle\")\n\np1 = gmsh.model.occ.addPoint(0, 0, 0)\np2 = gmsh.model.occ.addPoint(base, 0, 0)\np3 = gmsh.model.occ.addPoint(base, height, 0)\np4 = gmsh.model.occ.addPoint(0, height, 0)\n\nl1 = gmsh.model.occ.addLine(p1, p2)\nl2 = gmsh.model.occ.addLine(p2, p3)\nl3 = gmsh.model.occ.addLine(p3, p4)\nl4 = gmsh.model.occ.addLine(p4, p1)\n\ncl1 = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])\n\nl5 = gmsh.model.occ.addCircle(base / 2, height / 2, 0, min(base, height) / 4)\ncl2 = gmsh.model.occ.addCurveLoop([l5])\n\nsf1 = gmsh.model.occ.addPlaneSurface([cl1, cl2])\n\ngmsh.model.occ.synchronize()\n\nphg = gmsh.model.addPhysicalGroup(1, [l2])\ngmsh.model.setPhysicalName(1, phg, \"supp\")\nphg = gmsh.model.addPhysicalGroup(1, [l4])\ngmsh.model.setPhysicalName(1, phg, \"load\")\nphg = gmsh.model.addPhysicalGroup(2, [sf1])\ngmsh.model.setPhysicalName(2, phg, \"body\")\n\nFEM.generateMesh(sf1, elemSize, approxOrder=approxOrder, algorithm=6, quadrangle=quadElements, internalNodes=internalNodes)\n\nmat = FEM.material(\"body\", E=E, ν=ν)\nproblem = FEM.Problem([mat], type=:PlaneStress, thickness=thick)\n\nsupp = FEM.displacementConstraint(\"supp\", ux=0, uy=0)\nload = FEM.load(\"load\", fx=1, fy=0)\n\ngmsh.option.setNumber(\"Mesh.Lines\", 0)\n\nK = FEM.stiffnessMatrix(problem)\nf = FEM.loadVector(problem, [load])\nM = FEM.massMatrix(problem)\nC = 4e-3 * K\n\nFEM.applyBoundaryConditions!(problem, K, M, C, f, [supp]);\n\nTₘᵢₙ = FEM.smallestPeriodTime(K, M)\nq = FEM.solveDisplacement(K, f)\n\ndof, dof = size(K)\nu0 = zeros(dof)\nv0 = zeros(dof)\nFEM.initialDisplacement!(problem, \"supp\", u0, ux=0)\nFEM.initialVelocity!(problem, \"body\", v0, vx=1000)\nFEM.initialVelocity!(problem, \"supp\", v0, vx=0)\nf = zeros(dof)\n\nE = problem.material[1][2]\nρ = problem.material[1][4]\nc = √(E / ρ)\nξₘₐₓ = 1e-1\nβ = ξₘₐₓ * Tₘᵢₙ / π\nC = β * K\nu, v, t = FEM.CDM(K, M, C, f, u0, v0, base / c * 2, Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ) * 1.0)\n\nS = FEM.solveStress(problem, q)\n\nuvec = FEM.showDoFResults(problem, q, :uvec, name=\"uvec\", visible=false)\nux = FEM.showDoFResults(problem, q, :ux, name=\"ux\", visible=false)\nuy = FEM.showDoFResults(problem, q, :uy, name=\"uy\", visible=false)\nuz = FEM.showDoFResults(problem, q, :uz, name=\"uz\", visible=false)\ns = FEM.showStressResults(problem, S, :s, name=\"σ\", visible=false, smooth=true)\nsx = FEM.showStressResults(problem, S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = FEM.showStressResults(problem, S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = FEM.showStressResults(problem, S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = FEM.showStressResults(problem, S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = FEM.showStressResults(problem, S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = FEM.showStressResults(problem, S, :szx, name=\"τzx\", visible=false, smooth=true)\nvvec = FEM.showDoFResults(problem, v, t=t, :uvec, name=\"v(t)\", visible=true)\ngmsh.view.option.setNumber(vvec, \"NormalRaise\", 0.03)\n\nsts = ceil(Int64, (base / c * 2) / 6 / (Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ)))\ndisplay(sts)\nSp = FEM.solveStress(problem, u[:, sts])\nsp = FEM.showStressResults(problem, Sp, :s, name=\"σ at t\", visible=false, smooth=false);\n\nSanim = FEM.solveStress(problem, u[:, 1:sts])\nsanim = FEM.showStressResults(problem, Sanim, :s, t=t[1:sts], name=\"σ anim\", visible=false, smooth=false);\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"For more examples see examples on GitHub","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"Functions/#LowLevelFEM.jl","page":"Functions","title":"LowLevelFEM.jl","text":"","category":"section"},{"location":"Functions/","page":"Functions","title":"Functions","text":"Documentation for LowLevelFEM.jl","category":"page"},{"location":"Functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"Functions/#LowLevelFEM.CoordinateSystem","page":"Functions","title":"LowLevelFEM.CoordinateSystem","text":"CoordinateSystem(vec1, vec2)\n\nA structure containing the data of a coordinate system.\n\nvec1: direction of the new x axis.\nvec2: together with vec1 determine the xy plane\n\nIf the problem is two dimensional, it is enough to give the first two elements of vec1. Elements of vec1 and vec2 can be functions. In 3D case the functions have three arguments (x, y, and z coordinates), otherwise (in 2D case) the number of arguments is two (x and y coordinates).\n\nTypes:\n\nvec1: Vector{Float64}\nvec2: Vector{Float64}\n\nExamples\n\n# 2D case\nnx(x, y) = x\nny(x, y) = y\ncs = CoordinateSystem([nx, ny])\nQ = rotateNodes(problem, \"body\", cs)\nq2 = Q' * q1 # where `q1` is in Cartesian, `q2` is in Axisymmetric coordinate system and\n             # `q1` is a nodal displacement vector.\nS2 = Q' * S1 * Q # where `S1` is a stress field in Cartesian coordinate system while\n                 # `S2` is in Axisymmetric coordinate system.\n\n# 3D case\nn1x(x, y, z) = x\nn1y(x, y, z) = y\nn2x(x, y, z) = -y\nn2y = n1x\ncs = CoordinateSystem([n1x, n1y, 0], [n2x, n2y, 0])\nQ = rotateNodes(problem, \"body\", cs)\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.Eigen","page":"Functions","title":"LowLevelFEM.Eigen","text":"Eigen(f, ϕ, model)\n\nA structure containing the eigenfrequencies and eigen modes.\n\nf: eigenfrequencies\nϕ: eigen modes\nmodel: same as Problem\n\nTypes:\n\nf: Matrix{Float64}\nϕ: Vector{Float64}\nmodel: Problem\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.Material","page":"Functions","title":"LowLevelFEM.Material","text":"Material(phName, type, E, ν, ρ, k, c, α, λ, μ, κ)\n\nA structure containing the material type and constants.\n\ntype: constitutive law: :Hooke, :StVenantKirchhoff, :NeoHookeCompressible\nE: elastic modulus,\nν: Poisson's ratio,\nρ: mass density,\nk: heat conductivity,\nc: specific heat,\nα: heat expansion coefficient\nλ: Lamé parameter\nμ: Lamé parameter\nκ: Bulk modulus\n\nphName is the name of the physical group where the given material is used.\n\nTypes:\n\nphName: String\ntype: Symbol\nE: Float64\nν: Float64\nρ: Float64\nk: Float64\nc: Float64\nα: Float64\nλ: Float64\nμ: Float64\nκ: Float64\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.Problem","page":"Functions","title":"LowLevelFEM.Problem","text":"Problem(materials; thickness=..., type=..., bandwidth=...)\n\nA structure containing the most important data of the problem. \n\nParts of the model with their material constants. More materials can be given. (see material function)\ntype of the problem: :Solid, :PlaneStrain, :PlaneStress, :AxiSymmetric, :HeatConduction, :PlaneHeatConduction, :AxiSymmetricHeatConduction. In the case of :AxiSymmetric, the axis of symmetry is the y axis,  while the geometry must be drawn in the positive x half-plane.\nbandwidth optimization using built-in gmsh function. Possibilities: :RCMK, :Hilbert, :Metis or :none (default)\ndimension of the problem, determined from type\nmaterial constants (in a vector of material structure materials). See Material struct\nthickness of the plate\nnumber of nodes (non)\ndimension of the geometry\ndimension of the problem (eg. a 3D heat conduction problem is a 1D problem)\n\nTypes:\n\nmaterials: Material\ntype: Symbol\nbandwidth: Symbol\ndim: Integer\nthickness: Float64\nnon: Integer\ndim: Integer\npdim: Integer\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.ScalarField","page":"Functions","title":"LowLevelFEM.ScalarField","text":"ScalarField(A, a, t, numElem, nsteps, type, model)\nScalarField(problem, dataField)\n\nA structure containing all data of a scalar field (eg. Temperature field). \n\nA: vector of ElementNodeData type scalar data (see gmsh.jl)\na: matrix of nodal data of scalar field\nnumElem: vector of tags of elements\nnsteps: number of stress fields stored in A (for animations).\ntype: type of data (eg. temperature :T)\nmodel: the same as Problem\n\nTypes:\n\nA: Vector{Vector{Float64}}\na: Matrix{Float64}\nt: Vector{Float64}\nnumElem: Vector{Integer}\nnsteps: Integer\ntype: Symbol\nmodel: Problem\n\nExample\n\ns(x,y,z) = 2x + 3y\nfs = field(\"body\", f=s)\nS = ScalarField(problem, [fs])\n\nHere S is defined element-wise.\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.SystemMatrix","page":"Functions","title":"LowLevelFEM.SystemMatrix","text":"SystemMatrix(A::SparseMatrixCSC{Float64}, model::Problem)\n\nStructure which contains the stiffness/mass/heatconduction/heatcapacity/latentheat/... matrix and given Problem.\n\nTypes:\n\nA: SparseMatrixCSC{Float64}\nmodel: Problem\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.TensorField","page":"Functions","title":"LowLevelFEM.TensorField","text":"TensorField(A, a, t, numElem, nsteps, type, model)\n\nA structure containing the data of a tensor field (eg. stress field). \n\nA: vector of ElementNodeData type heat flux data (see gmsh.jl)\na: matrix of nodal data of scalar field\nnumElem: vector of tags of elements\nnsteps: number of stress fields stored in A (for animations).\ntype: type of data (eg. stress :s)\nmodel: the same as Problem\n\nTypes:\n\nA: Vector{Matrix{Float64}}\na: Matrix{Float64}\nt: Vector{Float64}\nnumElem: Vector{Integer}\nnsteps: Integer\ntype: Symbol\nmodel: Problem\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.Transformation","page":"Functions","title":"LowLevelFEM.Transformation","text":"Transformation(T::SparseMatrixCSC{Float64}, non::Int64, dim::Int64)\n\nStructure which contains the transformation matrix T of each nodes in the FE mesh,  the number of nodes non and the dimension of the problem dim.\n\nTypes:\n\nT: SparseMatrixCSC{Float64}\nnon: Int64\ndim: Int64\n\n\n\n\n\n","category":"type"},{"location":"Functions/#LowLevelFEM.VectorField","page":"Functions","title":"LowLevelFEM.VectorField","text":"VectorField(A, a, t, numElem, nsteps, type, model)\n\nA structure containing the data of a vector field (eg. displacement field). \n\nA: vector of ElementNodeData type heat flux data (see gmsh.jl)\na: matrix of nodal data of scalar field\nnumElem: vector of tags of elements\nnsteps: number of stress fields stored in A (for animations).\ntype: type of data (eg. heat flux :q)\nmodel: the same as Problem\n\nTypes:\n\nA: Vector{Matrix{Float64}}\na: Matrix{Float64}\nt: Vector{Float64}\nnumElem: Vector{Integer}\nnsteps: Integer\ntype: Symbol\nmodel: Problem\n\n\n\n\n\n","category":"type"},{"location":"Functions/#Base.:*-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}","page":"Functions","title":"Base.:*","text":"*(A::ScalarField, B::ScalarField)\n\nPerforms element-wise multiplication of two ScalarField objects on the same finite elements.\n\nReturn: ScalarField\n\nExamples\n\nC = A * B\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.:*-Tuple{LowLevelFEM.ScalarField, Number}","page":"Functions","title":"Base.:*","text":"*(A::ScalarField, b::Number)\n\nPerforms multiplication of a ScalarField objects and a Number.\n\nReturn: ScalarField\n\nExamples\n\nC = A * 2.0\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.:*-Tuple{Number, LowLevelFEM.ScalarField}","page":"Functions","title":"Base.:*","text":"*(b::Number, A::ScalarField)\n\nPerforms multiplication of a ScalarField objects and a Number.\n\nReturn: ScalarField\n\nExamples\n\nC = 2.0 * A\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.:+-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}","page":"Functions","title":"Base.:+","text":"+(A::ScalarField, B::ScalarField)\n\nPerforms element-wise addition of two ScalarField objects on the same finite elements.\n\nReturn: ScalarField\n\nExamples\n\nC = A + B\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.:--Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}","page":"Functions","title":"Base.:-","text":"-(A::ScalarField, B::ScalarField)\n\nPerforms element-wise substruction of two ScalarField objects on the same finite elements.\n\nReturn: ScalarField\n\nExamples\n\nC = A - B\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.:/-Tuple{LowLevelFEM.ScalarField, LowLevelFEM.ScalarField}","page":"Functions","title":"Base.:/","text":"/(A::ScalarField, B::ScalarField)\n\nPerforms element-wise division of two ScalarField objects on the same finite elements.\n\nReturn: ScalarField\n\nExamples\n\nC = A / B\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.copy-Tuple{LowLevelFEM.SystemMatrix}","page":"Functions","title":"Base.copy","text":"Base.copy(A::SystemMatrix)\n\nInternal function to copy the hole content of a SystemMatrix.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.div-Tuple{Union{LowLevelFEM.TensorField, LowLevelFEM.VectorField}}","page":"Functions","title":"Base.div","text":"div(r::Union{VectorField,TensorField})\n\nSolves the divergence of the vector field or tensor field r. An alternative way to solve div is to use ∇ as a differencial operator.\n\nReturn: ScalarField or VectorField\n\nTypes:\n\nr: VectorField or TensorField\n\nExamples\n\nx(X, Y, Z) = 2X + 3Y\ny(X, Y, Z) = Y\nz(X, Y, Z) = Z\nfld = field(\"body\", fx=x, fy=y, fz=z)\nv = vectorField(problem, [fld])\nD1 = div(v)\nD2 = ∇ ⋅ v\nprintln(D1 == D2)\n\nfsz(X, Y, Z) = 10 - Z\ns0 = field(\"body\", fz=fsz)\nS = tensorField(problem, [s0])\nb1 = -div(S)\nb2 = -S ⋅ ∇\nprintln(b1 == b2)\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}","page":"Functions","title":"Base.show","text":"Base.show(io::IO, M::SystemMatrix)\n\nInternal function to display SystemMatrix as a SparseMatrixCSC{Float64}.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.CDM-NTuple{8, Any}","page":"Functions","title":"LowLevelFEM.CDM","text":"CDM(K, M, C, f, u0, v0, T, Δt)\n\nSolves a transient dynamic problem using central difference method (CDM) (explicit). K is the stiffness Matrix, M is the mass matrix, C is the damping matrix, f is the load vector, u0 is the initial displacement, v0 is the initial velocity, T is the upper bound of the time intervall (lower bound is zero) and Δt is the time step size. Returns the displacement vectors and velocity vectors in each time step arranged in the columns of the two matrices u and v and a vector t of the time instants used.\n\nThe critical (largest allowed) time step is Δtₘₐₓ = Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ) where Tₘᵢₙ is the time period of the largest eigenfrequency and ξₘₐₓ is the largest modal damping.\n\nReturn: u, v\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nC: SystemMatrix\nf: VectorField\nu0: VectorField\nv0: VectorField\nT: Float64\nΔt: Float64 \nu: VectorField\nv: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}","page":"Functions","title":"LowLevelFEM.CDMaccuracyAnalysis","text":"CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)\n\nGives some functions (graphs) for accuracy analysis of the CDM method.  ωₘᵢₙ and ωₘₐₓ are the square root of smallest and largest eigenvalues of the Kϕ=ω²Mϕ eigenvalue problem, Δt is the time step size. type is one of the following values:\n\n:SR: spectral radius\n:PDR: physical damping ratio\n:ADR: algorithmic damping ratio\n:PE: period error\n\nFor details see [3].  n is the number of points in the graph. The damping matrix is assembled in the  following ways: C=αM+βK or C=αM+β₁K+β₂KM⁻¹K+β₃KM⁻¹KM⁻¹K+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (ξ in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (β in the argument list) are the  coefficients of the series. (see [4]) Either ξ or β must be specified. ξ or β are scalars or  vectors. If show_β or show_ξ is true, the corresponding β or ξ values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with plot(xy))\n\n[4]: Serfőző, D., Pere, B.: An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems, Meccanica, https://doi.org/10.1007/s11012-025-02036-9\n\nReturn: xy\n\nTypes:\n\nωₘᵢₙ: Float64\nωₘₐₓ: Float64\nΔt: Float64 \nn: Int64\nα: Float64\nβ: Float64 of Vector{Float64}\nξ: Float64 of Vector{Float64}\nshow_β: Boolean\nshow_ξ: Boolean\nxy: Tuple{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.FDM-NTuple{6, Any}","page":"Functions","title":"LowLevelFEM.FDM","text":"FDM(K, C, q, T0, tₘₐₓ, Δt; ϑ=...)\n\nSolves a transient heat conduction problem using Finite Difference Method (FDM). Introducing a ϑ parameter, special cases can be used as the Forward Euler (explicit, ϑ=0), Backward Euler (implicit, ϑ=1), Crank-Nicolson (ϑ=0.5) and intermediate cases (0<ϑ<1). (This method is known as ϑ-method. See [5].) K is the heat conduction matrix, C is the heat capacity matrix, q is the heat flux vector, T0 is the initial temperature, tₘₐₓ is the upper  bound of the time intervall (lower bound is zero) and Δt is the time step size. Returns the nodal temperature vectors in each time  step arranged in the columns of the matrix T and a vector t of the time instants used.\n\nThe critical (largest allowed) time step is Δtₘₐₓ = 2 / ((1-2ϑ)*λₘₐₓ) where λₘₐₓ is the largest eigenvalue of (K+λC)θ=0  eigenvalue problem and ϑ is the parameter of the ϑ-method. Default value of ϑ is 1/2.\n\n[5]: Bathe, K. J.: Finite element procedures, Wiley, 1983, https://doi.org/10.1002/nag.1610070412\n\nReturn: T\n\nTypes:\n\nK: SystemMatrix\nC: SystemMatrix\nq: ScalarField\nT0: ScalarField\ntₘₐₓ: Float64\nΔt: Float64 \nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.HHT-NTuple{7, Any}","page":"Functions","title":"LowLevelFEM.HHT","text":"HHT(K, M, f, u0, v0, T, Δt; α=..., δ=..., γ=..., β=...)\n\nSolves a transient dynamic problem using HHT-α method[1] (implicit). K is the stiffness Matrix, M is the mass matrix, f is the load vector,  u0 is the initial displacement, v0 is the initial velocity, T is the  upper bound of the time intervall (lower bound is zero) and Δt is the time  step size. Returns the displacement vectors and velocity vectors in each time  step arranged in the columns of the two matrices u and v and a vector t  of the time instants used. For the meaning of α, β and γ see [1]. If δ is given, γ=0.5+δ and β=0.25⋅(0.5+γ)².\n\n[1]: Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. Improved  numerical dissipation for time integration algorithms in structural  dynamics. Earthquake Engineering & Structural Dynamics 5.3 (1977): 283-292.\n\nReturn: u, v\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nf: VectorField\nu0: VectorField\nv0: VectorField\nT: Float64\nΔt: Float64 \nα: Float64\nβ: Float64\nγ: Float64\nδ: Float64\nu: VectorField\nv: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}","page":"Functions","title":"LowLevelFEM.HHTaccuracyAnalysis","text":"HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)\n\nGives some functions (graphs) for accuracy analysis of the HHT-α method[1].  ωₘᵢₙ and ωₘₐₓ are the square root of smallest and largest eigenvalues of the Kϕ=ω²Mϕ eigenvalue problem, Δt is the time step size. type is one of the following values:\n\n:SR: spectral radius\n:ADR: algorithmic damping ratio\n:PE: period error\n\nFor details see [2] and [3].  n is the number of points in the graph. For the meaning of α, β and γ see [1]. If δ is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with plot(xy))\n\n[2]: Belytschko, Ted, and Thomas JR, Hughes: Computational methods for  transient analysis, North-Holland, (1983).\n\n[3]: Serfőző, D., Pere, B.: A method to accurately define arbitrary algorithmic damping character as viscous damping. Arch Appl Mech 93, 3581–3595 (2023). https://doi.org/10.1007/s00419-023-02454-9\n\nReturn: xy\n\nTypes:\n\nωₘᵢₙ: Float64\nωₘₐₓ: Float64\nΔt: Float64 \nn: Int64\nα: Float64\nβ: Float64\nγ: Float64\nδ: Float64\nxy: Tuple{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}","page":"Functions","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(stiffMat, loadVec, supports)\n\nApplies displacement boundary conditions supports on a stiffness matrix stiffMat and load vector loadVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: none\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}","page":"Functions","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(heatCondMat, heatCapMat, heatFluxVec, supports)\n\nApplies boundary conditions supports on a heat conduction matrix heatCondMat, heat capacity matrix heatCapMat and heat flux vector heatFluxVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed temperature T.\n\nReturn: none\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}","page":"Functions","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(stiffMat, massMat, dampMat, loadVec, supports)\n\nApplies displacement boundary conditions supports on a stiffness matrix stiffMat, mass matrix massMat, damping matrix dampMat and load vector loadVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: none\n\nTypes:\n\nstiffMat: SystemMatrix \nmassMat: SystemMatrix \ndampMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyBoundaryConditions!-Tuple{Matrix, Any}","page":"Functions","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(dispVec, supports)\n\nApplies displacement boundary conditions supports on a displacement vector dispVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: none\n\nTypes:\n\nproblem: Problem\ndispVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.applyBoundaryConditions","text":"applyBoundaryConditions(stiffMat, loadVec, supports)\n\nApplies displacement boundary conditions supports on a stiffness matrix stiffMat and load vector loadVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz. Creates a new stiffness matrix and load vector.\n\nReturn: stiffMat, loadVec\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.applyDeformationBoundaryConditions!","text":"applyDeformationBoundaryConditions!(deformVec, supports)\n\nApplies displacement boundary conditions supports on deformation vector deformVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: none\n\nTypes:\n\ndeformVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}","page":"Functions","title":"LowLevelFEM.applyElasticSupport!","text":"applyElasticSupport!(stiffMat, elastSupp)\n\nApplies elastic support boundary conditions elastSupp on a stiffness matrix stiffMat. Mesh details are in problem. elastSupp is a tuple of name of physical group and prescribed kx, ky and kz stiffnesses.\n\nReturn: none\n\nTypes:\n\nstiffMat: SystemMatrix \nelastSupp: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.applyHeatConvection!-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.applyHeatConvection!","text":"applyHeatConvection!(heatCondMat, heatFluxVec, heatConv)\n\nApplies heat convectiom boundary conditions heatConv on a heat conduction matrix heatCondMat and heat flux vector heatFluxVec. Mesh details are in problem. heatConv is a tuple of name of physical group and prescribed heat transfer coefficient h and ambient temperature Tₐ. The ambient temperature can be either a constant or a  function of x, y and z coordinates.\n\nReturn: none\n\nTypes:\n\nproblem: Problem\nheatCondMat: SystemMatrix \nheatFluxVec: VectorField\nheatConv: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.constrainedDoFs","text":"constrainedDoFs(problem, supports)\n\nReturns the serial numbers of constrained degrees of freedom. Support is a vector of boundary conditions given with the function displacementConstraint.\n\nReturn: DoFs\n\nTypes:\n\nproblem: Problem\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\nDoFs: Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.curl-Tuple{LowLevelFEM.VectorField}","page":"Functions","title":"LowLevelFEM.curl","text":"curl(r::VectorField)\n\nSolves the rotation of the vector field r. An alternative way to solve curl is to use ∇ as a differencial operator.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\nExamples\n\nx(X, Y, Z) = 2X + 3Y\ny(X, Y, Z) = Y\nz(X, Y, Z) = Z\nfld = field(\"body\", fx=x, fy=y, fz=z)\nv = vectorField(problem, [fld])\nD1 = curl(v)\nD2 = ∇ × v\nprintln(D1 == D2)\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.dampingMatrix","text":"dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)\n\nGenerates the damping matrix for proportional damping case. C=αM+βK or C=αM+β₁K+β₂KM⁻¹K+β₃KM⁻¹KM⁻¹K+⋅⋅⋅. The latter corresponds  to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (ξ in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (β in the argument list) are the  coefficients of the series. (see [4]) Either ξ or β must be specified. ξ or β are scalars or  vectors. K is the stiffness matrix, M is the mass matrix and ωₘₐₓ is the  largest natural frequency.\n\nReturn: dampingMatrix\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nωₘₐₓ: Float64\nα: Float64\nξ: Float64 of Vector{Float64}\nβ: Float64 of Vector{Float64}\ndampingMatrix: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.displacementConstraint-Tuple{Any}","page":"Functions","title":"LowLevelFEM.displacementConstraint","text":"displacementConstraint(name; ux=..., uy=..., uz=...)\n\nGives the displacement constraints on name physical group. At least one ux,  uy or uz value have to be given (depending on the dimension of the problem). ux, uy or uz can be a constant value, or a function of x, y and z. (E.g. fn(x,y,z)=5*(5-x)); displacementConstraint(\"support1\", ux=fn))\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nux: Float64 or Function\nuy: Float64 or Function\nuz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.elasticSupport-Tuple{Any}","page":"Functions","title":"LowLevelFEM.elasticSupport","text":"elasticSupport(name; kx=..., ky=..., kz=...)\n\nGives the distributed stiffness of the elastic support on name physical group. kx, ky or kz can be a constant value, or a function of x, y and z. (E.g. fn(x,y,z)=5*(5-x)); elasticSupport(\"supp1\", kx=fn)) Default values are 1.\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nkx: Float64 or Function\nky: Float64 or Function\nkz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.elasticSupportMatrix","text":"elasticSupportMatrix(problem, elSupp)\n\nSolves the elastic support matrix of the problem. elSupp is a vector of elastic supports defined in function elasticSupport. With the displacementent vector q in hand the reaction force vector fR arising from the elastic support can be solved. (fR = heatConvMat * q)\n\nReturn: elSuppMat\n\nTypes:\n\nproblem: Problem\nelSupp: Vector{Tuple{String, Float64, Float64, Float64}}\nelSuppMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.elementsToNodes-Tuple{Any}","page":"Functions","title":"LowLevelFEM.elementsToNodes","text":"elementsToNodes(T)\n\nSolves the nodal results F from the elemental results T. T can be ScalarField, VectorField or TensorField.\n\nReturn: F\n\nTypes:\n\nT: ScalarField, VectorField or TensorField\nF: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.equivalentNodalForce-Tuple{LowLevelFEM.VectorField}","page":"Functions","title":"LowLevelFEM.equivalentNodalForce","text":"equivalentNodalForce(r::VectorField)\n\nSolves the equivalent nodal force (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.field-Tuple{Any}","page":"Functions","title":"LowLevelFEM.field","text":"field(name; f=..., fx=..., fy=..., fz=..., fxy=..., fyz=..., fzx=...)\n\nGives the value of scalar, vector or tensor field on name physical group. At least one fx,  fy or fz etc. value have to be given (depending on the dimension of the problem). fx,  fy or fz etc. can be a constant value, or a function of x, y and z. (E.g. fn(x,y,z)=5*(5-x)); field(\"surf1\", fx=fn))\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function,...x7}\n\nTypes:\n\nname: String\nf: Float64 or Function\nfx: Float64 or Function\nfy: Float64 or Function\nfz: Float64 or Function\nfxy: Float64 or Function\nfyz: Float64 or Function\nfzx: Float64 or Function\n\nExamples\n\nf1(x, y, z) = y\nf2 = field(\"face1\", f=f1)\nqq = scalarField(problem, [f2])\nqqq = showDoFResults(problem, qq, :scalar)\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.fieldError-Tuple{Any}","page":"Functions","title":"LowLevelFEM.fieldError","text":"fieldError(F)\n\nSolves the deviation of field results F (stresses, strains, heat flux components) at nodes, where the field has jumps. The result can be displayed with the showDoFResults function.\n\nReturn: e\n\nTypes:\n\nF: VectorField or TensorField\ne: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.freeDoFs-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.freeDoFs","text":"freeDoFs(problem, supports)\n\nReturns the serial numbers of unconstrained degrees of freedom. Support is a vector of boundary conditions given with the function displacementConstraint.\n\nReturn: DoFs\n\nTypes:\n\nproblem: Problem\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\nDoFs: Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.getEigenValues-Tuple{LowLevelFEM.VectorField}","page":"Functions","title":"LowLevelFEM.getEigenValues","text":"getEigenValues(A::VectorField)\n\nA function to extract the elements of a vector field to separate scalar fields.\n\nReturn: λ1, λ2, λ3\n\nTypes:\n\nA: VectorField\nλ1: ScalarField\nλ2: ScalarField\nλ3: ScalarField\n\nExamples:\n\nusing LinearAlgebra\nλ, Q = eigen(S)\nλ1, λ2, λ2 = getEigenVectors(λ)\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.getEigenVectors-Tuple{LowLevelFEM.TensorField}","page":"Functions","title":"LowLevelFEM.getEigenVectors","text":"getEigenVectors(A::TensorField)\n\nA function to extract the columns of a tensor field to separate vector fields.\n\nReturn: N1, N2, N3\n\nTypes:\n\nA: TensorField\nN1: VectorField\nN2: VectorField\nN3: VectorField\n\nExamples:\n\nusing LinearAlgebra\nλ, Q = eigen(S)\nN1, N2, N2 = getEigenVectors(Q)\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.getTagForPhysicalName-Tuple{Any}","page":"Functions","title":"LowLevelFEM.getTagForPhysicalName","text":"getTagForPhysicalName(name)\n\nReturns tags of elements of physical group name.\n\nReturn: tags\n\nTypes:\n\nname: String\ntags: Vector{Integer}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.grad-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.VectorField}}","page":"Functions","title":"LowLevelFEM.grad","text":"grad(r::Union{ScalarField,VectorField})\n\nSolves the gradient of the scalar field or vector field r. An alternative way to solve grad is to use ∇ as a differencial operator.\n\nReturn: VectorField or TensorField\n\nTypes:\n\nr: ScalarField or VectorField\n\nExamples\n\nx(X, Y, Z) = 2X + 3Y\ny(X, Y, Z) = Y\nz(X, Y, Z) = Z\nfld = field(\"body\", fx=x, fy=y, fz=z)\nv = vectorField(problem, [fld])\nD1 = grad(v)\nD2 = v ∘ ∇\nprintln(D1 == D2)\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatCapacityMatrix-Tuple{Any}","page":"Functions","title":"LowLevelFEM.heatCapacityMatrix","text":"heatCapacityMatrix(problem; lumped=...)\n\nSolves the heat capacity matrix of the problem. If lumped is true, solves lumped heat capacity matrix.\n\nReturn: heatCapMat\n\nTypes:\n\nproblem: Problem\nlumped: Boolean\nmassMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatConductionMatrix-Tuple{Any}","page":"Functions","title":"LowLevelFEM.heatConductionMatrix","text":"heatConductionMatrix(problem)\n\nSolves the heat conduction matrix of the problem.\n\nReturn: heatCondMat\n\nTypes:\n\nproblem: Problem\nheatCondMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatConvection-Tuple{Any}","page":"Functions","title":"LowLevelFEM.heatConvection","text":"heatConvection(name; h=..., Tₐ=...)\n\nGives the heat convection of the surface given with name physical group. h is the heat transfer coefficient of the surrounding media, Tₐ is the ambient temperature. The ambient temperature can be either a constant or a function of x, y and z.\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nh: Float64\nTₐ: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.heatConvectionMatrix","text":"heatConvectionMatrix(problem, heatConvection)\n\nSolves the heat convection matrix of the problem. heatConvection  is a vector of heat convection boundary condicions defined in function heatConduction. With the heat convection vector (see the heatConvectionVector function) heatConvVec, temperature field vector T in hand the heat flux vector qCV arising from the heat convection boundary condition can be solved. qCV = heatConvMat * T - heatConvVec\n\nReturn: heatConvMat\n\nTypes:\n\nproblem: Problem\nheatConvection: Vector{Tuple{String, Float64, Float64, Float64}}\nheatConvMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatConvectionVector-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.heatConvectionVector","text":"heatConvectionVector(problem, heatConvection)\n\nSolves a heat convection vector of problem. heatConvection  is a vector of heat convection boundary condicions defined in function heatConduction. With the heat convection matrix (see the heatConvectionMatrix function) heatConvMat, temperature field vector T in hand the heat flux vector qCV arising from the heat convection boundary condition can be solved. qCV = heatConvMat * T - heatConvVec\n\nReturn: heatConvVec\n\nTypes:\n\nproblem: Problem\nheatConvection: Vector{Tuple{String, Float64, Float64, Float64}}\nheatConvVec: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatFlux-Tuple{Any}","page":"Functions","title":"LowLevelFEM.heatFlux","text":"heatFlux(name; qn=...)\n\nGives the heat flux normal to the surface of name physical group. qn can be a constant value, or a function of x, y and z. (E.g. fn(x,y,z)=5*(5-x)); load(\"flux1\", qn=fn))\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nqn: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatFluxVector-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.heatFluxVector","text":"heatFluxVector(problem, heatFlux)\n\nSolves a heat flux or heat source vector of problem. heatFlux is a tuple of name of physical group  name, heat flux qn normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated heat flux.\nIn case of 2D problems and Line physical group means surface heat flux.\nIn case of 2D problems and Surface physical group means body heat source.\nIn case of 3D problems and Point physical group means concentrated heat flux.\nIn case of 3D problems and Line physical group means edge heat source.\nIn case of 3D problems and Surface physical group means surface heat flux.\nIn case of 3D problems and Volume physical group means body heat source.\n\nReturn: heatFluxVec\n\nTypes:\n\nproblem: Problem\nheatFlux: Vector{Tuple{String, Float64, Float64, Float64}}\nheatFluxVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatSource-Tuple{Any}","page":"Functions","title":"LowLevelFEM.heatSource","text":"heatSource(name; h=...)\n\nGives the body heat source in name physical group. h can be a constant value, or a function of x, y and z. (E.g. fn(x,y,z)=5*(5-x)); load(\"source1\", h=fn))\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nh: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.heatSourceVector-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.heatSourceVector","text":"heatSourceVector(problem, heatSource)\n\nSolves a heat flux or heat source vector of problem. heatSource is a tuple of name of physical group  name, heat flux qn normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated heat flux.\nIn case of 2D problems and Line physical group means surface heat flux.\nIn case of 2D problems and Surface physical group means body heat source.\nIn case of 3D problems and Point physical group means concentrated heat flux.\nIn case of 3D problems and Line physical group means edge heat source.\nIn case of 3D problems and Surface physical group means surface heat flux.\nIn case of 3D problems and Volume physical group means body heat source.\n\nSame as the heatFluxVector function.\n\nReturn: heatSourceVec\n\nTypes:\n\nproblem: Problem\nheatSource: Vector{Tuple{String, Float64, Float64, Float64}}\nheatSourceVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.initialDisplacement!","text":"initialDisplacement!(name, u0; ux=..., uy=..., uz=...)\n\nChanges the displacement values to ux, uy and uz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in displacement vector u0.\n\nReturn: u0\n\nTypes:\n\nname: String \nux: Float64 \nuy: Float64 \nuz: Float64 \nu0: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.initialDisplacement-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.initialDisplacement","text":"initialDisplacement(problem, name; ux=..., uy=..., uz=...)\n\nSets the displacement values ux, uy and uz (depending on the dimension of the problem) at nodes belonging to physical group name. Returns the initial displacement vector u0.\n\nReturn: u0\n\nTypes:\n\nproblem: Problem\nname: String \nu0: VectorField\nux: Float64 \nuy: Float64 \nuz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.initialTemperature!-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.initialTemperature!","text":"initialTemperature!(name, T0; T=...)\n\nChanges the tempetature value to T at nodes belonging to physical group name. Original values are in temperature vector T0.\n\nReturn: none\n\nTypes:\n\nname: String \nT0: ScalarField\nT: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.initialTemperature-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.initialTemperature","text":"initialTemperature(problem, name; T=...)\n\nSets the temperature value T at nodes belonging to physical group name. Returns the T0 initial nodal temperature vector.\n\nReturn: T0\n\nTypes:\n\nproblem: Problem\nname: String \nT: Float64 \nT0: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.initialVelocity!-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.initialVelocity!","text":"initialVelocity!(name, v0; vx=..., vy=..., vz=...)\n\nChanges the velocity values vx, vy and vz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in velocity vector v0.\n\nReturn: none\n\nTypes:\n\nname: String \nv0: VectorField\nvx: Float64 \nvy: Float64 \nvz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.initialVelocity-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.initialVelocity","text":"initialVelocity(problem, name; vx=..., vy=..., vz=...)\n\nSets the velocity values vx, vy and vz (depending on the dimension of the problem) at nodes belonging to physical group name. Returns the initial velocity vector v0.\n\nReturn: v0\n\nTypes:\n\nproblem: Problem\nname: String \nvx: Float64 \nvy: Float64 \nvz: Float64 \nv0: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.isSaved-Tuple{String}","page":"Functions","title":"LowLevelFEM.isSaved","text":"isSaved(fileName::String)\n\nChecks whether a variable has been saved or not.\n\nReturn: Boolean\n\nTypes:\n\nfileName: String\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.largestEigenValue-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.largestEigenValue","text":"largestEigenValue(K, M)\n\nSolves the smallest eigenvalue for a transient problem given by stiffness (heat conduction) matrix K and the mass (heat capacity) matrix M (C).\n\nReturn: λₘᵢₙ\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nλₘᵢₙ: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.largestPeriodTime","text":"largestPeriodTime(K, M)\n\nSolves the largest period of time for a dynamic problem given by stiffness matrix K and the mass matrix M.\n\nReturn: Δt\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nΔt: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.latentHeatMatrix","text":"latentHeatMatrix(problem, u, v, T0)\n\nSolves the latent heat matrix of the problem. With this matrix the generated heat due to deformations (given with displacement field u and velocity field v) can be solved. T0 is the current temperature field which is given in absolute temperature scale (Kelvin).\n\nReturn: latHeatMat\n\nTypes:\n\nproblem: Problem\nu: VectorField\nv: VectorField\nT0: ScalarField\nlatHeatMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.load-Tuple{Any}","page":"Functions","title":"LowLevelFEM.load","text":"load(name; fx=..., fy=..., fz=...)\n\nGives the intensity of distributed load on name physical group. At least one fx,  fy or fz value have to be given (depending on the dimension of the problem). fx,  fy or fz can be a constant value, or a function of x, y and z. (E.g. fn(x,y,z)=5*(5-x)); load(\"load1\", fx=fn))\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nfx: Float64 or Function\nfy: Float64 or Function\nfz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.loadField-Tuple{String}","page":"Functions","title":"LowLevelFEM.loadField","text":"loadField(fileName::String)\n\nLoads a ScalarField, VectorField, or TensorField from a file named fileName (without \"-LLF-Data.jld2\"). \n\nReturn: variabla\n\nTypes:\n\nfileName: String\nvariable: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.loadVector-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.loadVector","text":"loadVector(problem, loads)\n\nSolves a load vector of problem. loads is a tuple of name of physical group  name, coordinates fx, fy and fz of the intensity of distributed force. It can solve traction or body force depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated force.\nIn case of 2D problems and Line physical group means surface force.\nIn case of 2D problems and Surface physical group means body force.\nIn case of 3D problems and Point physical group means concentrated force.\nIn case of 3D problems and Line physical group means edge force.\nIn case of 3D problems and Surface physical group means surface force.\nIn case of 3D problems and Volume physical group means body force.\n\nReturn: loadVec\n\nTypes:\n\nproblem: Problem\nloads: Vector{Tuple{String, Float64, Float64, Float64}}\nloadVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.massMatrix-Tuple{Any}","page":"Functions","title":"LowLevelFEM.massMatrix","text":"massMatrix(problem; lumped=...)\n\nSolves the mass matrix of the problem. If lumped is true, solves lumped mass matrix.\n\nReturn: massMat\n\nTypes:\n\nproblem: Problem\nlumped: Boolean\nmassMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.material-Tuple{Any}","page":"Functions","title":"LowLevelFEM.material","text":"material(name; type=:Hooke, E=2.0e5, ν=0.3, ρ=7.85e-9, k=45, c=4.2e8, α=1.2e-5, λ=νE/(1+ν)/(1-2ν), μ=E/(1+ν)/2, κ=E/(1-2ν)/3)\n\nReturns a structure in which name is the name of a physical group, type is the name of the constitutive law (eg. :Hooke), E is the modulus of elasticity, ν Poisson's ratio and ρ is the mass density, k is the heat conductivity, c is the specific heat, α is the coefficient of heat expansion, λ and μ are the  Lamé parameters, κ is the Bulk modulus.\n\nReturn: mat\n\nTypes:\n\nmat: Material\nname: String\ntype: Symbol\nE: Float64\nν: Float64\nρ: Float64\nk: Float64\nc: Float64\nα: Float64\nλ: Float64\nμ: Float64\nκ: Float64\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.nodalAcceleration!-Tuple{Any}","page":"Functions","title":"LowLevelFEM.nodalAcceleration!","text":"nodalAcceleration!(name, a0; ax=..., ay=..., az=...)\n\nChanges the acceleration values ax, ay and az (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in acceleration vector a0.\n\nReturn: none\n\nTypes:\n\nname: String \na0: VectorField\nax: Float64\nay: Float64\naz: Float64\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.nodalForce!-Tuple{Any}","page":"Functions","title":"LowLevelFEM.nodalForce!","text":"nodalForce!(name, f0; fx=..., fy=..., fz=...)\n\nChanges the force values fx, fy and fz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in load vector f0.\n\nReturn: none\n\nTypes:\n\nname: String \nf0: VectorField\nfx: Float64 \nfy: Float64 \nfz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.nodePositionVector-Tuple{Any}","page":"Functions","title":"LowLevelFEM.nodePositionVector","text":"nodePositionVector(problem)\n\nGives back the positiond vectors of all the nodes of the mesh as a VectorField. (Initial configuration)\n\nReturn: R\n\nTypes:\n\nproblem: Problem\nR: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.nodesToElements-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}","page":"Functions","title":"LowLevelFEM.nodesToElements","text":"nodesToElements(T)\n\nSolves the element results F from the nodal results T. T can be ScalarField, VectorField or TensorField.\n\nReturn: F\n\nTypes:\n\nT: ScalarField, VectorField or TensorField\nF: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.nonFollowerLoadVector-Tuple{LowLevelFEM.VectorField, Any}","page":"Functions","title":"LowLevelFEM.nonFollowerLoadVector","text":"nonFollowerLoadVector(r::VectorField, load)\n\nSolves the non-follower load vector (when solving large deformation problems). r is the position vector field in the current configuration.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}","page":"Functions","title":"LowLevelFEM.nonLinearStiffnessMatrix","text":"nonLinearStiffnessMatrix(problem, q)\n\nSolves the nonlinear stiffness matrix of the problem. q is a displacement field.\n\nReturn: stiffMat\n\nTypes:\n\nproblem: Problem\nq: VectorField\nstiffMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.openPostProcessor-Tuple{}","page":"Functions","title":"LowLevelFEM.openPostProcessor","text":"openPostProcessor(; model=...)\n\nLaunches the GMSH postprocessor window with open postprocessor tree (of model).\n\nReturn: none\n\nTypes:\n\nmodel: Int64\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.openPreProcessor-Tuple{}","page":"Functions","title":"LowLevelFEM.openPreProcessor","text":"openPreProcessor(; openGL=...)\n\nLaunches the GMSH preprocessor window with openGL disabled by default.\n\nReturn: none\n\nTypes:\n\nopenGL: Boolean\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.plotOnPath-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.plotOnPath","text":"plotOnPath(problem, pathName, field; points=100, step=..., plot=..., name=..., visible=..., offsetX=..., offsetY=..., offsetZ=...)\n\nLoad a 2D plot on a path into a View in gmsh. field is the number of View in gmsh from which the data of a field is imported. pathName is the name of a physical group which contains a curve. The curve is devided into equal length intervals with number of points points. The field is shown at this points. step is the sequence number of displayed step. If no step is given, shows all  the aviable steps as an animation. If plot is true, additional return parameter, a tuple of vectors is given back, in which x is a vector of values in horizontal axis, y is a vector of values in vertical axis of a plot (see Plots package). name is the title of graph and visible is a true or false value to toggle on or off the initial visibility  in gmsh. This function returns the tag of View.\n\nReturn: tag\n\nor\n\nReturn: tag, xy\n\nTypes:\n\nproblem: Problem\npathName: String\nfield: Integer\npoints: Integer\nstep: Integer\nplot: Boolean\nname: String\nvisible: Boolean\ntag: Integer\nxy: Tuples{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.probe-Tuple{LowLevelFEM.TensorField, Any, Any, Any}","page":"Functions","title":"LowLevelFEM.probe","text":"probe(A::Union{ScalarField,VectorField,TensorField}, x::Number, y::Number, z::Number; step=Int)\n\nGet a value of the field A in a point given with its coordinates x,y,z at time step step.\n\nReturn: Float64 or Vector{Float64} or Matrix{Float64}\n\nTypes:\n\nA: ScalarField or VectorField or TensorField\nx: Number\ny: Number\nz: Number\nstep: Int\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.probe-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}, String}","page":"Functions","title":"LowLevelFEM.probe","text":"probe(A::Union{ScalarField,VectorField,TensorField}, s::String; step=Int)\n\nGet a value of the field A in a point given its physical name in GMSH at time step step.\n\nReturn: Float64 or Vector{Float64} or Matrix{Float64}\n\nTypes:\n\nA: ScalarField or VectorField or TensorField\nx: Number\ny: Number\nz: Number\nstep: Int\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.resultant-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.resultant","text":"resultant(problem, field, phName; grad=false, component=:x)\n\nSolves the resultant of field on phName physical group. Return the resultant(s) in tuple. Number of the members in tuple depends on the dimension of problem. It can solve the resultant of a load vector (sum of the elements of the vector), if field is a vector of floats. If field is a view (tag of a view in gmsh), then the integral of the field is solved. field must have only one component. If grad is true, then the gradient of the field will be evaluated and component of the gradient (:x, :y or :z) will be used to solve the resultant.\n\nReturn: res\n\nor\n\nReturn: resx, resy\n\nor\n\nReturn: resx, resy, resz\n\nTypes:\n\nfield: Vector{Float64}\nphName: String \ndim: Int64\nres: Float64 \nresx: Float64 \nresy: Float64 \nresz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.rot-Tuple{LowLevelFEM.VectorField}","page":"Functions","title":"LowLevelFEM.rot","text":"rot(r::VectorField)\n\nSolves the rotation of the vector field r. In some countries \"rot\" denotes the English \"curl\". (See the curl function.)\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.rotateNodes","text":"rotateNodes(problem, phName, CoordSys)\n\nCreates the T transformation matrix, which rotates the nodal coordinate system of the nodes in phName physical group to the coordinate systen defined by CoordSys. The mesh belongs to problem.\n\nReturn: T\n\nTypes:\n\nproblem: Problem\nphName: String\nCoordSys: CoordinateSystem\nT: SparseMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.saveField-Tuple{String, Union{Number, LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}","page":"Functions","title":"LowLevelFEM.saveField","text":"saveField(fileName::String, variable::Union{ScalarField,VectorField,TensorField,Number})\n\nSaves variable of type ScalarField, VectorField, or TensorField to a file named fileName. The name of the file will be complemented with the string \"-LLF-Data.jld2\"\n\nReturn: none\n\nTypes:\n\nfileName: String\nvariable: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.scalarField-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.scalarField","text":"scalarField(problem, dataField)\n\nDefines a scalar field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem.\n\nReturn: Vector{Float64}\n\nTypes:\n\nproblem: Problem\ndataField: Vector{Tuple{String, Float64,...}}\n\nExamples\n\nf2 = field(\"face1\", f=1)\nqq = scalarField(problem, [f2])\nqqq = showDoFResults(problem, qq, :scalar)\n\nHere ScalarField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.setParameter-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.setParameter","text":"setParameter(name, value)\n\nDefines a parameter name and sets its value to value. \n\nReturn: none\n\nTypes:\n\nname: String\nvalue: Float64\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.setParameters-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.setParameters","text":"setParameters(name, value)\n\nDefines a parameter name and sets its value to value, which is a Vector{Float64}. \n\nReturn: none\n\nTypes:\n\nname: String\nvalue: Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}","page":"Functions","title":"LowLevelFEM.showBucklingResults","text":"showBucklingResults(Φ, name=..., visible=...)\n\nLoads buckling results into a View in gmsh. Φ is a struct of Eigen. name is a title to display and visible is a true or false value to toggle on or off the  initial visibility in gmsh. Click on ▷| to change the results. This function  returns the tag of View.\n\nReturn: tag\n\nTypes:\n\nΦ: Eigen\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showDeformationResults-Tuple{LowLevelFEM.VectorField, Any}","page":"Functions","title":"LowLevelFEM.showDeformationResults","text":"showDeformationResults(r::VectorField, comp; name=String, visible=Boolean)\n\nShows deformation result, where r contains the position vectors of nodes  in the current configuration.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showDoFResults-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.showDoFResults","text":"showDoFResults(q, comp; name=..., visible=...)\n\nLoads nodal results into a View in gmsh. q is the field to show, comp is the component of the field (:vector, :uvec, :ux, :uy, :uz, :vvec, :vx, :vy, :vz, :qvec, :qx, :qy, :qz, :T, :p, :qn, :s, :sx, :sy, :sz, :sxy, :syx, :syz, :szy, :szx, :sxz, :e, :ex, :ey, :ez, :exy, :eyx, :eyz, :ezy, :ezx, :exz, :seqv, :scalar, :tensor), name is a title to display and visible is a true or false value to toggle on or off the  initial visibility in gmsh. If q has more columns, then a sequence of results will be shown (eg. as an animation). This function returns the tag of View.\n\nReturn: tag\n\nTypes:\n\nq: ScalarField, VectorField or TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showElementResults-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.showElementResults","text":"showElementResults(F, comp; name=..., visible=..., smooth=...)\n\nSame as ShowStressResults or showStrainResults, depending on the type of F data field.\n\nReturn: tag\n\nTypes:\n\nF: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.showHeatFluxResults","text":"showHeatFluxResults(Q, comp; name=..., visible=..., smooth=...)\n\nLoads heat flux results into a View in gmsh. Q is a heat flux field to show, comp is the component of the field (:qvec, :qx, :qy, :qz, :q), name is a title to display, visible is a true or false value to toggle on or off the initial visibility in gmsh and smooth is a true of false value to toggle smoothing the stress field on or off. If Q contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.\n\nReturn: tag\n\nTypes:\n\nS: VectorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}","page":"Functions","title":"LowLevelFEM.showModalResults","text":"showModalResults(Φ, name=..., visible=...)\n\nLoads modal results into a View in gmsh. Φ is a struct of Eigen. name is a title to display and visible is a true or false value to toggle on or off the  initial visibility in gmsh. Click on ▷| to change the results. This function  returns the tag of View.\n\nReturn: tag\n\nTypes:\n\nΦ: Eigen\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showOnSurface-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.showOnSurface","text":"showOnSurface(field, phName; grad=false, component=:x, offsetX=0, offsetY=0, offsetZ=0, name=phName, visible=false)\n\nShows the values of a scalar field at a surface which has a physical name phName. field is the tag of a view in GMSH. The values of the field are calculated at the intersection with the surface. grad has a true or false value to toggle on or off the gradient of the field. component is the component of the gradient of field (:x, :y, :z) to be shown. offsetX, offsetY, offsetZ are the offsets in the x, y and z directions where the values are picked from. name is a title to display and visible is a true or false value to toggle on or off the initial visibility in gmsh.\n\nReturn: tag\n\nTypes:\n\nfield: Integer\nphName: String\ngrad: Boolean\ncomponent: Symbol\noffsetX: Float64\noffsetY: Float64\noffsetZ: Float64\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showStrainResults-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.showStrainResults","text":"showStrainResults(E, comp; name=..., visible=..., smooth=...)\n\nLoads strain results into a View in gmsh. E is a strain field to show, comp is the component of the field (:e, :ex, :ey, :ez, :exy, :eyz, :ezx), name is a title to display, visible is a true or false value to toggle on or off the initial visibility in gmsh and smooth is a true of false value to toggle smoothing the stress field on or off. If E contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.\n\nReturn: tag\n\nTypes:\n\nE: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.showStressResults-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.showStressResults","text":"showStressResults(S, comp; name=..., visible=..., smooth=...)\n\nLoads stress results into a View in gmsh. S is a stress field to show, comp is the component of the field (:s, :sx, :sy, :sz, :sxy, :syz, :szx, :seqv), name is a title to display, visible is a true or false value to toggle on or off the initial visibility in gmsh and smooth is a true of false value to toggle smoothing the stress field on or off. If S contains more than one time steps, then a  sequence of results will be shown (eg. as an animation). This function returns the tag of View.\n\nReturn: tag\n\nTypes:\n\nS: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.smallestEigenValue-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.smallestEigenValue","text":"smallestEigenValue(K, M)\n\nSolves the largest eigenvalue for a transient problem given by stiffness (heat conduction) matrix K and the mass (heat capacity) matrix M (C).\n\nReturn: λₘₐₓ\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nλₘₐₓ: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.smallestPeriodTime","text":"smallestPeriodTime(K, M)\n\nSolves the smallest period of time for a dynamic problem given by stiffness matrix K and the mass matrix M.\n\nReturn: Δt\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nΔt: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.solveBuckling","text":"solveBuckling(problem, loads, constraints; n=6)\n\nSolves the multipliers for the first n critical forces and the corresponding  buckling shapes for the instability of the problem, when loads and  constraints are applied. Result can be presented by showBucklingResults function. loads and constraints can be defined by load and displacementConstraint functions, respectively.\n\nReturn: buckling\n\nTypes:\n\nproblem: Problem\nloads: Vector{tuples}\nconstraints: Vector{tuples}\nn: Int64\nbuckling: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.solveBucklingModes","text":"solveBucklingModes(K, Knl; n=6)\n\nSolves the critical force multipliers and buckling mode shapes of a problem given by stiffness matrix K and the nonlinear stiffness matrix Knl. n is the number of buckling modes to solve. Returns the struct of critical forces and buckling modes. Results can be presented by showBucklingResults function.\n\nReturn: modes\n\nTypes:\n\nK: SystemMatrix\nKnl: SystemMatrix\nn: Int64\nmodes: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveDeformation-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.solveDeformation","text":"solveDeformation(problem::Problem, load, supp;\n                followerLoad=false,\n                loadSteps = 3,\n                rampedLoad = true,\n                rampedSupport = false,\n                maxIteration = 10,\n                saveSteps = false,\n                saveIterations = false,\n                plotConvergence = false,\n                relativeError = 1e-5,\n                initialDeformation=nodePositionVector(problem))\n\nSolves the deformed shape of a non-linearly elastic body...\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveDisplacement-NTuple{4, Any}","page":"Functions","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(problem, load, supp, elasticSupp)\n\nSolves the displacement vector q of problem with loads load,  supports supp and elastic supports elasticSupp.\n\nReturn: q\n\nTypes:\n\nproblem: Problem \nload: Vector{Tuple} \nsupp: Vector{Tuple}\nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(problem, load, supp)\n\nSolves the displacement vector q of problem with loads load and supports supp.\n\nReturn: q\n\nTypes:\n\nproblem: Problem \nload: Vector{Tuple} \nsupp: Vector{Tuple}\nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveDisplacement-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(K, q)\n\nSolves the equation K*q=f for the displacement vector q. K is the stiffness Matrix, q is the load vector.\n\nReturn: q\n\nTypes:\n\nK: SystemMatrix \nf: VectorField \nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveEigenModes-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.solveEigenModes","text":"solveEigenModes(K, M; n=6, fₘᵢₙ=1.01)\n\nSolves the eigen frequencies and mode shapes of a problem given by stiffness matrix K and the mass matrix M. n is the number of eigenfrequencies to solve, and solves the eigenfrequencies greater than fₘᵢₙ. Returns the struct of eigenfrequencies and eigen modes. Results can be presented by showModalResults function.\n\nReturn: modes\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nn: Int64\nfₘᵢₙ: Float64\nmodes: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveHeatFlux-Tuple{Any}","page":"Functions","title":"LowLevelFEM.solveHeatFlux","text":"solveHeatFlux(T; DoFResults=false)\n\nSolves the heat flux field q from temperature vector T. heat flux is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in problem. If DoFResults is true, q is a matrix with nodal results. In this case showDoFResults can be used to show the results (otherwise showHeatFluxResults or showElementResults).\n\nReturn: q\n\nTypes:\n\nproblem: Problem\nT: ScalarField\nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveModalAnalysis-Tuple{Any}","page":"Functions","title":"LowLevelFEM.solveModalAnalysis","text":"solveModalAnalysis(problem; constraints=[]; loads=[], n=6)\n\nSolves the first n eigenfrequencies and the corresponding  mode shapes for the problem, when loads and  constraints are applied. loads and contraints are optional.  Result can be presented by showModalResults function.  loads and constraints can be defined by load and displacementConstraint functions, respectively. If loads are given, it solves the eigenfrequencies of a prestressed structure.\n\nReturn: modes\n\nTypes:\n\nproblem: Problem\nloads: Vector{tuples}\nconstraints: Vector{tuples}\nn: Int64\nmodes: Eigen\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveStrain-Tuple{Any}","page":"Functions","title":"LowLevelFEM.solveStrain","text":"solveStrain(q; DoFResults=false)\n\nSolves the strain field E from displacement vector q. Strain field is given per elements, so it usually contains jumps at the boundaries of elements. Details of mesh is available in problem. If DoFResults is true, E is a matrix with nodal results. In this case showDoFResults can be used to show the results  (otherwise showStrainResults or showElementResults).\n\nReturn: E\n\nTypes:\n\nq: VectorField\nE: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveStress-Tuple{Any}","page":"Functions","title":"LowLevelFEM.solveStress","text":"solveStress(q; T=..., T₀=..., DoFResults=false)\n\nSolves the stress field S from displacement vector q. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in problem. If DoFResults is true, S is a matrix with nodal results. In this case showDoFResults can be used to show the results  (otherwise showStressResults or showElementResults). If the T temperature field (and T₀ initial temperature field if it differs from zero) is given, the function solves also the thermal stresses.\n\nReturn: S\n\nTypes:\n\nq: VectorField\nT: ScalarField\nT₀: ScalarField\nS: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveTemperature-NTuple{4, Any}","page":"Functions","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem, flux, temp, heatconv)\n\nSolves the temperature field T of problem with given heat flux flux, temperature temp and heat convection heatconv.\n\nReturn: T\n\nTypes:\n\nproblem: Problem \nflux: Vector{Tuple} \ntemp: Vector{Tuple}\nheatconv: Vector{Tuple}\nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem, flux, temp)\n\nSolves the temperature field T of problem with given heat flux flux and temperature temp.\n\nReturn: T\n\nTypes:\n\nproblem: Problem \nflux: Vector{Tuple} \ntemp: Vector{Tuple}\nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveTemperature-Tuple{Any, LowLevelFEM.VectorField}","page":"Functions","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem, u; T0=273.0)\n\nSolves the raise of temperature T during reversible (no dissipation) elastic deformations, where u is the displacement field, and problem is a heat cunduction problem.\n\nReturn: T\n\nTypes:\n\nproblem: Problem \nu: VectorField \nT0: Float64\nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.ScalarField}","page":"Functions","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(K, q)\n\nSolves the equation K*T=q for the temperature field T. K is the heat conduction matrix, q is the heat flux vector.\n\nReturn: T\n\nTypes:\n\nK: SystemMatrix \nq: ScalarField \nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.stiffnessMatrix-Tuple{Any}","page":"Functions","title":"LowLevelFEM.stiffnessMatrix","text":"stiffnessMatrix(problem)\n\nSolves the stiffness matrix of the problem.\n\nReturn: stiffMat\n\nTypes:\n\nproblem: Problem\nstiffMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.suppressDeformationAtBoundaries!","text":"suppressDeformationAtBoundaries!(stiffMat, loadVec, supports)\n\nSuppresses the displacements given in support in stiffMat and loadVec  so that it is only necessary to consider them once during iteration. stiffMat is the stiffness matrix, loadVec is the load vector. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: none\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}","page":"Functions","title":"LowLevelFEM.suppressDeformationAtBoundaries","text":"suppressDeformationAtBoundaries(stiffMat, loadVec, supports)\n\nSuppresses the displacements given in support in stiffMat and loadVec  so that it is only necessary to consider them once during iteration. stiffMat is the stiffness matrix, loadVec is the load vector. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: stiffMat1, loadVec1\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\nstiffMat1: SystemMatrix \nloadVec1: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.tangentMatrixConstitutive-Tuple{LowLevelFEM.VectorField}","page":"Functions","title":"LowLevelFEM.tangentMatrixConstitutive","text":"tangentMatrixConstitutive(r::VectorField)\n\nSolves the constitutive part of the tangent matrix (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: SystemMatrix\n\nTypes:     - r: VectorField\n\n[6]: Javier Bonet, Richard D. Wood: Nonlinear Continuum Mechanics for Finite Element Analysis, \n\nCambridge University Press, 2008, https://doi.org/10.1017/CBO9780511755446\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.tangentMatrixInitialStress-Tuple{LowLevelFEM.VectorField}","page":"Functions","title":"LowLevelFEM.tangentMatrixInitialStress","text":"tangentMatrixInitialStress(r::VectorField)\n\nSolves the initial stress part of the tangent matrix (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: SystemMatrix\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.temperatureConstraint-Tuple{Any}","page":"Functions","title":"LowLevelFEM.temperatureConstraint","text":"temperatureConstraint(name; T=...)\n\nGives the temperature constraints on name physical group.  T can be a constant value, or a function of x, y and z. (E.g. fn(x,y,z)=5*(5-x)); temperatureConstraint(\"surf1\", T=fn))\n\nReturn: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nT: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.tensorField-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.tensorField","text":"tensorField(problem, dataField; type=...)\n\nDefines a vector field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem. type can be an arbitrary Symbol, eg. :u or :f.\n\nReturn: TensorField\n\nTypes:\n\nproblem: Problem\ndataField: Vector{Tuple{String, Float64,...}}\n\nExamples\n\nf1(x, y, z) = sin(x)\nf2(x, y, z) = 5y\nff1 = field(\"face1\", fx=f1, fy=f2, fz=0, fxy=1, fyz=1, fzx=f2)\nff2 = field(\"face2\", fx=f2, fy=f1, fz=1, fxy=1, fyz=f1, fzx=1)\nqq = tensorField(problem, [ff1, ff2])\nqq0 = showDoFResults(problem, qq, :tensor)\n\nHere TensorField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.vectorField-Tuple{Any, Any}","page":"Functions","title":"LowLevelFEM.vectorField","text":"vectorField(problem, dataField; type=...)\n\nDefines a vector field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem. type can be an arbitrary Symbol, eg. :u or :f.\n\nReturn: VectorField\n\nTypes:\n\nproblem: Problem\ndataField: Vector{Tuple{String, Float64,...}}\n\nExamples\n\nf1(x, y, z) = sin(x)\nf2(x, y, z) = 5y\nff1 = field(\"face1\", fx=f1, fy=f2, fz=0)\nff2 = field(\"face2\", fx=f2, fy=f1, fz=1)\nqq = vectorField(problem, [ff1, ff2])\nqq0 = showDoFResults(problem, qq, :vector)\n\nHere VectorField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"Functions/#LowLevelFEM.∇-Tuple{Union{LowLevelFEM.ScalarField, LowLevelFEM.TensorField, LowLevelFEM.VectorField}}","page":"Functions","title":"LowLevelFEM.∇","text":"∇(rr::Union{VectorField, ScalarField, TensorField}; nabla=:grad)\n\nSolves the deriavatives of rr.\n\nIf rr is a ScalarField, nabla is :grad, it solves the gradient of rr, which is a VectorField.\nIf rr is a VectorField, nabla is :grad, it solves the gradient of rr, which is a TensorField.\nIf rr is a VectorField, nabla is :curl, it solves the rotation of rr, which is a VectorField.\nIf rr is a VectorField, nabla is :div, it solves the divergence of rr, which is a ScalarField.\nIf rr is a TensorField, nabla is :div, it solves the divergence of rr, which is a VectorField.\n\nReturn: ScalarField, VectorField or TensorField\n\nTypes:\n\nrr: ScalarField, VectorField or TensorField\nnabla: Symbol\n\n\n\n\n\n","category":"method"},{"location":"Functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"Functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"#LowLevelFEM","page":"Introduction","title":"LowLevelFEM","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Solution of a problem in linear elasticity using Finite Element Method consists of solution of the stiffness matrix K and load vector f, modifying them according to the boundary conditions (getting K' and f'), solving the displacement field q' as the result of the system of equations K'q=f', solving the stress field from q and visualize them. The above described steps can be easily performed using the LowLevelFEM package. Each step means a function with the appropriate parameters, while at any step it is possible to perform an arbitrary operation with the quantities calculated in the meantime. For example the strain energy can be solved as U=1/2q^T^Kq, for which the code is simply U=q'*K*q/2.(see Examples)","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Sketching the geometry, making the FE mesh with GMSH.\nSolving problems from linear elasticity,\n2D problems,\nPlane stress,\nPlane strain,\nAxisymmetric,\n3D problem (solid body),\nwhich means the creation of the stiffness matrix K and the mass matrix M of the problem using arbitrary\nelement types (line, triangle, rectangle, tetrahedron, hexahedron, pyramid, wedge)\napproximation order (up to ten, Lagrange polynomials)\nApplying\ndistributed forces on arbitrary physical groups (see GMSH),\nLines (in 2D: surface force, in 3D: edge force),\nSurfaces (in 2D: body force, in 3D: traction),\nVolumes (in 3D: body force),\nconcentrated forces on nodes,\nwhich means the calculation of the load vector f.\nConstraints on physical groups (nodes on points, edges, surfaces and volumes).\nElastic support\nGiving loads as functions\nGiving displacement constraints as functions\nDifferent materials on each physical group\nSolves stress, stain and heat flux field as element result (possibly jumps at the element boundaries) or as nodal results.\nResultant of scalar or vector type quantities on arbitrary physical group (in GMSH). The resultant can be the sum of elements in a load vector, or an integral of a distributed quantity.\nApplying initial conditions (displacement and velocity) on arbitrary points, edges, surfaces, volumes and on combinations of them.\nSolution of static and dynamic (transient with central difference method, Newmark and HHT-α) problems,\nDisplaying the results (scalar or vector displacements, scalar or tensor stresses and strains) with GMSH.\nWhen dynamic problems are solved animations are also possible (click on triangleright).\nRotation of nodal coordinate systems using transformation matrix. Transformation matrix can be given with constant direction vectors or with functions. (With this arbitrary coordinate systems can be defined.)\nPlotting arbitrary results on paths.\nSolves the damping matrix of structures in case of proportional damping\nusing Rayleigh-damping (C=αM+βK) or\nusing Caughey-damping (C=αM+β₁K+β₂KM⁻¹K+β₃KM⁻¹KM⁻¹K+⋅⋅⋅).\nSolves the stability analysis transient problems (spectral radius, period error, physical damping ratio, algorithmic damping ratio)\nBuckling of structures in 3D.\nHeat conduction problems\nConductivity and heat capacity matrices,\nTemperature boundary conditions (also with functions)\nLoads:\nHeat flux on boundaries (also with functions)\nHeat source inside the bodies (also with functions)\nHeat convection\nStady state and transient problems in heat conduction.\nHeat expansion\nThermal loading in stress analysis (thermal stresses)\nGenerated heat (and temperature change) due to elastic deformations.\nModal analysis (eigenfrequencies, modal shapes), even if the structure is prestressed.","category":"page"},{"location":"#Planned-features","page":"Introduction","title":"Planned features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"[ ] 3D (and  2D) truss structures\n[ ] 3D (and 2D) beam structures\n[ ] Shells\n[ ] MultiPoint Constraint (like MPC184 in Ansys)\n[ ] Contact problems,\n[ ] in 2D,\n[ ] in 3D,\n[ ] with penalty method\n[ ] with Lagrange multiplier method.\n[x] Defining displacement initial condition as a function of x, y and z.\n[x] Defining velocity initial condition as a function of x, y and z.\n[ ] Finite rotations.\n[ ] Plastic deformation (within small strain theory).\n[ ] Solver for arbitrary weak forms.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Any suggestions are welcome.","category":"page"}]
}
