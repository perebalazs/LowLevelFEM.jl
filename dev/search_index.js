var documenterSearchIndex = {"docs":
[{"location":"Operators/#Operators-and-Algebra","page":"Operators","title":"Operators and Algebra","text":"","category":"section"},{"location":"Operators/#Base.:*-Tuple{LowLevelFEM.SystemMatrix, Number}","page":"Operators","title":"Base.:*","text":"*(A::SystemMatrix, c::Number)\n*(c::Number, A::SystemMatrix)\n\nScalar multiplication of a system matrix.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{Number, ScalarField}","page":"Operators","title":"Base.:*","text":"*(b::Number, A::ScalarField)\n\nPerforms multiplication of a ScalarField objects and a Number.\n\nReturn: ScalarField\n\nExamples\n\nC = 2.0 * A\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{ScalarField, Number}","page":"Operators","title":"Base.:*","text":"*(A::ScalarField, b::Number)\n\nPerforms multiplication of a ScalarField objects and a Number.\n\nReturn: ScalarField\n\nExamples\n\nC = A * 2.0\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:*","text":"*(A::ScalarField, B::ScalarField)\n\nPerforms element-wise multiplication of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A * B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{ScalarField, VectorField}","page":"Operators","title":"Base.:*","text":"*(A::ScalarField, B::VectorField)\n\nScales a VectorField by a ScalarField element-wise on matching elements.\n\nReturns: VectorField\n\nExamples\n\nv2 = s .* v  # equivalent to s * v\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{TensorField, TensorField}","page":"Operators","title":"Base.:*","text":"*(A::TensorField, B::TensorField)\n\nTensor contraction (matrix multiplication) for each element/node: reshapes 9×1 blocks into 3×3, multiplies, then flattens back.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{Union{LowLevelFEM.SystemMatrix, Matrix}, Union{ScalarField, TensorField, VectorField}}","page":"Operators","title":"Base.:*","text":"*(A::Union{SystemMatrix,Matrix}, B::Union{ScalarField,VectorField,TensorField})\n\nMatrix–vector multiplication between a system matrix and a nodal vector field.\n\nIf the vector field is defined elementwise, it is automatically converted to nodal representation before multiplication.\n\nReturns\n\nVectorField containing the nodal result with one time step.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{VectorField, ScalarField}","page":"Operators","title":"Base.:*","text":"*(B::VectorField, A::ScalarField)\n\nScales a VectorField by a ScalarField element-wise on matching elements.\n\nReturns: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:+-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix}","page":"Operators","title":"Base.:+","text":"+(A::SystemMatrix, B::SystemMatrix)\n-(A::SystemMatrix, B::SystemMatrix)\n\nAddition and subtraction of system matrices.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:+-Tuple{Number, ScalarField}","page":"Operators","title":"Base.:+","text":"+(b::Number, A::ScalarField)\n\nAdd a constant offset to a scalar field.\n\nThe scalar b is added elementwise to each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the shifted values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:+-Tuple{ScalarField, Number}","page":"Operators","title":"Base.:+","text":"+(A::ScalarField, b::Number)\n\nAdd a constant offset to a scalar field.\n\nThe scalar b is added elementwise to each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the shifted values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:+-Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:+","text":"+(A::ScalarField, B::ScalarField)\n\nPerforms element-wise addition of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A + B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:--Tuple{Number, ScalarField}","page":"Operators","title":"Base.:-","text":"-(b::Number, A::ScalarField)\n\nSubtract a constant offset from a scalar field.\n\nThe scalar b is subtracted elementwise from each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the shifted values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:--Tuple{ScalarField, Number}","page":"Operators","title":"Base.:-","text":"-(A::ScalarField, b::Number)\n\nSubtract a constant offset from a scalar field.\n\nThe scalar b is subtracted elementwise from each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the shifted values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:--Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:-","text":"-(A::ScalarField, B::ScalarField)\n\nPerforms element-wise subtraction of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A - B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:/-Tuple{Number, ScalarField}","page":"Operators","title":"Base.:/","text":"/(b::Number, A::ScalarField)\n\nElementwise division of a constant by a scalar field.\n\nEach element-wise matrix of the scalar field is used as the divisor of the constant b, i.e. b ./ A.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the elementwise divided values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:/-Tuple{ScalarField, Number}","page":"Operators","title":"Base.:/","text":"/(A::ScalarField, b::Number)\n\nElementwise division of a scalar field by a constant.\n\nEach element-wise matrix of the scalar field is divided by the scalar b. If the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the elementwise divided values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:/-Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:/","text":"/(A::ScalarField, B::ScalarField)\n\nPerforms element-wise division of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A / B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:/-Tuple{VectorField, ScalarField}","page":"Operators","title":"Base.:/","text":"/(B::VectorField, A::ScalarField)\n\nDivides a VectorField by a ScalarField element-wise on matching elements.\n\nReturns: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:\\-Tuple{Union{LowLevelFEM.SystemMatrix, Matrix}, Union{ScalarField, TensorField, VectorField}}","page":"Operators","title":"Base.:\\","text":"\\(A::Union{SystemMatrix,Matrix}, b::Union{ScalarField,VectorField,TensorField})\n\nSolves the linear system A * x = b for a nodal scalar, vectoror tensor field right-hand side.\n\nIf the field is defined elementwise, it will be converted to nodal form before solving.\n\nReturns\n\nScalarField or VectorField or TensorField containing the solution.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:\\-Tuple{Union{LowLevelFEM.SystemMatrix, SparseArrays.SparseMatrixCSC}, SparseArrays.SparseMatrixCSC}","page":"Operators","title":"Base.:\\","text":"\\(K::Union{SystemMatrix,SparseMatrixCSC}, F::SparseMatrixCSC)\n\nSolves a sparse linear system with multiple right-hand sides.\n\nReturns\n\nSparse matrix containing the solution.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:∘-Tuple{Function, Union{ScalarField, VectorField}}","page":"Operators","title":"Base.:∘","text":"∘(D::Function, A::Union{ScalarField,VectorField})\n\nLeft application of differential operator D to field A.\n\nIf D == ∇ and A is ScalarField: returns grad(A).\nIf D == ∇ and A is VectorField: returns grad(A)' (transpose).\n\nReturns: VectorField or TensorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->x, fy=y->y, fz=z->z)])\nT = ∇ ∘ V      # equals grad(V)'\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:∘-Tuple{Union{ScalarField, VectorField}, Function}","page":"Operators","title":"Base.:∘","text":"∘(A::Union{ScalarField,VectorField}, D::Function)\n\nRight application of differential operator D to field A.\n\nIf D == ∇ and A is ScalarField: returns grad(A).\nIf D == ∇ and A is VectorField: returns grad(A).\n\nReturns: VectorField or TensorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nS = scalarField(problem, [field(\"body\", f=(x,y,z)->x*y)])\nG = S ∘ ∇      # grad of scalar field\nV = vectorField(problem, [field(\"body\", fx=x->x, fy=y->y, fz=z->z)])\nH = V ∘ ∇      # grad of vector field (tensor)\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.Math.cbrt-Tuple{ScalarField}","page":"Operators","title":"Base.Math.cbrt","text":"cbrt(A::ScalarField)\n\nElementwise cubic root of a scalar field.\n\nApplies the cubic root to each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the elementwise cubic-rooted values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.abs-Tuple{ScalarField}","page":"Operators","title":"Base.abs","text":"abs(A::ScalarField)\n\nElementwise absolute value of a scalar field.\n\nApplies the absolute value to each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the elementwise absolute values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.adjoint-Tuple{TensorField}","page":"Operators","title":"Base.adjoint","text":"adjoint(A::TensorField)\n\nAdjoint (conjugate transpose) of each 3×3 tensor block.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.axes-Tuple{LowLevelFEM.SystemMatrix}","page":"Operators","title":"Base.axes","text":"axes(K::SystemMatrix)\n\nReturn the valid index ranges for the system matrix.\n\nEquivalent to axes(K.A).\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.copy-Tuple{LowLevelFEM.SystemMatrix}","page":"Operators","title":"Base.copy","text":"copy(K::SystemMatrix)\n\nReturns a deep copy of the system matrix.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.eltype-Tuple{LowLevelFEM.SystemMatrix}","page":"Operators","title":"Base.eltype","text":"eltype(K::SystemMatrix)\n\nReturn the element type of the system matrix.\n\nEquivalent to eltype(K.A).\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.getindex-Tuple{LowLevelFEM.SystemMatrix, Vararg{Any}}","page":"Operators","title":"Base.getindex","text":"getindex(K::SystemMatrix, I...)\n\nIndexing operation for SystemMatrix.\n\nForwards all indexing operations to the underlying sparse matrix K.A, allowing a SystemMatrix to be indexed in the same way as a SparseMatrixCSC.\n\nExamples include:\n\nK[i, j]\nK[:, j], K[i, :]\nK[a:b, c:d]\nK[v1, v2] where v1 and v2 are index vectors.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.inv-Tuple{TensorField}","page":"Operators","title":"Base.inv","text":"inv(A::TensorField)\n\nMatrix inverse of each 3×3 tensor block.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.log-Tuple{ScalarField}","page":"Operators","title":"Base.log","text":"log(A::ScalarField)\n\nElementwise natural logarithm of a scalar field.\n\nApplies the natural logarithm to each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the elementwise logarithmic values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.setindex!-Tuple{LowLevelFEM.SystemMatrix, Any, Vararg{Any}}","page":"Operators","title":"Base.setindex!","text":"setindex!(K::SystemMatrix, v, I...)\n\nIn-place assignment for SystemMatrix.\n\nForwards indexed assignment to the underlying sparse matrix K.A, enabling modifications such as:\n\nK[i, j] = v\nK[a:b, c:d] .= v\nK[v1, v2] .= submatrix\n\nNote that assignment follows the semantics and performance characteristics of SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.size-Tuple{LowLevelFEM.SystemMatrix}","page":"Operators","title":"Base.size","text":"size(K::SystemMatrix)\n\nReturn the size of the system matrix.\n\nEquivalent to size(K.A).\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.sqrt-Tuple{ScalarField}","page":"Operators","title":"Base.sqrt","text":"sqrt(A::ScalarField)\n\nElementwise square root of a scalar field.\n\nApplies the square root to each entry of every element-wise matrix of the scalar field.\n\nIf the field is nodal, it is first converted to elementwise form.\n\nReturns\n\nA new ScalarField containing the elementwise square-rooted values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.transpose-Tuple{LowLevelFEM.SystemMatrix}","page":"Operators","title":"Base.transpose","text":"transpose(K::SystemMatrix)\nadjoint(K::SystemMatrix)\n\nTranspose / adjoint of a system matrix.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.transpose-Tuple{TensorField}","page":"Operators","title":"Base.transpose","text":"transpose(A::TensorField)\n\nTransposes each 3×3 tensor block.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:×-Tuple{Function, VectorField}","page":"Operators","title":"LinearAlgebra.:×","text":"×(D::Function, A::VectorField)\n\nLeft curl. With D == ∇, returns curl(A).\n\nReturns: VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->0, fy=x->x, fz=z->0)])\nC = ∇ × V\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:×-Tuple{VectorField, Function}","page":"Operators","title":"LinearAlgebra.:×","text":"×(A::VectorField, D::Function)\n\nRight curl with sign convention. With D == ∇, returns -curl(A).\n\nReturns: VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->0, fy=x->x, fz=z->0)])\nCneg = V × ∇   # -curl(V)\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:×-Tuple{VectorField, VectorField}","page":"Operators","title":"LinearAlgebra.:×","text":"×(a::VectorField, b::VectorField)\n\nElement-wise 3D vector cross product on matching elements.\n\nReturns: VectorField\n\nExamples\n\nw = u × v\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:⋅-Tuple{Function, Union{TensorField, VectorField}}","page":"Operators","title":"LinearAlgebra.:⋅","text":"⋅(D::Function, A::Union{VectorField,TensorField})\n\nLeft contraction with the differential operator. With D == ∇:\n\nIf A is VectorField: returns div(A).\nIf A is TensorField: returns div(A').\n\nReturns: ScalarField or VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nT = tensorField(problem, [field(\"body\", fz=z->z)])\nDV = ∇ ⋅ T     # VectorField (divergence of tensor)\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:⋅-Tuple{TensorField, TensorField}","page":"Operators","title":"LinearAlgebra.:⋅","text":"⋅(A::TensorField, B::TensorField)\n\nElement-wise (Hadamard) product followed by summation of all components, yielding a scalar per tensor (i.e., Frobenius inner product).\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:⋅-Tuple{Union{TensorField, VectorField}, Function}","page":"Operators","title":"LinearAlgebra.:⋅","text":"⋅(A::Union{VectorField,TensorField}, D::Function)\n\nRight contraction with the differential operator. With D == ∇:\n\nIf A is VectorField: returns div(A) (scalar field).\nIf A is TensorField: returns div(A) (vector field).\n\nReturns: ScalarField or VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->x, fy=y->y, fz=z->z)])\ndivV = V ⋅ ∇   # ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.det-Tuple{TensorField}","page":"Operators","title":"LinearAlgebra.det","text":"det(A::TensorField)\n\nComputes the determinant of each 3×3 tensor block.\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.diagm-Tuple{VectorField}","page":"Operators","title":"LinearAlgebra.diagm","text":"diagm(A::VectorField)\n\nCreates a diagonal TensorField from a VectorField (dim=3), i.e., places vector components on the tensor diagonal for each node/element.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.issymmetric-Tuple{LowLevelFEM.SystemMatrix}","page":"Operators","title":"LinearAlgebra.issymmetric","text":"issymmetric(K::SystemMatrix)\n\nChecks whether the system matrix is symmetric.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.norm-Tuple{VectorField}","page":"Operators","title":"LinearAlgebra.norm","text":"norm(A::VectorField)\n\nElement-wise Euclidean norm of a VectorField.\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LowLevelFEM.ldiv_sparse!-Tuple{SparseArrays.SparseMatrixCSC, Union{LowLevelFEM.SystemMatrix, SparseArrays.SparseMatrixCSC}, SparseArrays.SparseMatrixCSC}","page":"Operators","title":"LowLevelFEM.ldiv_sparse!","text":"ldiv_sparse!(X, K, F)\n\nSolves the sparse linear system K * X = F column-by-column, where F is a sparse matrix representing multiple right-hand sides.\n\nReturns\n\nSparse matrix X containing the solution.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LowLevelFEM.mapScalarField-Union{Tuple{F}, Tuple{F, ScalarField}} where F","page":"Operators","title":"LowLevelFEM.mapScalarField","text":"mapScalarField(f, A::ScalarField)\n\nApply a function elementwise to a scalar field.\n\nThe function f is applied to each element-wise matrix of the scalar field. If the field is nodal, it is first converted to elementwise form.\n\nThis is a low-level helper used to implement elementwise scalar-field operations such as abs, +, -, log, sqrt, etc.\n\nReturns\n\nA new ScalarField containing the transformed values.\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LowLevelFEM.trace-Tuple{TensorField}","page":"Operators","title":"LowLevelFEM.trace","text":"trace(A::TensorField)\n\nComputes the trace of each 3×3 tensor block.\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LowLevelFEM.unitTensor-Tuple{TensorField}","page":"Operators","title":"LowLevelFEM.unitTensor","text":"unitTensor(A::TensorField)\n\nCreates an identity tensor field (I) with the same element structure and time steps as A.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#Nonlinear-Mechanics-and-Fields","page":"Nonlinear","title":"Nonlinear Mechanics and Fields","text":"","category":"section"},{"location":"Nonlinear/#Base.div-Tuple{Union{TensorField, VectorField}}","page":"Nonlinear","title":"Base.div","text":"div(r::Union{VectorField,TensorField})\n\nSolves the divergence of the vector field or tensor field r. An alternative way to solve div is to use ∇ as a differencial operator.\n\nReturn: ScalarField or VectorField\n\nTypes:\n\nr: VectorField or TensorField\n\n3D Examples (assumes problem is set as in the ∇ doc setup)\n\n# Assumes a 3D mesh with physical group \"body\".\n\n# 1) Divergence of a 3D vector field → ScalarField\nv1(X,Y,Z) = X\nv2(X,Y,Z) = Y\nv3(X,Y,Z) = Z\nv = vectorField(problem, [field(\"body\", fx=v1, fy=v2, fz=v3)])\nD1 = div(v)\nD2 = ∇ ⋅ v\n\n# 2) Divergence of a 3D tensor field → VectorField\nfsz(X, Y, Z) = 10 - Z\nS = tensorField(problem, [field(\"body\", fz=fsz)])\nb1 = -div(S)\nb2 = -S ⋅ ∇\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}","page":"Nonlinear","title":"LowLevelFEM.applyDeformationBoundaryConditions!","text":"applyDeformationBoundaryConditions!(deformVec, supports)\n\nApplies displacement boundary conditions supports on deformation vector deformVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturns: nothing\n\nTypes:\n\ndeformVec: VectorField\nsupports: Vector{BoundaryCondition}\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.curl-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.curl","text":"curl(r::VectorField)\n\nSolves the rotation of the vector field r. An alternative way to solve curl is to use ∇ as a differencial operator.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n3D Example (assumes problem is set as in the ∇ doc setup)\n\n# Assumes a 3D mesh with physical group \"body\".\nvx(X, Y, Z) = 0\nvy(X, Y, Z) = X\nvz(X, Y, Z) = 0\nv = vectorField(problem, [field(\"body\", fx=vx, fy=vy, fz=vz)])\nD1 = curl(v)\nD2 = ∇ × v\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.equivalentNodalForce-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.equivalentNodalForce","text":"equivalentNodalForce(r::VectorField)\n\nSolves the equivalent nodal force (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.grad-Tuple{Union{ScalarField, VectorField}}","page":"Nonlinear","title":"LowLevelFEM.grad","text":"grad(r::Union{ScalarField,VectorField})\n\nSolves the gradient of the scalar field or vector field r. An alternative way to solve grad is to use ∇ as a differencial operator.\n\nReturn: VectorField or TensorField\n\nTypes:\n\nr: ScalarField or VectorField\n\n3D Examples\n\n# Assumes a 3D mesh with physical group \"body\".\n\n# 1) Gradient of a 3D scalar field → VectorField\nf(X,Y,Z) = X^2 + Y*Z\nS = scalarField(problem, [field(\"body\", f=f)])\nG1 = grad(S)\nG2 = ∇(S)\n\n# 2) Gradient of a 3D vector field → TensorField\nvx(X,Y,Z) = X\nvy(X,Y,Z) = Y\nvz(X,Y,Z) = Z\nV = vectorField(problem, [field(\"body\", fx=vx, fy=vy, fz=vz)])\nT1 = grad(V)\nT2 = V ∘ ∇\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.nodePositionVector-Tuple{Any}","page":"Nonlinear","title":"LowLevelFEM.nodePositionVector","text":"nodePositionVector(problem)\n\nReturns the position vectors of all mesh nodes as a VectorField (initial configuration). Returning vector is always a 3D vector.\n\nReturns: R\n\nTypes:\n\nproblem: Problem\nR: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.nonFollowerLoadVector-Tuple{VectorField, Any}","page":"Nonlinear","title":"LowLevelFEM.nonFollowerLoadVector","text":"nonFollowerLoadVector(r::VectorField, load)\n\nSolves the non-follower load vector (when solving large deformation problems). r is the position vector field in the current configuration.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.rot-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.rot","text":"rot(r::VectorField)\n\nSolves the rotation of the vector field r. In some countries \"rot\" denotes the English \"curl\". (See the curl function.)\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.showDeformationResults-Tuple{VectorField, Any}","page":"Nonlinear","title":"LowLevelFEM.showDeformationResults","text":"showDeformationResults(r::VectorField, comp; name=String, visible=Boolean)\n\nShows deformation result, where r contains the position vectors of nodes  in the current configuration.\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.solveDeformation-Tuple{Any, Any, Any}","page":"Nonlinear","title":"LowLevelFEM.solveDeformation","text":"solveDeformation(problem::Problem, load, supp;\n                followerLoad=false,\n                loadSteps = 3,\n                rampedLoad = true,\n                rampedSupport = false,\n                maxIteration = 10,\n                saveSteps = false,\n                saveIterations = false,\n                plotConvergence = false,\n                relativeError = 1e-5,\n                initialDeformation=nodePositionVector(problem))\n\nSolves the deformed shape of a non-linearly elastic body...\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}","page":"Nonlinear","title":"LowLevelFEM.suppressDeformationAtBoundaries!","text":"suppressDeformationAtBoundaries!(stiffMat, loadVec, supports)\n\nSuppresses the displacements given in support in stiffMat and loadVec  so that it is only necessary to consider them once during iteration. stiffMat is the stiffness matrix, loadVec is the load vector. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturns: nothing\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{BoundaryCondition}\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}","page":"Nonlinear","title":"LowLevelFEM.suppressDeformationAtBoundaries","text":"suppressDeformationAtBoundaries(stiffMat, loadVec, supports)\n\nSuppresses the displacements given in support in stiffMat and loadVec  so that it is only necessary to consider them once during iteration. stiffMat is the stiffness matrix, loadVec is the load vector. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: stiffMat1, loadVec1\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{BoundaryCondition}\nstiffMat1: SystemMatrix \nloadVec1: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.tangentMatrixConstitutive-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.tangentMatrixConstitutive","text":"tangentMatrixConstitutive(r::VectorField)\n\nSolves the constitutive part of the tangent matrix (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: SystemMatrix\n\nTypes:     - r: VectorField\n\n[6]: Javier Bonet, Richard D. Wood: Nonlinear Continuum Mechanics for Finite Element Analysis,  Cambridge University Press, 2008, https://doi.org/10.1017/CBO9780511755446\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.tangentMatrixInitialStress-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.tangentMatrixInitialStress","text":"tangentMatrixInitialStress(r::VectorField)\n\nSolves the initial stress part of the tangent matrix (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: SystemMatrix\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.∇-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"Nonlinear","title":"LowLevelFEM.∇","text":"∇(r::Union{VectorField, ScalarField, TensorField}; nabla=:grad)\n\nComputes derivatives of r.\n\nIf r is a ScalarField and nabla == :grad, returns the gradient (a VectorField).\nIf r is a VectorField and nabla == :grad, returns the gradient (a TensorField).\nIf r is a VectorField and nabla == :curl, returns the curl (a VectorField).\nIf r is a VectorField and nabla == :div, returns the divergence (a ScalarField).\nIf r is a TensorField and nabla == :div, returns the divergence (a VectorField).\n\nReturns: ScalarField, VectorField, or TensorField\n\nTypes:\n\nr: ScalarField, VectorField, or TensorField\nnabla: Symbol\n\n3D Examples (assumes problem is set as in the ∇ doc setup)\n\n# One-time 3D setup (assumes examples/Fields/cube.geo exists with physical group \"body\")\nusing LowLevelFEM\ngmsh.initialize()\ngmsh.open(\"examples/Fields/cube.geo\")\nmat = material(\"body\", E=210e3, ν=0.3, ρ=7.85e-9)\nproblem = Problem([mat], type=:Solid)\n\n# 1) Gradient of a 3D scalar field: ∇f → VectorField\nf(X,Y,Z) = X^2 + Y*Z\nS = scalarField(problem, [field(\"body\", f=f)])\nG = ∇(S)  # VectorField with 3 components\n\n# 2) Curl of a 3D vector field: ∇ × v → VectorField\nvx(X,Y,Z) = 0\nvy(X,Y,Z) = X\nvz(X,Y,Z) = 0\nV = vectorField(problem, [field(\"body\", fx=vx, fy=vy, fz=vz)])\nC = ∇(V, nabla=:curl)  # approx (0, 0, 1) everywhere\n\n# 3) Divergence of a 3D vector field: ∇ ⋅ v → ScalarField\nv1(X,Y,Z) = X\nv2(X,Y,Z) = Y\nv3(X,Y,Z) = Z\nV2 = vectorField(problem, [field(\"body\", fx=v1, fy=v2, fz=v3)])\nD = ∇(V2, nabla=:div)  # ≈ 3\n\n# 4) Divergence of a 3D tensor field: ∇ · T → VectorField (if T is TensorField)\n# For example, a diagonal tensor T with only Tzz = g(Z): div(T) = (0, 0, ∂g/∂Z)\ng(Z) = 10 - Z\nT = tensorField(problem, [field(\"body\", fz=g)])\nDV = ∇(T, nabla=:div)  # VectorField\n\n# Symmetric displacement gradient via operators\n# A = (u ∘ ∇ + ∇ ∘ u) / 2\ngmsh.finalize()\n\n\n\n\n\n","category":"method"},{"location":"Linear/#Linear-Mechanics","page":"Linear","title":"Linear Mechanics","text":"","category":"section"},{"location":"Linear/#LowLevelFEM.CDM-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, VectorField, Vector{BoundaryCondition}, VectorField, VectorField, Int64, Float64}","page":"Linear","title":"LowLevelFEM.CDM","text":"CDM(K, M, C, f, bc, u0, v0, n, Δt)\nCDM(K, M, f, bc, u0, v0, n, Δt)\nCDM(K, M, C, f, u0, v0, n, Δt; support=[])\nCDM(K, M, f, u0, v0, n, Δt; support=[])\n\nSolves a transient structural dynamic problem using the central difference method (CDM), an explicit time integration scheme. (support ≡ bc)\n\nThe semi-discrete system\n\n\nM * ü(t) + C * u̇(t) + K * u(t) = f(t)\n\n\nis advanced in time using central finite differences. The method supports:\n\ntime-independent or time-dependent load vectors f\ntime-independent or time-dependent displacement boundary conditions\nconsistent treatment of constraint-induced inertia and damping terms\nvector-valued unknowns (VectorField)\n\nBoundary conditions are applied solver-side: on constrained DOFs the prescribed displacements override the initial conditions, while on free DOFs the initial displacement u0 and velocity v0 are used. Velocities on constrained DOFs are derived from the prescribed displacements.\n\nIf f.nsteps == 1, the load is treated as time-independent. If f.nsteps == n, the load is applied time step–by–time step.\n\n\n\nArguments\n\nK::SystemMatrix   Global stiffness matrix.\nM::SystemMatrix   Global mass matrix (assumed diagonal or lumped for efficiency).\nC::SystemMatrix   Global damping matrix. If omitted, zero damping is assumed.\nf::VectorField   External load vector (time-independent or time-dependent).\nbc::Vector{BoundaryCondition}   Displacement-type boundary conditions (possibly time-dependent).\nu0::VectorField   Initial displacement field. Overridden on constrained DOFs.\nv0::VectorField   Initial velocity field. Overridden on constrained DOFs.\nn::Int   Number of time steps.\nΔt::Float64   Time step size.\n\n\n\nReturns\n\nu::VectorField   Displacement field at all time steps (ndof × nsteps).\nv::VectorField   Velocity field at all time steps (ndof × nsteps).\n\nThe associated time vector is\n\n\nt = 0 : Δt : (n-1)Δt\n\n\n\n\nNotes\n\nThe method is conditionally stable. The critical time step is governed by the highest eigenfrequency and damping:\n\n\nΔt_max = T_min / π * (√(1 + ξ_max^2) - ξ_max)\n\n\nwhere T_min is the smallest modal period and ξ_max is the largest modal damping ratio.\n\nThe algorithm itself is agnostic to the physical meaning of the displacement field;\n\nit operates purely on the algebraic system defined by M, C, and K.\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}","page":"Linear","title":"LowLevelFEM.CDMaccuracyAnalysis","text":"CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)\n\nGives some functions (graphs) for accuracy analysis of the CDM method.  ωₘᵢₙ and ωₘₐₓ are the square root of smallest and largest eigenvalues of the Kϕ=ω²Mϕ eigenvalue problem, Δt is the time step size. type is one of the following values:\n\n:SR: spectral radius\n:PDR: physical damping ratio\n:ADR: algorithmic damping ratio\n:PE: period error\n\nFor details see [3].  n is the number of points in the graph. The damping matrix is assembled in the  following ways: C=αM+βK or C=αM+β₁K+β₂KM⁻¹K+β₃KM⁻¹KM⁻¹K+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (ξ in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (β in the argument list) are the  coefficients of the series. (see [4]) Either ξ or β must be specified. ξ or β are scalars or  vectors. If show_β or show_ξ is true, the corresponding β or ξ values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with plot(xy))\n\n[4]: Serfőző, D., Pere, B.: An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems, Meccanica, https://doi.org/10.1007/s11012-025-02036-9\n\nReturn: xy\n\nTypes:\n\nωₘᵢₙ: Float64\nωₘₐₓ: Float64\nΔt: Float64 \nn: Int64\nα: Float64\nβ: Float64 of Vector{Float64}\nξ: Float64 of Vector{Float64}\nshow_β: Boolean\nshow_ξ: Boolean\nxy: Tuple{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.HHT-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, VectorField, Vector{BoundaryCondition}, VectorField, VectorField, Int64, Float64}","page":"Linear","title":"LowLevelFEM.HHT","text":"HHT(K, M, f, bc, u0, v0, n, Δt; α=0.0, δ=0.0, γ=0.5+δ, β=0.25*(0.5+γ)^2)\nHHT(K, M, f, u0, v0, n, Δt; α=0.0, δ=0.0, γ=0.5+δ, β=0.25*(0.5+γ)^2)\n\nSolves a transient structural dynamic problem using the Hilber–Hughes–Taylor (HHT-α) method[1], an implicit time integration scheme with controllable numerical dissipation.\n\nThe semi-discrete system\n\n\nM * ü(t) + K * u(t) = f(t)\n\n\nis integrated in time using the generalized Newmark formulation with the HHT-α modification. The method supports:\n\ntime-independent or time-dependent load vectors f\ntime-independent or time-dependent displacement boundary conditions\nsolver-side enforcement of Dirichlet constraints\nconsistent treatment of constraint-induced inertia forces\nvector-valued unknowns (VectorField)\n\nBoundary conditions are applied solver-side: on constrained DOFs the prescribed displacements override the initial conditions, while on free DOFs the initial displacement u0 and velocity v0 are used. Prescribed displacements are inserted at every time step, and the corresponding inertial contributions are accounted for automatically through the global system.\n\nIf f.nsteps == 1, the load is treated as time-independent. If f.nsteps == n, the load is applied time step–by–time step.\n\nThe parameters α, β, and γ control numerical dissipation and stability. If δ is given, the standard relations\n\n\nγ = 0.5 + δ\nβ = 0.25 * (0.5 + γ)^2\n\n\nare used.\n\n\n\nArguments\n\nK::SystemMatrix   Global stiffness matrix.\nM::SystemMatrix   Global mass matrix.\nf::VectorField   External load vector (time-independent or time-dependent).\nbc::Vector{BoundaryCondition}   Displacement-type boundary conditions (possibly time-dependent).\nu0::VectorField   Initial displacement field. Overridden on constrained DOFs.\nv0::VectorField   Initial velocity field. Overridden on constrained DOFs.\nn::Int   Number of time steps.\nΔt::Float64   Time step size.\n\n\n\nReturns\n\nu::VectorField   Displacement field at all time steps (ndof × nsteps).\nv::VectorField   Velocity field at all time steps (ndof × nsteps).\n\nThe associated time vector is\n\n\nt = 0 : Δt : (n-1)Δt\n\n\n\n\nNotes\n\nThe HHT-α method is unconditionally stable for appropriate parameter choices and introduces numerical dissipation primarily in the high-frequency range.\nThe algorithm itself is independent of the physical interpretation of the displacement field and operates purely on the algebraic system defined by M, K, and f.\nDamping matrices are not included explicitly; numerical dissipation is controlled via the HHT-α parameters.\n\n\n\nReference\n\nHilber, H. M., Hughes, T. J. R., Taylor, R. L.   Improved numerical dissipation for time integration algorithms in structural dynamics,   Earthquake Engineering & Structural Dynamics, 5(3), 283–292, 1977.\n\n[1]: Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. Improved  numerical dissipation for time integration algorithms in structural  dynamics. Earthquake Engineering & Structural Dynamics 5.3 (1977): 283-292.\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}","page":"Linear","title":"LowLevelFEM.HHTaccuracyAnalysis","text":"HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)\n\nGives some functions (graphs) for accuracy analysis of the HHT-α method[1].  ωₘᵢₙ and ωₘₐₓ are the square root of smallest and largest eigenvalues of the Kϕ=ω²Mϕ eigenvalue problem, Δt is the time step size. type is one of the following values:\n\n:SR: spectral radius\n:ADR: algorithmic damping ratio\n:PE: period error\n\nFor details see [2] and [3].  n is the number of points in the graph. For the meaning of α, β and γ see [1]. If δ is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with plot(xy))\n\n[2]: Belytschko, Ted, and Thomas JR, Hughes: Computational methods for  transient analysis, North-Holland, (1983).\n\n[3]: Serfőző, D., Pere, B.: A method to accurately define arbitrary algorithmic damping character as viscous damping. Arch Appl Mech 93, 3581–3595 (2023). https://doi.org/10.1007/s00419-023-02454-9\n\nReturn: xy\n\nTypes:\n\nωₘᵢₙ: Float64\nωₘₐₓ: Float64\nΔt: Float64 \nn: Int64\nα: Float64\nβ: Float64\nγ: Float64\nδ: Float64\nxy: Tuple{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyBoundaryConditions!-Tuple{Union{ScalarField, TensorField, VectorField}, Vector{BoundaryCondition}}","page":"Linear","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(field::Union{ScalarField,VectorField,TensorField}, supports::Vector{BoundaryCondition})\n\nApplies boundary conditions supports on a ScalarField, VectorField or TensorField field. Mesh details are in problem. supports is BoundaryCondition.\n\nReturns: nothing\n\nTypes:\n\nproblem: Problem\nfield: ScalarField, VectorField or TensorField\nsupports: Vector{BoundaryCondition}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyBoundaryConditions-Tuple{Problem, Vector{BoundaryCondition}}","page":"Linear","title":"LowLevelFEM.applyBoundaryConditions","text":"applyBoundaryConditions(problem::Problem, supports::Vector{BoundaryCondition})\n\nCreate a ScalarField, VectorField or TensorField and applies the boundary  conditions supports on it. Mesh details are in problem. supports is BoundaryCondition.\n\nReturns: ScalarField, VectorField or TensorField\n\nTypes:\n\nproblem: Problem\nsupports: Vector{BoundaryCondition}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}","page":"Linear","title":"LowLevelFEM.applyElasticSupport!","text":"applyElasticSupport!(stiffMat, elastSupp)\n\nApplies elastic support boundary conditions elastSupp on a stiffness matrix stiffMat. Mesh details are in problem. elastSupp is a tuple of name of physical group and prescribed kx, ky and kz stiffnesses.\n\nReturns: nothing\n\nTypes:\n\nstiffMat: SystemMatrix \nelastSupp: Vector{BoundaryCondition}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}","page":"Linear","title":"LowLevelFEM.dampingMatrix","text":"dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)\n\nGenerates the damping matrix for proportional damping. C = αM + βK, or C = αM + β₁K + β₂KM⁻¹K + β₃KM⁻¹KM⁻¹K + ⋯. The latter corresponds to a damping characteristic given by a power series in the natural frequencies with odd exponents. ξᵢ (ξ in the arguments) are the values of the individual terms of the series at ωₘₐₓ. βᵢ (β in the arguments) are the coefficients of the series. Either ξ or β must be specified; each may be a scalar or a vector. K is the stiffness matrix, M is the mass matrix, and ωₘₐₓ is the largest natural frequency.\n\nReturns: dampingMatrix\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nωₘₐₓ: Float64\nα: Float64\nξ: Float64 or Vector{Float64}\nβ: Float64 or Vector{Float64}\ndampingMatrix: SystemMatrix\n\nExamples\n\nK = stiffnessMatrix(problem)\nM = massMatrix(problem; lumped=true)\nωmax = 2π * 1000\nC = dampingMatrix(K, M, ωmax; α=0.0, ξ=[0.02, 0.02])\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.elasticSupportMatrix","text":"elasticSupportMatrix(problem, elSupp)\n\nSolves the elastic support matrix of the problem. elSupp is a vector of elastic supports defined in function elasticSupport. With the displacementent vector q in hand the reaction force vector fR arising from the elastic support can be solved. (fR = heatConvMat * q)\n\nReturn: elSuppMat\n\nTypes:\n\nproblem: Problem\nelSupp: Vector{BoundaryCondition}\nelSuppMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialDisplacement!","text":"initialDisplacement!(u0, name; ux=..., uy=..., uz=...)\n\nChanges the displacement values to ux, uy and uz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in displacement vector u0.\n\nReturn: nothing\n\nTypes:\n\nname: String \nux: Float64 \nuy: Float64 \nuz: Float64 \nu0: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialDisplacement-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialDisplacement","text":"initialDisplacement(problem, name; ux=..., uy=..., uz=...)\n\nSets the displacement values ux, uy and uz (depending on the dimension of the problem) at nodes belonging to physical group name. Returns the initial displacement vector u0.\n\nReturn: u0\n\nTypes:\n\nproblem: Problem\nname: String \nu0: VectorField\nux: Float64 \nuy: Float64 \nuz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialVelocity!-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialVelocity!","text":"initialVelocity!(v0, name; vx=..., vy=..., vz=...)\n\nChanges the velocity values vx, vy and vz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in velocity vector v0.\n\nReturns: nothing\n\nTypes:\n\nname: String \nv0: VectorField\nvx: Float64 \nvy: Float64 \nvz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialVelocity-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialVelocity","text":"initialVelocity(problem, name; vx=..., vy=..., vz=...)\n\nSets the velocity values vx, vy and vz (depending on the dimension of the problem) at nodes belonging to physical group name. Returns the initial velocity vector v0.\n\nReturn: v0\n\nTypes:\n\nproblem: Problem\nname: String \nvx: Float64 \nvy: Float64 \nvz: Float64 \nv0: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.largestEigenValue-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix}","page":"Linear","title":"LowLevelFEM.largestEigenValue","text":"largestEigenValue(K, M)\n\nSolves the smallest eigenvalue for a transient problem given by stiffness (heat conduction) matrix K and the mass (heat capacity) matrix M (C).\n\nReturn: λₘᵢₙ\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nλₘᵢₙ: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.largestPeriodTime","text":"largestPeriodTime(K, M, bc)\n\nSolves the largest period of time for a dynamic problem given by stiffness matrix K and the mass matrix M, bc is a vector of BoundaryCondition where the displacement is given.\n\nReturn: Δt\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nbc: Vector{BoundaryCondition}\nΔt: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.loadVector-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.loadVector","text":"loadVector(problem, loads)\n\nAssembles the right-hand-side vector associated with external mechanical loads in weak-form finite element problems.\n\nDepending on the problem dimension and the dimension of the physical group, this function handles concentrated forces, line/surface/volume loads, tractions, pressures, and body forces in 1D, 2D, and 3D.\n\nThe interpretation of the physical group dimension is:\n\n1D problems:\nPoint  → concentrated force\nLine   → distributed force\n2D problems:\nPoint  → concentrated force\nLine   → surface force\nSurface → body force\n3D problems:\nPoint  → concentrated force\nLine   → edge force\nSurface → surface force\nVolume → body force\n\nLoad components may be specified as constants, spatial functions, or ScalarFields (nodal type). Axisymmetric and other weighted formulations can be handled by including the appropriate geometric factor (e.g. 2πr) in the load definition or coefficient.\n\nReturns a VectorField for vector-valued problems (pdim > 1) and a ScalarField for scalar problems (pdim == 1).\n\nReturn: loadVec\n\nTypes:\n\nproblem: Problem\nloads: Vector{BoundaryCondition}\nloadVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.massMatrix-Tuple{Any}","page":"Linear","title":"LowLevelFEM.massMatrix","text":"massMatrix(problem; lumped=...)\n\nSolves the mass matrix of the problem. If lumped is true, computes the lumped mass matrix.\n\nReturns: massMat\n\nTypes:\n\nproblem: Problem\nlumped: Boolean\nmassMat: SystemMatrix\n\nExamples\n\nM = massMatrix(problem; lumped=true)\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}","page":"Linear","title":"LowLevelFEM.nonLinearStiffnessMatrix","text":"nonLinearStiffnessMatrix(problem, q)\n\nSolves the nonlinear stiffness matrix of the problem. q is a displacement field.\n\nReturns: stiffMat\n\nTypes:\n\nproblem: Problem\nq: VectorField\nstiffMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.printElasticConstantsTable-Tuple{}","page":"Linear","title":"LowLevelFEM.printElasticConstantsTable","text":"printElasticConstantsTable(; io::IO=stdout)\n\nPrints a compact reference table of the most common relations between isotropic linear-elastic material constants:\n\nYoung's modulus E\nPoisson's ratio ν\nShear modulus G (also denoted as μ)\nBulk modulus K\nLamé's first parameter λ\nLamé's second parameter μ (= G)\n\nThe table is meant as a quick cheat-sheet for documentation / teaching.\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.smallestEigenValue-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix}","page":"Linear","title":"LowLevelFEM.smallestEigenValue","text":"smallestEigenValue(K, M)\n\nSolves the largest eigenvalue for a transient problem given by stiffness (heat conduction) matrix K and the mass (heat capacity) matrix M (C).\n\nReturn: λₘₐₓ\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nλₘₐₓ: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.smallestPeriodTime","text":"smallestPeriodTime(K, M, support=[])\n\nSolves the smallest period of time for a dynamic problem given by stiffness matrix K and the mass matrix M, support is a vector of BoundaryCondition where the displacement is given.\n\nReturn: Δt\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nsupport: Vector{BoundaryCondition}\nΔt: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveAxialForce-Tuple{VectorField}","page":"Linear","title":"LowLevelFEM.solveAxialForce","text":"solveAxialForce(u::VectorField)\n\nCompute axial (bar/truss) forces from a displacement field.\n\nThe input displacement field u must be nodal (VectorField), typically containing the nodal displacements of a truss or bar structure.   The output is a scalar field (ScalarField), where each value represents  the axial force in a truss element.\n\nArguments\n\nu::VectorField: nodal displacement field.\n\nReturns\n\nScalarField: axial forces defined per element.\n\nExamples\n\nu = solveDisplacement(problem, load=[loads], support=[supports])  # VectorField of nodal displacements\nN = solveAxialForce(u)                               # ScalarField of axial element forces\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveBuckling-Tuple{Any}","page":"Linear","title":"LowLevelFEM.solveBuckling","text":"solveBuckling(problem; load=[], support=[], n=6)\n\nSolves the multipliers for the first n critical forces and the corresponding  buckling shapes for the instability of the problem, when loads and  support are applied. Result can be presented by showBucklingResults function. loads and support can be defined by load and displacementConstraint functions, respectively.\n\nReturn: buckling\n\nTypes:\n\nproblem: Problem\nload: Vector{BoundaryCondition}\nsupport: Vector{BoundaryCondition}\nn: Int64\nbuckling: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.solveBucklingModes","text":"solveBucklingModes(K, Knl; n=6)\n\nSolves the critical force multipliers and buckling mode shapes of a problem given by stiffness matrix K and the nonlinear stiffness matrix Knl. n is the number of buckling modes to solve. Returns the struct of critical forces and buckling modes. Results can be presented by showBucklingResults function.\n\nReturn: modes\n\nTypes:\n\nK: SystemMatrix\nKnl: SystemMatrix\nn: Int64\nmodes: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveDisplacement-Tuple{LowLevelFEM.SystemMatrix, VectorField}","page":"Linear","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(K, f; support = BoundaryCondition[],\n                  iterative = false,\n                  reltol = sqrt(eps()),\n                  maxiter = K.model.non * K.model.dim,\n                  preconditioner = Identity(),\n                  ordering = true)\n\nSolves the linear system\n\nK * u = f\n\nfor the displacement vector u, where K is a stiffness matrix and f is the load vector. Essential (Dirichlet) boundary conditions are imposed via the support argument.\n\nThis is a low-level solver operating directly on a preassembled [SystemMatrix] and load [VectorField]. It assumes that the stiffness matrix already includes all material contributions (and optional elastic supports).\n\nIf iterative = true, the reduced system is solved using the conjugate gradient method. Otherwise, a direct solver is used.\n\nArguments\n\nK::SystemMatrix: Assembled stiffness matrix associated with a [Problem].\nf::VectorField: Load vector.\nsupport::Vector{BoundaryCondition} (keyword, optional): Essential boundary conditions (Dirichlet-type constraints). Default is an empty vector (no supports).\niterative::Bool (keyword): If true, uses the conjugate gradient method.\nreltol::Real (keyword): Relative tolerance for the iterative solver.\nmaxiter::Int (keyword): Maximum number of iterations for the iterative solver.\npreconditioner (keyword): Preconditioner object for iterative solution (e.g. from ilu or ichol).\nordering::Bool (keyword): If false, disables column reordering in the direct solver (lu(A, q=nothing)).\n\nReturns\n\nu::VectorField: Displacement vector satisfying the prescribed boundary conditions.\n\nNotes\n\nOnly the unconstrained degrees of freedom are solved for; constrained values are imposed explicitly.\nThis function is primarily intended for internal or advanced use. Most users should prefer the high-level solveDisplacement(problem; ...) interface.\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveDisplacement-Tuple{Problem}","page":"Linear","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(problem;\n                  load = BoundaryCondition[],\n                  support = BoundaryCondition[],\n                  elasticSupport = BoundaryCondition[],\n                  condensed = true,\n                  iterative = false,\n                  reltol = sqrt(eps()),\n                  maxiter = problem.non * problem.dim,\n                  preconditioner = Identity(),\n                  ordering = true)\n\nComputes the displacement vector u for a given [Problem] subject to external loads, essential supports, and optional elastic supports.\n\nThe stiffness matrix is assembled internally. Depending on the value of condensed, either a reduced system (eliminating constrained degrees of freedom) or the full system with modified rows and columns is solved.\n\nThis is the high-level, user-facing displacement solver.\n\nArguments\n\nproblem::Problem: Finite element problem definition (geometry, materials, DOFs, etc.).\nload::Vector{BoundaryCondition} (keyword, optional): Prescribed nodal loads.\nsupport::Vector{BoundaryCondition} (keyword, optional): Essential (Dirichlet) boundary conditions.\nelasticSupport::Vector{BoundaryCondition} (keyword, optional): Elastic (spring-type) supports contributing to the stiffness matrix.\ncondensed::Bool (keyword): If true, solves the reduced system using only free degrees of freedom. If false, modifies the full system matrix explicitly.\niterative::Bool (keyword): If true, uses the conjugate gradient method.\nreltol::Real (keyword): Relative tolerance for the iterative solver.\nmaxiter::Int (keyword): Maximum number of iterations for the iterative solver.\npreconditioner (keyword): Preconditioner object for iterative solution (e.g. from ilu or ichol).\nordering::Bool (keyword): If false, disables column reordering in the direct solver (lu(A, q=nothing)).\n\nReturns\n\nu::VectorField: Displacement vector defined on the problem degrees of freedom.\n\nNotes\n\nIf problem.type == :dummy, the function returns nothing.\nWhen condensed = true, constrained DOFs are eliminated algebraically.\nWhen condensed = false, constrained rows and columns are modified explicitly.\nThis function internally calls the low-level solveDisplacement(K, f; ...) routine after assembling the stiffness matrix and load vector.\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveEigenModes-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.solveEigenModes","text":"solveEigenModes(K, M; n=6, fₘᵢₙ=1.01)\n\nSolves the eigen frequencies and mode shapes of a problem given by stiffness matrix K and the mass matrix M. n is the number of eigenfrequencies to solve, and solves the eigenfrequencies greater than fₘᵢₙ. Returns the struct of eigenfrequencies and eigen modes. Results can be presented by showModalResults function.\n\nReturn: modes\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nn: Int64\nfₘᵢₙ: Float64\nmodes: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveModalAnalysis-Tuple{Any}","page":"Linear","title":"LowLevelFEM.solveModalAnalysis","text":"solveModalAnalysis(problem; support=[]; load=[], n=6, fₘᵢₙ=0.00001, directSolver=false)\n\nSolves the first n eigenfrequencies and the corresponding  mode shapes for the problem, when load and  support are applied. load and contraints are optional.  Result can be presented by showModalResults function.  load and support can be defined by load and displacementConstraint functions, respectively. If load are given, it solves the eigenfrequencies of a prestressed structure.\n\nReturn: modes\n\nTypes:\n\nproblem: Problem\nload: Vector{tuples}\nsupport: Vector{tuples}\nn: Int64\nmodes: Eigen\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveStrain-Tuple{Any}","page":"Linear","title":"LowLevelFEM.solveStrain","text":"solveStrain(q; DoFResults=false)\n\nSolves the strain field E from displacement vector q. Strain field is given per elements, so it usually contains jumps at the boundaries of elements. Details of mesh is available in problem. If DoFResults is true, E is a matrix with nodal results. In this case showDoFResults can be used to show the results  (otherwise showStrainResults or showElementResults).\n\nReturn: E\n\nTypes:\n\nq: VectorField\nE: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveStress-Tuple{VectorField}","page":"Linear","title":"LowLevelFEM.solveStress","text":"solveStress(q; T=..., T₀=..., DoFResults=false)\n\nSolves the stress field S from displacement vector q. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in problem. If DoFResults is true, S is a matrix with nodal results. In this case showDoFResults can be used to show the results  (otherwise showStressResults or showElementResults). If the T temperature field (and T₀ initial temperature field if it differs from zero) is given, the function solves also the thermal stresses.\n\nReturn: S\n\nTypes:\n\nq: VectorField\nT: ScalarField\nT₀: ScalarField\nS: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.stiffnessMatrix-Tuple{Any}","page":"Linear","title":"LowLevelFEM.stiffnessMatrix","text":"stiffnessMatrix(problem; forceOneThread=true)\n\nSolves the stiffness matrix of the problem.\n\nReturns: stiffMat\n\nTypes:\n\nproblem: Problem\nstiffMat: SystemMatrix\n\nExamples\n\nK = stiffnessMatrix(problem)\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#Poisson-type-operators","page":"Poisson operators","title":"Poisson-type operators","text":"","category":"section"},{"location":"Poisson/#LowLevelFEM.advectionMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.advectionMatrix","text":"advectionMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0, dir::Int=1)\n∫N_c_∂N∂x_dΩ(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n∫N_c_∂N∂y_dΩ(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n∫N_c_∂N∂z_dΩ(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the global convection (advection/drift) matrix\n\n\nC_ab = ∫_Ω N_a (∂N_b/∂x_dir) β(x) dΩ\n\n\ndir=1 corresponds to x, dir=2 to y, dir=3 to z (when available).\ncoefficient can be a constant (Number) or an elementwise ScalarField, interpolated to Gauss points as in the stiffness implementation.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.curlCurlMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.curlCurlMatrix","text":"curlCurlMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n∫∇xN_c_∇xN_dΩ(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the global curl–curl matrix\n\n\nC(u,v) = ∫_Ω (∇×u) · (∇×v) α(x) dΩ\n\n\nNotes\n\nRequires problem.pdim == problem.dim (vector field).\nUses standard Lagrange H¹ elements (NOT H(curl)-conforming).\nIntended for operator studies, stabilization terms, and educational use.\nNot suitable as a primary operator for Maxwell-type problems.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.gradDivMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.gradDivMatrix","text":"gradDivMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n∫∇N_c_∇N_dΩ(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the global matrix corresponding to the grad-div bilinear form\n\n\nG_ab = ∫_Ω (∇·u_h) (∇·v_h) α(x) dΩ\n\n\nThis is the weak form associated with the operator ∇(∇·u) (up to sign conventions), commonly appearing in linear elasticity and in grad-div stabilization.\n\nNotes\n\nRequires problem.pdim == problem.dim (vector unknown with one component per spatial dimension).\ncoefficient can be a constant (Number) or an elementwise ScalarField, interpolated to Gauss points using the Lagrange basis (same mechanism as in poissonMatrix).\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.gradMatrix-Tuple{Problem, Problem}","page":"Poisson operators","title":"LowLevelFEM.gradMatrix","text":"gradMatrix(problem_u::Problem, problem_p::Problem)\n\nAssembles the mixed gradient matrix G mapping a scalar field (pressure) to a vector field (velocity), corresponding to the weak form\n\n(G p, v) = -∫_Ω p ∇·v dΩ\n\nNotes\n\nRequires problemu.pdim == problemu.dim (vector field).\nRequires problem_p.pdim == 1 (scalar field).\nRequires problemu.dim == problemp.dim.\nThe divergence matrix is obtained as D = -G'.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.loadTensor-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.loadTensor","text":"loadTensor(problem::Problem;\n           source::Union{Matrix{Float64},TensorField} = zeros(3,3))\n\nAssembles an L2 right-hand-side vector for tensor-valued problems (pdim = 9):\n\nf_{a,α} = ∫_Ω N_a(x) * S_α(x) dΩ\n\nwhere S is either\n\na constant 3×3 tensor (Matrix{Float64}), or\na nodal TensorField.\n\nNotes\n\nIntended for Beltrami–Michell and other stress-based formulations.\nNo traction, pressure, or surface force interpretation.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.navierStokesAdvectionMatrix-Tuple{Problem, Any}","page":"Poisson operators","title":"LowLevelFEM.navierStokesAdvectionMatrix","text":"navierStokesAdvectionMatrix(problem::Problem, u;\n                            time_index::Int = 1)\n\nAssembles the (linearized) Navier–Stokes convection operator in Oseen/Picard form:\n\nC(w,v) = ∫_Ω (u·∇)w · v dΩ\n\nwhere u is a given velocity field (the coefficient), w is the unknown velocity, and v is the test function.\n\nMatrix size:\n\nproblem.pdim == problem.dim is required (vector field).\nReturns a SystemMatrix of size (dimN) × (dimN).\n\nArguments\n\nproblem::Problem: Must represent the velocity unknown (vector field).\nu: Given advection velocity in the SAME dof ordering as VectorField uses: [u1x,u1y(,u1z), u2x,u2y(,u2z), ...]. Accepted forms:\nVectorField (nodal, same mesh)\nAbstractVector{<:Real} (length = dim*problem.non)\n\nKeyword arguments\n\ntime_index: If u stores multiple time steps internally (e.g. as a matrix), you can select which column to use. For plain vectors it is ignored.\n\nNotes\n\nThis is NOT the scalar advectionMatrix. This operator uses the given velocity u inside the Gauss integration, assembled in ONE pass (no splitting to 3 scalar fields).\nThe resulting operator is block-diagonal by velocity components (no component mixing), consistent with (u·∇) acting component-wise in Cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.poissonMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.poissonMatrix","text":"poissonMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n∫∇oN_c_∇oN_dΩ(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the global stiffness matrix for a Poisson-type diffusion operator\n\n\nK_ab = ∫_Ω (∇N_a · ∇N_b) α(x) dΩ\n\n\ncoefficient can be a constant (Number) or an elementwise ScalarField (interpolated to Gauss points using the Lagrange basis, as in the original implementation).\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.reactionMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.reactionMatrix","text":"reactionMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n∫N_c_N_dΩ(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the global (weighted) mass / reaction matrix\n\n\nM_ab = ∫_Ω N_a N_b c(x) dΩ\n\n\ncoefficient can be a constant (Number) or an elementwise ScalarField, interpolated to Gauss points using the Lagrange basis (same mechanism as stiffness).\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.solveField-Tuple{LowLevelFEM.SystemMatrix, Union{ScalarField, VectorField}}","page":"Poisson operators","title":"LowLevelFEM.solveField","text":"solveField(K, f; support=BoundaryCondition[], iterative=false,\n           reltol=sqrt(eps()), maxiter=..., preconditioner=Identity(),\n           ordering=true)\n\nSolves a linear static field problem with Dirichlet boundary conditions.\n\nThe algebraic system\n\n\nK * u = f\n\n\nis solved for the unknown field u, where prescribed values are enforced solver-side via boundary conditions.\n\nThe solution is obtained by partitioning the degrees of freedom into free and constrained sets. On constrained DOFs the values prescribed by support override the solution, while on free DOFs the reduced system is solved:\n\n\nK_ff * u_f = f_f − K_fc * u_c\n\n\nThe function supports both direct and iterative linear solvers and works uniformly for ScalarField and VectorField unknowns.\n\n\n\nArguments\n\nK::SystemMatrix   Global system matrix.\nf::Union{ScalarField,VectorField}   Right-hand-side vector.\nsupport::Vector{BoundaryCondition} (keyword, default = BoundaryCondition[])   Dirichlet-type boundary conditions.\niterative::Bool (keyword, default = false)   If true, use an iterative solver (conjugate gradient).\nreltol::Real (keyword, default = sqrt(eps()))   Relative tolerance for the iterative solver.\nmaxiter::Int (keyword, default = K.model.non * K.model.dim)   Maximum number of iterations for the iterative solver.\npreconditioner (keyword, default = Identity())   Preconditioner for the iterative solver.\nordering::Bool (keyword, default = true)   If false, use an explicit LU factorization without reordering.\n\n\n\nReturns\n\nu::Union{ScalarField,VectorField}   Solution field with prescribed values enforced on constrained DOFs.\n\n\n\nNotes\n\nBoundary conditions are applied inside the solver; the input field f is not modified.\nThe algorithm itself is agnostic to the physical meaning of the field (scalar, vector, tensor), as long as K and f are dimensionally consistent.\nWhen iterative = true, the system is solved using conjugate gradient on the reduced matrix K_ff.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.sourceVector","page":"Poisson operators","title":"LowLevelFEM.sourceVector","text":"sourceVector(problem, sources)\n\nAssembles the right-hand-side vector corresponding to a volumetric source term in Poisson-type and other scalar or vector-valued PDEs expressed in weak form.\n\nMathematically, this function assembles\n\nf_a = ∫_Ω N_a f dΩ\n\nwhere the source term f may be given as a constant, a spatial function, or a ScalarField.\n\nThis function is an alias of loadVector and shares the same implementation. The difference is purely interpretational: sourceVector emphasizes the role of the right-hand side as a PDE source term rather than a mechanical load.\n\nAxisymmetric or spherically symmetric problems can be handled by including the appropriate geometric weighting (e.g. 2πr, 4πr²) as a coefficient field.\n\nIn LowLevelFEM, right-hand-side vectors are assembled independently of the governing equation. The same numerical machinery can therefore represent mechanical loads, heat sources, or generic PDE source terms.\n\nReturns a ScalarField or VectorField, depending on the problem field dimension.\n\n\n\n\n\n","category":"function"},{"location":"Poisson/#LowLevelFEM.symmetricGradientMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.symmetricGradientMatrix","text":"symmetricGradientMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the global matrix for the symmetric-gradient (strain) bilinear form\n\n\nA(u,v) = ∫_Ω 2μ ε(u) : ε(v) dΩ\nε(u)   = 1/2 (∇u + ∇uᵀ)\n\n\nNotes\n\nRequires problem.pdim == problem.dim.\ncoefficient is typically the shear modulus μ (constant or ScalarField).\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.tensorDivDivMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.tensorDivDivMatrix","text":"tensorDivDivMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the tensor div–div matrix\n\n\nD(σ,τ) = ∫_Ω (∇·σ_h) · (∇·τ_h) α(x) dΩ\n\n\nNotes\n\nRequires problem.pdim == dim^2 (second-order tensor field).\nActs as an equilibrium-enforcing operator in stress-based formulations (e.g. Beltrami–Michell).\ncoefficient may be a constant (Number) or an elementwise ScalarField.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.tensorLaplaceMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.tensorLaplaceMatrix","text":"tensorLaplaceMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the tensor Laplace operator\n\n∫_Ω ∇(sym σ) : ∇(sym τ) dΩ\n\nfor a nodal TensorField with pdim = 9.\n\nNotes\n\nOperator is restricted to the symmetric tensor subspace.\ncoefficient may be constant or an elementwise ScalarField.\n\n\n\n\n\n","category":"method"},{"location":"Poisson/#LowLevelFEM.traceLaplaceMatrix-Tuple{Problem}","page":"Poisson operators","title":"LowLevelFEM.traceLaplaceMatrix","text":"traceLaplaceMatrix(problem::Problem; coefficient::Union{Number,ScalarField}=1.0)\n\nAssembles the trace Laplace operator\n\n∫_Ω ∇tr(σ) · ∇tr(τ) dΩ\n\nfor a nodal TensorField with pdim = 9.\n\n\n\n\n\n","category":"method"},{"location":"news/2025-11-12_announcement/#November-2025-–-Package-Announcement","page":"November 2025 – Package Announcement","title":"November 2025 – Package Announcement","text":"","category":"section"},{"location":"news/2025-11-12_announcement/","page":"November 2025 – Package Announcement","title":"November 2025 – Package Announcement","text":"We are happy to announce that LowLevelFEM.jl is now officially available in the Julia General Registry! 🎉","category":"page"},{"location":"news/2025-11-12_announcement/","page":"November 2025 – Package Announcement","title":"November 2025 – Package Announcement","text":"The package provides a lightweight and transparent FEM environment written entirely in Julia.   It supports:","category":"page"},{"location":"news/2025-11-12_announcement/","page":"November 2025 – Package Announcement","title":"November 2025 – Package Announcement","text":"2D and 3D solid mechanics (plane stress/strain, axisymmetric, and full 3D)\nHeat conduction and thermo-mechanical coupling\nGmsh integration for pre- and post-processing","category":"page"},{"location":"news/2025-11-12_announcement/","page":"November 2025 – Package Announcement","title":"November 2025 – Package Announcement","text":"Unlike symbolic DSL-based FEM frameworks, LowLevelFEM gives you full control over assembly, boundary conditions, and solution steps — ideal for teaching, research, and method development.","category":"page"},{"location":"news/2025-11-12_announcement/","page":"November 2025 – Package Announcement","title":"November 2025 – Package Announcement","text":"📚 Documentation   🗣 Original announcement on Julia Discourse","category":"page"},{"location":"news/2025-11-12_announcement/","page":"November 2025 – Package Announcement","title":"November 2025 – Package Announcement","text":"Stay tuned for upcoming examples and performance notes in future posts!","category":"page"},{"location":"Heat/#Heat-Conduction","page":"Heat","title":"Heat Conduction","text":"","category":"section"},{"location":"Heat/#LowLevelFEM.FDM-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Union{ScalarField, VectorField}, Vector{BoundaryCondition}, Union{ScalarField, VectorField}, Int64, Float64}","page":"Heat","title":"LowLevelFEM.FDM","text":"FDM(K, C, q, bc, T0, n, Δt; ϑ=0.5)\n\nSolves a transient diffusion-type problem (e.g. heat conduction) using the finite difference method in time (ϑ-method).\n\nThe semi-discrete system\n\n\nC * Ẋ(t) + K * X(t) = q(t)\n\n\nis integrated in time using the ϑ-scheme:\n\nϑ = 0   : Forward Euler (explicit)\nϑ = 1/2 : Crank–Nicolson\nϑ = 1   : Backward Euler (implicit)\n0 < ϑ < 1 : intermediate schemes\n\nThe method supports:\n\ntime-independent or time-dependent load vectors q\ntime-independent or time-dependent Dirichlet boundary conditions\nScalarField and VectorField unknowns\nconsistent treatment of constraint-induced volume terms (i.e. contributions of prescribed values appear automatically in the RHS)\n\nBoundary conditions are applied solver-side: on constrained DOFs the prescribed values override the initial condition, while on free DOFs the initial condition T0 is used.\n\nIf q.nsteps == 1, the load is treated as time-independent. If q.nsteps == n, a true ϑ-weighted load\n\n\nq^{n+ϑ} = (1-ϑ) q^n + ϑ q^{n+1}\n\n\nis used.\n\nFor ϑ = 0 and diagonal C, a fully explicit update is used.\n\n\n\nArguments\n\nK::SystemMatrix   Diffusion (conductivity / stiffness) matrix.\nC::SystemMatrix   Capacity (mass / heat capacity) matrix.\nq::Union{ScalarField,VectorField}   Load / source vector. May be time-independent (nsteps = 1) or time-dependent (nsteps = n).\nbc::Vector{BoundaryCondition}   Dirichlet boundary conditions (possibly time-dependent).\nT0::Union{ScalarField,VectorField}   Initial condition. On constrained DOFs this is overridden by bc.\nn::Int   Number of time steps.\nΔt::Float64   Time step size.\nϑ::Float64 (keyword, default = 0.5)   Parameter of the ϑ-method.\n\n\n\nReturns\n\nT::Union{ScalarField,VectorField}   Nodal solution field at all time steps (ndof × nsteps), with time vector t = 0:Δt:(n-1)Δt.\n\n\n\nNotes\n\nStability depends on ϑ and the spectrum of the generalized eigenproblem K x = λ C x. For ϑ ≥ 1/2 the method is unconditionally stable.\nThe algorithm itself is agnostic to the physical meaning of the field (scalar, vector, tensor), as long as K, C and the fields are consistent.\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.applyHeatConvection!-Tuple{Any, Any, Any}","page":"Heat","title":"LowLevelFEM.applyHeatConvection!","text":"applyHeatConvection!(heatCondMat, heatFluxVec, heatConv)\n\nApplies heat convectiom boundary conditions heatConv on a heat conduction matrix heatCondMat and heat flux vector heatFluxVec. Mesh details are in problem. heatConv is a tuple of name of physical group and prescribed heat transfer coefficient h and ambient temperature Tₐ. The ambient temperature can be either a constant or a  function of x, y and z coordinates.\n\nReturns: nothing\n\nTypes:\n\nproblem: Problem\nheatCondMat: SystemMatrix \nheatFluxVec: VectorField\nheatConv: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatCapacityMatrix-Tuple{Any}","page":"Heat","title":"LowLevelFEM.heatCapacityMatrix","text":"heatCapacityMatrix(problem; lumped=...)\n\nSolves the heat capacity matrix of the problem. If lumped is true, solves lumped heat capacity matrix.\n\nReturn: heatCapMat\n\nTypes:\n\nproblem: Problem\nlumped: Boolean\nmassMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatConductionMatrix-Tuple{Any}","page":"Heat","title":"LowLevelFEM.heatConductionMatrix","text":"heatConductionMatrix(problem)\n\nSolves the heat conduction matrix of the problem.\n\nReturns: heatCondMat\n\nTypes:\n\nproblem: Problem\nheatCondMat: SystemMatrix\n\nExamples\n\nKth = heatConductionMatrix(problem)\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatConvectionMatrix","text":"heatConvectionMatrix(problem, heatConvection)\n\nSolves the heat convection matrix of the problem. heatConvection  is a vector of heat convection boundary condicions defined in function heatConduction. With the heat convection vector (see the heatConvectionVector function) heatConvVec, temperature field vector T in hand the heat flux vector qCV arising from the heat convection boundary condition can be solved. qCV = heatConvMat * T - heatConvVec\n\nReturn: heatConvMat\n\nTypes:\n\nproblem: Problem\nheatConvection: Vector{Tuple{String, Float64, Float64, Float64}}\nheatConvMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatConvectionVector-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatConvectionVector","text":"heatConvectionVector(problem, heatConvection)\n\nSolves a heat convection vector of problem. heatConvection  is a vector of heat convection boundary condicions defined in function heatConduction. With the heat convection matrix (see the heatConvectionMatrix function) heatConvMat, temperature field vector T in hand the heat flux vector qCV arising from the heat convection boundary condition can be solved. qCV = heatConvMat * T - heatConvVec\n\nReturn: heatConvVec\n\nTypes:\n\nproblem: Problem\nheatConvection: Vector{Tuple{String, Float64, Float64, Float64}}\nheatConvVec: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatFluxVector-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatFluxVector","text":"heatFluxVector(problem, heatFlux)\n\nSolves a heat flux or heat source vector of problem. heatFlux is a tuple of name of physical group  name, heat flux qn normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated heat flux.\nIn case of 2D problems and Line physical group means surface heat flux.\nIn case of 2D problems and Surface physical group means body heat source.\nIn case of 3D problems and Point physical group means concentrated heat flux.\nIn case of 3D problems and Line physical group means edge heat source.\nIn case of 3D problems and Surface physical group means surface heat flux.\nIn case of 3D problems and Volume physical group means body heat source.\n\nReturn: heatFluxVec\n\nTypes:\n\nproblem: Problem\nheatFlux: Vector{Tuple{String, Float64, Float64, Float64}}\nheatFluxVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatSourceVector-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatSourceVector","text":"heatSourceVector(problem, heatSource)\n\nSolves a heat flux or heat source vector of problem. heatSource is a tuple of name of physical group  name, heat flux qn normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated heat flux.\nIn case of 2D problems and Line physical group means surface heat flux.\nIn case of 2D problems and Surface physical group means body heat source.\nIn case of 3D problems and Point physical group means concentrated heat flux.\nIn case of 3D problems and Line physical group means edge heat source.\nIn case of 3D problems and Surface physical group means surface heat flux.\nIn case of 3D problems and Volume physical group means body heat source.\n\nSame as the heatFluxVector function.\n\nReturn: heatSourceVec\n\nTypes:\n\nproblem: Problem\nheatSource: Vector{Tuple{String, Float64, Float64, Float64}}\nheatSourceVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.initialTemperature!-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.initialTemperature!","text":"initialTemperature!(T0, name; T=...)\n\nChanges the tempetature value to T at nodes belonging to physical group name. Original values are in temperature vector T0.\n\nReturns: nothing\n\nTypes:\n\nname: String \nT0: ScalarField\nT: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.initialTemperature-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.initialTemperature","text":"initialTemperature(problem, name; T=...)\n\nSets the temperature value T at nodes belonging to physical group name. Returns the T0 initial nodal temperature vector.\n\nReturn: T0\n\nTypes:\n\nproblem: Problem\nname: String \nT: Float64 \nT0: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}","page":"Heat","title":"LowLevelFEM.latentHeatMatrix","text":"latentHeatMatrix(problem, u, v, T0)\n\nSolves the latent heat matrix of the problem. With this matrix the generated heat due to deformations (given with displacement field u and velocity field v) can be solved. T0 is the current temperature field which is given in absolute temperature scale (Kelvin).\n\nReturn: latHeatMat\n\nTypes:\n\nproblem: Problem\nu: VectorField\nv: VectorField\nT0: ScalarField\nlatHeatMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveHeatFlux-Tuple{Any}","page":"Heat","title":"LowLevelFEM.solveHeatFlux","text":"solveHeatFlux(T; DoFResults=false)\n\nSolves the heat flux field q from temperature vector T. heat flux is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in problem. If DoFResults is true, q is a matrix with nodal results. In this case showDoFResults can be used to show the results (otherwise showHeatFluxResults or showElementResults).\n\nReturn: q\n\nTypes:\n\nproblem: Problem\nT: ScalarField\nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveTemperature-Tuple{Any, VectorField}","page":"Heat","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem, u; T0=273.0)\n\nSolves the raise of temperature T during reversible (no dissipation) elastic deformations, where u is the displacement field, and problem is a heat cunduction problem.\n\nReturn: T\n\nTypes:\n\nproblem: Problem \nu: VectorField \nT0: Float64\nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, ScalarField}","page":"Heat","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(K, q;\n                 temperatureConstraint = [])\n\nSolves the linear heat conduction problem\n\nK * T = q\n\nfor the temperature field T, where K is the assembled heat conduction matrix and q is the heat flux (load) vector. Essential temperature constraints (Dirichlet-type boundary conditions) are imposed via temperatureConstraint.\n\nThis is a low-level temperature solver operating directly on a preassembled [SystemMatrix] and a heat flux [ScalarField]. It assumes that the system matrix already contains all material contributions.\n\nArguments\n\nK::SystemMatrix: Assembled heat conduction matrix associated with a [Problem].\nq::ScalarField: Heat flux vector (right-hand side of the heat equation).\ntemperatureConstraint::Vector{BoundaryCondition} (keyword, optional): Prescribed temperature constraints (Dirichlet boundary conditions). Default is an empty vector (no temperature constraints).\n\nReturns\n\nT::ScalarField: Temperature field satisfying the prescribed constraints.\n\nNotes\n\nOnly the unconstrained degrees of freedom are solved for; constrained values are imposed explicitly.\nThis function is primarily intended for internal or advanced use. Most users should prefer the high-level solveTemperature(problem; ...) interface.\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveTemperature-Tuple{Problem}","page":"Heat","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem;\n                 heatFlux = BoundaryCondition[],\n                 temperatureConstraint = BoundaryCondition[],\n                 heatConvection = BoundaryCondition[])\n\nComputes the temperature field T for a given [Problem] subject to prescribed heat fluxes, temperature constraints, and optional heat convection boundary conditions.\n\nThe heat conduction matrix and load vector are assembled internally. Heat convection terms, if present, are incorporated into the system before solving.\n\nThis is the high-level, user-facing temperature solver.\n\nArguments\n\nproblem::Problem: Finite element heat transfer problem definition.\nheatFlux::Vector{BoundaryCondition} (keyword, optional): Prescribed heat flux boundary conditions.\ntemperatureConstraint::Vector{BoundaryCondition} (keyword, optional): Prescribed temperature constraints (Dirichlet boundary conditions).\nheatConvection::Vector{BoundaryCondition} (keyword, optional): Heat convection boundary conditions contributing to both the system matrix and the load vector.\n\nReturns\n\nT::ScalarField: Temperature field defined on the problem degrees of freedom.\n\nNotes\n\nTemperature constraints are enforced by eliminating constrained degrees of freedom from the linear system.\nHeat convection terms are added to the conduction matrix and load vector via applyHeatConvection!.\nThis function internally assembles the heat conduction matrix and heat flux vector, then solves the reduced linear system.\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.thermalLoadVector-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.thermalLoadVector","text":"thermalLoadVector(problem, T; T₀=...)\n\nSolves the thermal load vector from a temperature field T for problem problem. T₀ is the initial temperature field. problem is an elastic problem.\n\nReturn: thermLoadVec\n\nTypes:\n\nproblem: Problem\nT: ScalarField\nT₀: ScalarField\nthermLoadVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/#2D-Cantilever","page":"Examples","title":"2D Cantilever","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ on deformed shape)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ and $\\tau_{yx}$ on path)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever2D.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\ngmsh.open(\"cantilever2D.geo\")\nmat = Material(\"body\", E=2e5, ν=0.3)\nproblem = Problem([mat], type=:PlaneStress)\n\nsupp = displacementConstraint(\"supp\", ux=0, uy=0)\nload1 = load(\"load\", fy=-1)\n\nq = solveDisplacement(problem, load=[load1], support=[supp])\nS = solveStress(q)\n\nu = showDoFResults(q, :uvec)\nux = showDoFResults(q, :ux)\nuy = showDoFResults(q, :uy)\n\ns = showStressResults(S, :s, visible=true, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\n\nplotOnPath(\"path\", sx, name=\"σx\", visible=false)\nplotOnPath(\"path\", sxy, name=\"τxy\", visible=false)\nplotOnPath(\"path\", ux, name=\"ux\", visible=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever2D.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"SetFactory(\"OpenCASCADE\");\n\nRectangle(1) = {0, 0, 0, 100, 10, 0};\n\nPhysical Curve(\"supp\", 5) = {4};\nPhysical Curve(\"load\", 6) = {2};\nPhysical Surface(\"body\", 7) = {1};\n\nRecombine Surface {1};\n\nTransfinite Line {2,4} = 4;\nTransfinite Line {1,3} = 31;\nTransfinite Surface {1};\n\nMesh.ElementOrder = 3;\n\nSetName \"cantilever2D\";\nMesh 2;\n\nPoint(5) = {10, 0, 0, 1.0};\nPoint(6) = {10, 10, 0, 1.0};\nLine(5) = {5, 6};\n\nPhysical Curve(\"path\", 8) = {5};","category":"page"},{"location":"Examples/#3D-Cantilever","page":"Examples","title":"3D Cantilever","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ on deformed shape)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever3D.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\ngmsh.open(\"cantilever3D.geo\")\nmat = material(\"body\", E=2e5, ν=0.3)\nproblem = Problem([mat])\n\nsupp = displacementConstraint(\"supp\", ux=0, uy=0, uz=0)\nld = load(\"load\", fy=-1)\n\nK = stiffnessMatrix(problem)\nf = loadVector(problem, [ld])\n\nq = solveDisplacement(K, f, support=[supp])\nS = solveStress(q)\n\nu = showDoFResults(q, :uvec, name=\"uvec\", visible=false)\nux = showDoFResults(q, :ux, name=\"ux\", visible=false)\nuy = showDoFResults(q, :uy, name=\"uy\", visible=false)\nuz = showDoFResults(q, :uz, name=\"uz\", visible=false)\n\ns = showStressResults(S, :s, name=\"σ\", visible=true, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = showStressResults(S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = showStressResults(S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = showStressResults(S, :szx, name=\"τzx\", visible=false, smooth=true)\n\nplotOnPath(\"path\", sx, name=\"σx\", visible=false)\nplotOnPath(\"path\", sxy, name=\"τxy\", visible=false)\nplotOnPath(\"path\", ux, name=\"ux\", visible=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever3D.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"SetFactory(\"OpenCASCADE\");\n\nBox(1) = {0, 0, 0, 100, 10, 10};\n\nPhysical Surface(\"supp\", 13) = {1};\nPhysical Surface(\"load\", 14) = {2};\nPhysical Volume(\"body\", 15) = {1};\n\nRecombine Surface {1:6};\n\nTransfinite Line {1:8} = 4;\nTransfinite Line {9:12} = 31;\nTransfinite Surface {1:6};\nTransfinite Volume {1};\n\nMesh.ElementOrder = 3;\n\nSetName \"cantilever3D\";\nMesh 3;\n\nPoint(9) = {10, 0, 5, 1.0};\nPoint(10) = {10, 10, 5, 1.0};\nLine(13) = {9, 10};\n\nPhysical Curve(\"path\", 16) = {13};","category":"page"},{"location":"Examples/#L-shaped-plate","page":"Examples","title":"L-shaped plate","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Mesh with a path for graphs)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Fillet)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Equivalent stress)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Equivalent stress on path)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n#gmsh.open(\"LshapedPlate.geo\")\ngmsh.open(\"LshapedPlate2.geo\")\n\nmat = Material(\"body\", E=2e5, ν=0.3)\nproblem = Problem([mat], type=:PlaneStress, thickness=1)\n\nbc1 = displacementConstraint(\"fix\", ux=0, uy=0)\nld1 = load(\"load\", fy=-1)\n\nK = stiffnessMatrix(problem)\nf = loadVector(problem, [ld1])\n\nq = solveDisplacement(K, f, support=[bc1])\nS = solveStress(q)\n\nu = showDoFResults(q, :uvec, name=\"uvec\", visible=false)\nux = showDoFResults(q, :ux, name=\"ux\", visible=false)\nuy = showDoFResults(q, :uy, name=\"uy\", visible=false)\nuz = showDoFResults(q, :uz, name=\"uz\", visible=false)\ns = showStressResults(S, :s, name=\"σ red\", visible=false, smooth=false)\nss = showStressResults(S, :s, name=\"σ red smooth\", visible=true, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = showStressResults(S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = showStressResults(S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = showStressResults(S, :szx, name=\"τzx\", visible=false, smooth=true)\n\nplotOnPath(\"path\", s, name=\"σred\", visible=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Point(1) = {0, 0, 0, 15.0};\nPoint(2) = {100, 0, 0, 15.0};\nPoint(3) = {100, 50, 0, 15.0};\nPoint(4) = {50, 50, 0, 0.5};\nPoint(5) = {50, 100, 0, 15.0};\nPoint(6) = {0, 100, 0, 15.0};\nLine(1) = {1, 2};\nLine(2) = {2, 3};\nLine(3) = {3, 4};\nLine(4) = {4, 5};\nLine(5) = {5, 6};\nLine(6) = {6, 1};\nCurve Loop(1) = {6, 1, 2, 3, 4, 5};\nPlane Surface(1) = {1};\n\nPhysical Curve(\"fix\", 7) = {5};\nPhysical Curve(\"load\", 8) = {2};\nPhysical Surface(\"body\", 11) = {1};\n\nSetName \"Lshape\";\n\nMesh.ElementOrder = 4;\nMesh.HighOrderOptimize = 1;\nMesh 2;\n\nPoint(7) = {0, 0, 0, 1.0};\nPoint(8) = {50, 50, 0, 1.0};\nLine(7) = {7, 8};\n\nPhysical Curve(\"path\", 9) = {7};","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate2.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"R=1;\n\nPoint(1) = {0, 0, 0, 15.0};\nPoint(2) = {100, 0, 0, 15.0};\nPoint(3) = {100, 50, 0, 15.0};\nPoint(4) = {50+R, 50, 0, R/1.6};\nPoint(5) = {50, 50+R, 0, R/1.6};\nPoint(6) = {50, 100, 0, 15.0};\nPoint(7) = {0, 100, 0, 15.0};\nPoint(8) = {50+R, 50+R, 0, 0.0};\nLine(1) = {1, 2};\nLine(2) = {2, 3};\nLine(3) = {3, 4};\nCircle(4) = {4, 8, 5};\nLine(5) = {5, 6};\nLine(6) = {6, 7};\nLine(7) = {7, 1};\nCurve Loop(1) = {1, 2, 3, 4, 5, 6, 7};\nPlane Surface(1) = {1};\n\nPhysical Curve(\"fix\", 8) = {6};\nPhysical Curve(\"load\", 9) = {2};\nPhysical Surface(\"body\", 11) = {1};\n\nSetName \"Lshape\";\nMesh.ElementOrder = 4;\nMesh.HighOrderOptimize = 1;\nMesh 2;\n\nPoint(9) = {0, 0, 0, 1.0};\nPoint(10) = {50+0.415*R, 50+0.415*R, 0, 1.0};\nLine(8) = {9, 10};\n\nPhysical Curve(\"path\", 10) = {8};","category":"page"},{"location":"Examples/#Wave-propagation-in-a-plate","page":"Examples","title":"Wave propagation in a plate","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: velocity field)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"wavePropagation.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\nE = 2e5\nν = 0.3\nρ = 7.85e-9\nthick = 1\nheight = 10\nbase = 100\nelemSize = 2 #22\n\napproxOrder = 2\ninternalNodes = true\nquadElements = true\n\ngmsh.model.add(\"rectangle\")\n\np1 = gmsh.model.occ.addPoint(0, 0, 0)\np2 = gmsh.model.occ.addPoint(base, 0, 0)\np3 = gmsh.model.occ.addPoint(base, height, 0)\np4 = gmsh.model.occ.addPoint(0, height, 0)\n\nl1 = gmsh.model.occ.addLine(p1, p2)\nl2 = gmsh.model.occ.addLine(p2, p3)\nl3 = gmsh.model.occ.addLine(p3, p4)\nl4 = gmsh.model.occ.addLine(p4, p1)\n\ncl1 = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])\n\nl5 = gmsh.model.occ.addCircle(base / 2, height / 2, 0, min(base, height) / 4)\ncl2 = gmsh.model.occ.addCurveLoop([l5])\n\nsf1 = gmsh.model.occ.addPlaneSurface([cl1, cl2])\n\ngmsh.model.occ.synchronize()\n\nphg = gmsh.model.addPhysicalGroup(1, [l2])\ngmsh.model.setPhysicalName(1, phg, \"supp\")\nphg = gmsh.model.addPhysicalGroup(1, [l4])\ngmsh.model.setPhysicalName(1, phg, \"load\")\nphg = gmsh.model.addPhysicalGroup(2, [sf1])\ngmsh.model.setPhysicalName(2, phg, \"body\")\n\ngenerateMesh(sf1, elemSize, approxOrder=approxOrder, algorithm=6, quadrangle=quadElements, internalNodes=internalNodes)\n\nmat = material(\"body\", E=E, ν=ν)\nproblem = Problem([mat], type=:PlaneStress, thickness=thick)\n\nsupp = displacementConstraint(\"supp\", ux=0, uy=0)\nld = load(\"load\", fx=1, fy=0)\n\ngmsh.option.setNumber(\"Mesh.Lines\", 0)\n\nK = stiffnessMatrix(problem)\nf = loadVector(problem, [ld])\nM = massMatrix(problem)\nC = 4e-3 * K\n\napplyBoundaryConditions!(K, M, C, f, [supp])\n\nTₘᵢₙ = smallestPeriodTime(K, M)\nq = solveDisplacement(K, f)\n\ndof, dof = size(K)\nu0 = zeros(dof)\nv0 = zeros(dof)\ninitialDisplacement!(\"supp\", u0, ux=0)\ninitialVelocity!(\"body\", v0, vx=1000)\ninitialVelocity!(\"supp\", v0, vx=0)\nf = zeros(dof)\n\nE = problem.material[1].E\nρ = problem.material[1].ρ\nc = √(E / ρ)\nξₘₐₓ = 1e-1\nβ = ξₘₐₓ * Tₘᵢₙ / π\nC = β * K\nu, v, t = CDM(K, M, C, f, u0, v0, base / c * 2, Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ) * 1.0)\n\nS = solveStress(q)\n\nuvec = showDoFResults(q, :uvec, name=\"uvec\", visible=false)\nux = showDoFResults(q, :ux, name=\"ux\", visible=false)\nuy = showDoFResults(q, :uy, name=\"uy\", visible=false)\nuz = showDoFResults(q, :uz, name=\"uz\", visible=false)\ns = showStressResults(S, :s, name=\"σ\", visible=false, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = showStressResults(S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = showStressResults(S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = showStressResults(S, :szx, name=\"τzx\", visible=false, smooth=true)\n\n# Show velocity time history as a VectorField with time vector t\nvVF = VectorField([], v, t, [], length(t), :u2D, problem)\nvvec = showDoFResults(vVF, :uvec, name=\"v(t)\", visible=true)\ngmsh.view.option.setNumber(vvec, \"NormalRaise\", 0.03)\n\nsts = ceil(Int64, (base / c * 2) / 6 / (Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ)))\ndisplay(sts)\nuVF_sts = VectorField([], u[:, sts:sts], [t[sts]], [], 1, :u2D, problem)\nSp = solveStress(uVF_sts)\nsp = showStressResults(Sp, :s, name=\"σ at t\", visible=false, smooth=false)\n\nuVF_anim = VectorField([], u[:, 1:sts], t[1:sts], [], sts, :u2D, problem)\nSanim = solveStress(uVF_anim)\nsanim = showStressResults(Sanim, :s, name=\"σ anim\", visible=false, smooth=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"For more examples see examples on GitHub","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"Examples/#2D-Heat-Conduction-(steady-state)","page":"Examples","title":"2D Heat Conduction (steady state)","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n# Problem and BCs\nmat = Material(\"body\", k=45.0)\nproblem = Problem([mat], type=:PlaneHeatConduction, thickness=1.0)\n\nbc_hot = temperatureConstraint(\"hot\", T=100.0)\nbc_cold = temperatureConstraint(\"cold\", T=0.0)\n\n# Assemble and solve K*T = q with Dirichlet BCs\nKth = heatConductionMatrix(problem)\nqth = heatFluxVector(problem, [])\nT = solveTemperature(Kth, qth, temperatureConstraint=[bc_hot, bc_cold])\n\n# Postprocess: temperature and heat flux\nshowDoFResults(T, :T, name=\"T\", visible=true)\nqflux = solveHeatFlux(T)\nshowHeatFluxResults(qflux, :qvec, name=\"q\", visible=false, smooth=true)\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"Examples/#2D-Heat-Conduction-with-Convection","page":"Examples","title":"2D Heat Conduction with Convection","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n# Heat problem and BCs\nmatT = material(\"body\", k=45.0)\nprobT = Problem([matT], type=:PlaneHeatConduction, thickness=1.0)\n\nbc_hot = temperatureConstraint(\"hot\", T=100.0)\nhcv = heatConvection(\"conv\", h=15.0, T∞=20.0)\n\nT = solveTemperature(Kth, qth, temperatureConstraint=[bc_hot], heatConvection=[hcv])\n\nshowDoFResults(T, :T, name=\"T\", visible=true)\nqflux = solveHeatFlux(T)\nshowHeatFluxResults(qflux, :qvec, name=\"q\", visible=false, smooth=true)\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"Examples/#Thermo‑Mechanical-Coupling-(Plane-Stress)","page":"Examples","title":"Thermo‑Mechanical Coupling (Plane Stress)","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n# 1) Heat problem to compute T(x)\nmatT = material(\"body\", k=45.0)\nprobT = Problem([matT], type=:PlaneHeatConduction, thickness=1.0)\nbc_hot = temperatureConstraint(\"hot\", T=100.0)\nhcv = heatConvection(\"conv\", h=15.0, T∞=20.0)\nT = solveTemperature(Kth, qth, temperatureConstraint=[bc_hot], heatConvection=[hcv])\n\n# 2) Elastic problem with thermal load\nmatE = material(\"body\", E=210e3, ν=0.3, α=1.2e-5)\nprobE = Problem([matE], type=:PlaneStress, thickness=1.0)\nK = stiffnessMatrix(probE)\nfth = thermalLoadVector(probE, T)  # from temperature field\nbc_fix = displacementConstraint(\"hot\", ux=0.0, uy=0.0)\nq = solveDisplacement(K, fth, support=[bc_fix])\nS = solveStress(q)\n\nshowDoFResults(q, :uvec, name=\"u\", visible=false)\nshowStressResults(S, :s, name=\"σ\", visible=true, smooth=true)\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"news/#News-and-Updates","page":"News & Updates","title":"News & Updates","text":"","category":"section"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"Welcome to the LowLevelFEM.jl News section!","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"This page collects package announcements, new examples, and feature highlights related to the LowLevelFEM project.   Posts are written in plain Markdown and versioned together with the documentation — making it easy to maintain and extend.","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"","category":"page"},{"location":"news/#Latest-posts","page":"News & Updates","title":"Latest posts","text":"","category":"section"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"November 2025 – Package Announcement","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"","category":"page"},{"location":"news/#How-to-contribute","page":"News & Updates","title":"How to contribute","text":"","category":"section"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"If you use LowLevelFEM.jl in teaching, research, or a student project and would like to share your results or an interesting example, feel free to open a pull request or suggest a short write-up.","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"📘 Related links","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"Documentation home\nJulia Discourse announcement\nProject repository","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"","category":"page"},{"location":"news/","page":"News & Updates","title":"News & Updates","text":"📡 RSS Feed: https://perebalazs.github.io/LowLevelFEM.jl/dev/news/feed.xml","category":"page"},{"location":"General/#General-API","page":"General","title":"General API","text":"","category":"section"},{"location":"General/#LowLevelFEM.BoundaryCondition","page":"General","title":"LowLevelFEM.BoundaryCondition","text":"BoundaryCondition\n\nGeneral container type for prescribing boundary conditions in LowLevelFEM.\n\nBoundaryCondition unifies all Dirichlet- and Neumann-type boundary data (mechanical, thermal, elastic, convective, etc.) into a single, extensible structure. A boundary condition always refers to a physical group of the mesh (e.g. \"left\", \"right\", \"wall\") and may prescribe one or more fields simultaneously.\n\nThe same BoundaryCondition type is used consistently across:\n\nstatic and transient solid mechanics\nmodal and buckling analysis\nheat conduction and thermo-mechanical problems\n\nBoundary conditions are typically passed as Vector{BoundaryCondition} to assembly, load, and solver routines.\n\nPrescribed fields\n\nMechanical (solid mechanics)\n\nDirichlet-type (essential)\n\nux, uy, uz : prescribed displacement components\np          : prescribed pressure (if applicable)\n\nNeumann-type (natural)\n\nfx, fy, fz : prescribed surface forces / tractions\n\nElastic (Robin-type)\n\nkx, ky, kz : elastic support (spring stiffness per displacement component)\n\nThermal\n\nDirichlet-type\n\nT          : prescribed temperature\n\nNeumann-type\n\nq          : prescribed heat flux\nqn         : prescribed normal heat flux\n\nConvection (Robin-type)\n\nh          : heat transfer coefficient\nT          : ambient temperature (used together with h)\n\nPoisson-type problems\n\nDirichlet-type\n\np          : prescribed field\n\nNeumann-type\n\nq          : prescribed force\n\nFor heat convection, the field T is interpreted as ambient temperature. This is intentional and handled consistently by the heat assembly routines.\n\nValue types\n\nEach field may be specified as:\n\na scalar number (Number)\na ScalarField\na VectorField\na function (x,y,z) -> value\n\ndepending on the context and the assembly routine using it.\n\nUsage pattern\n\nIt is recommended to:\n\nuse separate BoundaryCondition objects for conceptually different constraints (e.g. displacement support vs. load),\nand collect them in a vector:\n\nbc = [\n    displacementConstraint(\"left\", ux=0.0, uy=0.0),\n    load(\"right\", fx=1.0),\n    temperatureConstraint(\"wall\", T=300.0)\n]\n\nNotes\n\nOnly the fields relevant to a given analysis are accessed; unused fields may safely remain nothing.\nInvalid combinations (e.g. simultaneous displacement and force prescription on the same DOF) are detected during boundary condition application.\n\nSee also:\n\ndisplacementConstraint\nload\nelasticSupport\ntemperatureConstraint\nheatFlux\nheatConvection\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.CoordinateSystem","page":"General","title":"LowLevelFEM.CoordinateSystem","text":"CoordinateSystem(vec1, vec2)\n\nA structure containing the data of a coordinate system.\n\nvec1: direction of the new x axis.\nvec2: together with vec1 determine the xy plane\n\nIf the problem is two dimensional, it is enough to give the first two elements of vec1. Elements of vec1 and vec2 can be functions. In 3D case the functions have three arguments (x, y, and z coordinates), otherwise (in 2D case) the number of arguments is two (x and y coordinates).\n\nTypes:\n\nvec1: Vector{Float64}\nvec2: Vector{Float64}\n\nExamples\n\n# 2D case\nnx(x, y) = x\nny(x, y) = y\ncs = CoordinateSystem([nx, ny])\nQ = rotateNodes(problem, \"body\", cs)\nq2 = Q' * q1 # where `q1` is in Cartesian, `q2` is in Axisymmetric coordinate system and\n# `q1` is a nodal displacement vector.\nS2 = Q' * S1 * Q # where `S1` is a stress field in Cartesian coordinate system while\n# `S2` is in Axisymmetric coordinate system.\n\n# 3D case\nn1x(x, y, z) = x\nn1y(x, y, z) = y\nn2x(x, y, z) = -y\nn2y = n1x\ncs = CoordinateSystem([n1x, n1y, 0], [n2x, n2y, 0])\nQ = rotateNodes(problem, \"body\", cs)\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Eigen","page":"General","title":"LowLevelFEM.Eigen","text":"Eigen(f, ϕ, model)\n\nA structure containing the eigenfrequencies and eigen modes.\n\nf: eigenfrequencies\nϕ: eigen modes\nmodel: same as Problem\n\nTypes:\n\nf: Matrix{Float64}\nϕ: Vector{Float64}\nmodel: Problem\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Material","page":"General","title":"LowLevelFEM.Material","text":"Material(phName, type, E, ν, ρ, k, c, α, λ, μ, κ)\n\nStructure containing the material type and constants.\n\ntype: constitutive law (:Hooke, :StVenantKirchhoff, :NeoHookeCompressible)\nE: elastic modulus\nν: Poisson's ratio\nρ: mass density\nk: thermal conductivity\nc: specific heat\nα: thermal expansion coefficient\nλ: Lamé parameter\nμ: Lamé parameter\nκ: bulk modulus\n\nphName is the name of the physical group where the material is used.\n\nTypes:\n\nphName: String\ntype: Symbol\nE: Float64\nν: Float64\nρ: Float64\nk: Float64\nc: Float64\nα: Float64\nλ: Float64\nμ: Float64\nκ: Float64\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Problem","page":"General","title":"LowLevelFEM.Problem","text":"Problem(materials; thickness=..., type=..., bandwidth=..., dim=..., fdim=...)\n\nStructure containing key data for a problem.\n\nParts of the model with their material constants. Multiple materials can be provided (see material).\nProblem type: :Solid, :PlaneStrain, :PlaneStress, :AxiSymmetric, :HeatConduction, :PlaneHeatConduction, \n\n:AxiSymmetricHeatConduction, :Truss, :General.   For :AxiSymmetric, the symmetry axis is y, and the geometry must be drawn in the positive x half-plane.\n\nBandwidth optimization using Gmsh's built-in reordering. Options: :RCMK, :Hilbert, :Metis, or :none (default).\nDimension of the problem, determined by type.\nMaterial constants (vector of Material; see the Material struct).\nPlate thickness (for 2D plate problems).\nNumber of nodes (non).\nGeometry dimension.\nProblem dimension (e.g., a 3D heat conduction problem is a 1D problem).\nIn case of 2D truss displacements have to be fixed in the third direction.\ndim is number of dimensions in space (in case of :General)\nfdim is the number of unknown fields (eg. scalar->1, 2D vector->2, 3D vector->3 or more) (in case of :General)\n\nTypes:\n\nmaterials: Material\ntype: Symbol\nbandwidth: Symbol\ndim: Integer\nthickness: Float64\nnon: Integer\ndim: Integer\npdim: Integer\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.ScalarField","page":"General","title":"LowLevelFEM.ScalarField","text":"ScalarField(A, a, t, numElem, nsteps, type, model)\nScalarField(problem::Problem, dataField::Vector; steps=1, tmin=0.0, tmax=tmin+(steps-1))\nScalarField(problem::Problem, phName::String, data::Union{Number,Function};\n            steps=1, tmin=0.0, tmax=tmin+(steps-1))\nScalarField(s::ScalarField; steps=1, tmin=0.0, tmax=tmin+(steps-1), step=1)\n\nContainer for a time-dependent scalar field defined on a finite element mesh (e.g. temperature, pressure, potential).\n\nA ScalarField can store the field either\n\nelement-wise (values at the element nodes, stored in A), or\nnodally (values at global mesh nodes, stored in a).\n\nTime dependence is handled by storing multiple time steps for each spatial degree of freedom.\n\n\n\nStored data\n\nA : Vector of matrices holding element-wise values   (A[e][k,i] = value at local node k of element e at time step i)\na : Matrix of nodal values   (a[n,i] = value at node n at time step i)\nt : Vector of time instants corresponding to the stored time steps\nnumElem : Vector of element tags associated with A\nnsteps : Number of stored time steps\ntype : Symbol identifying the physical meaning of the field\nmodel : Associated Problem\n\nAt a given time, either A or a is typically populated, depending on whether the field is element-wise or nodal.\n\n\n\nConstructors\n\nLow-level constructor\n\nScalarField(A, a, t, numElem, nsteps, type, model)\n\nDirectly constructs a ScalarField from preallocated data arrays.\n\n\n\nFrom spatial field definitions\n\nScalarField(problem, dataField; steps, tmin, tmax)\n\nConstructs an element-wise scalar field from a vector of field definitions (e.g. as returned by field(...)). The scalar value may be:\n\na constant,\na spatial function f(x,y,z),\nor a space–time function f(x,y,z,t).\n\nValues are evaluated at the element nodes for each requested time step.\n\n\n\nFrom a physical group\n\nScalarField(problem, phName, data; steps, tmin, tmax)\n\nConvenience constructor for defining a scalar field on a single physical group. Equivalent to calling field(phName, f=data) internally.\n\n\n\nFrom an existing ScalarField\n\nScalarField(s; steps, tmin, tmax, step)\n\nCreates a new ScalarField by replicating a selected time step of an existing field. This is useful for initializing a time-dependent field from a static solution.\n\nstep selects the time index of s to be replicated.\nThe new field contains steps identical time slices.\n\n\n\nNotes\n\nTime steps do not need to be uniformly spaced.\nNo assumptions are made about governing equations; this is a pure data container.\nSpatial interpolation and projections (e.g. nodal ↔ element-wise) are handled by separate utility functions.\n\n\n\nExample\n\ns(x,y,z) = 2x + 3y\nfs = field(\"body\", f=s)\n\nS1 = ScalarField(problem, [fs])\nS2 = ScalarField(problem, \"body\", s)\n\nHere S1 and S2 define equivalent element-wise scalar fields.\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.SystemMatrix","page":"General","title":"LowLevelFEM.SystemMatrix","text":"SystemMatrix(A::SparseMatrixCSC{Float64}, model::Problem)\nSystemMatrix(A::SparseMatrixCSC{Float64}, model::Problem, test_model::Problem)\n\nStructure containing the stiffness/mass/heat conduction/heat capacity/latent heat/... matrix and the  associated Problem (with its trial field) and another Problem (with a test field).\n\nTypes:\n\nA: SparseMatrixCSC{Float64}\nmodel: Problem\ntest_model: Problem\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.TensorField","page":"General","title":"LowLevelFEM.TensorField","text":"TensorField(A, a, t, numElem, nsteps, type, model)\nTensorField(problem::Problem, dataField::Vector)\nTensorField(problem::Problem, phName::String, data::Matrix)\nTensorField(comps::Matrix{ScalarField})\n\nContainer for a (possibly time-dependent) second-order tensor field defined on a finite element mesh (e.g. stress, strain, conductivity tensor).\n\nA TensorField stores a full 3×3 tensor at each spatial location, either\n\nelement-wise, with values given at element nodes (A), or\nnodally, with values given at global mesh nodes (a).\n\nTime dependence is handled by storing multiple time steps for each tensor component.\n\n\n\nStored data\n\nA : Vector of matrices holding element-wise tensor values   (A[e][9k-8:9k, i] = tensor components at local node k of element e at time step i)\na : Matrix of nodal tensor values   (same component ordering as element-wise storage)\nt : Vector of time instants corresponding to the stored time steps\nnumElem : Vector of element tags associated with A\nnsteps : Number of stored time steps\ntype : Symbol identifying the physical meaning of the tensor field (e.g. :e, :stress, :tensor)\nmodel : Associated Problem\n\nTensor components are stored in row-major, interleaved form for each node:\n\n\n(xx, yx, zx,\nxy, yy, zy,\nxz, yz, zz)\n\n\nrepeated for all nodes and time steps.\n\n\n\nConstructors\n\nLow-level constructor\n\nTensorField(A, a, t, numElem, nsteps, type, model)\n\nDirectly constructs a TensorField from preallocated data arrays.\n\n\n\nFrom element-wise field definitions\n\nTensorField(problem, dataField::Vector)\n\nConstructs an element-wise tensor field from a vector of field definitions (e.g. as returned by field(...)).\n\nEach tensor component may be specified as:\n\na constant,\na spatial function f(x,y,z).\n\nValues are evaluated at the element nodes.\n\n\n\nFrom a constant or functional tensor\n\nTensorField(problem, phName, data::Matrix)\n\nConvenience constructor for defining a tensor field on a single physical group, where data is a 3×3 matrix whose entries are constants or functions f(x,y,z).\n\n\n\nFrom scalar components\n\nTensorField(comps::Matrix{ScalarField})\n\nAssembles a 3×3 tensor field from a 3×3 matrix of compatible ScalarFields.\n\nRequirements:\n\nexactly a 3×3 matrix of scalar fields,\nidentical Problem,\nidentical element numbering,\nidentical time discretization.\n\nEach scalar field provides one tensor component.\n\n\n\nNotes\n\nTime steps do not need to be uniformly spaced.\nNo symmetry is assumed; all 9 tensor components are stored explicitly.\nThis is a pure data container; no constitutive or kinematic assumptions are implied.\nSpatial operations (e.g. divergence, invariants, projections) are handled by separate utility functions.\nElement-wise storage is the primary representation; nodal storage may be empty depending on construction.\n\n\n\nExample\n\ntx(x,y,z)  = x + y\ntxy(x,y,z) = z\n\nft = field(\"body\", fx=tx, fxy=txy, fz=3)\nT1 = TensorField(problem, [ft])\n\nT2 = TensorField(problem, \"body\", [1 0 0;\n                                  0 2 0;\n                                  0 0 3])\n\nHere T1 and T2 define equivalent element-wise tensor fields.\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Transformation","page":"General","title":"LowLevelFEM.Transformation","text":"Transformation(T::SparseMatrixCSC{Float64}, non::Int64, dim::Int64)\n\nStructure containing the transformation matrix T at each node in the FE mesh, the number of nodes non, and the problem dimension dim.\n\nTypes:\n\nT: SparseMatrixCSC{Float64}\nnon: Int64\ndim: Int64\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.VectorField","page":"General","title":"LowLevelFEM.VectorField","text":"VectorField(A, a, t, numElem, nsteps, type, model)\nVectorField(problem::Problem, dataField::Vector)\nVectorField(problem::Problem, phName::String, data::Vector)\nVectorField(problem::Problem, phName::String, func::Function)\nVectorField(comps::Vector{ScalarField})\n\nContainer for a (possibly time-dependent) vector field defined on a finite element mesh (e.g. displacement, velocity, heat flux).\n\nA VectorField stores a 3D vector field either\n\nelement-wise, with values given at element nodes (A), or\nnodally, with values given at global mesh nodes (a).\n\nTime dependence is handled by storing multiple time steps for each spatial degree of freedom, analogously to ScalarField.\n\n\n\nStored data\n\nA : Vector of matrices holding element-wise vector values   (A[e][3k-2:3k, i] = vector value at local node k of element e at time step i)\na : Matrix of nodal vector values   (layout follows the same interleaved component ordering)\nt : Vector of time instants corresponding to the stored time steps\nnumElem : Vector of element tags associated with A\nnsteps : Number of stored time steps\ntype : Symbol identifying the physical meaning of the vector field (e.g. :v3D)\nmodel : Associated Problem\n\nVector components are stored in interleaved form (x₁,y₁,z₁,x₂,y₂,z₂,…) for each element or node.\n\n\n\nConstructors\n\nLow-level constructor\n\nVectorField(A, a, t, numElem, nsteps, type, model)\n\nDirectly constructs a VectorField from preallocated data arrays.\n\n\n\nFrom element-wise field definitions\n\nVectorField(problem, dataField::Vector)\n\nConstructs an element-wise vector field from a vector of field definitions (e.g. as returned by field(...)). Each component may be specified as:\n\na constant,\na spatial function f(x,y,z).\n\nValues are evaluated at the element nodes.\n\n\n\nFrom a physical group and component data\n\nVectorField(problem, phName, data::Vector)\n\nConvenience constructor for defining a vector field on a single physical group, where data = [fx, fy, fz] specifies the three components (constants or functions).\n\n\n\nFrom a vector-valued function\n\nVectorField(problem, phName, func::Function)\n\nConstructs an element-wise vector field by evaluating a function func(x,y,z) -> (vx,vy,vz) at the element nodes.\n\n\n\nFrom scalar components\n\nVectorField(comps::Vector{ScalarField})\n\nAssembles a 3D vector field from exactly three compatible ScalarFields.\n\nRequirements:\n\nexactly three components,\nsame Problem,\nidentical element numbering,\nidentical time discretization.\n\nEach scalar field provides one vector component.\n\n\n\nFrom an existing VectorField\n\nVectorField(s; steps, tmin, tmax, step)\n\nCreates a new VectorField by replicating a selected time step of an existing field. This is useful for initializing a time-dependent field from a static solution.\n\nstep selects the time index of s to be replicated.\nThe new field contains steps identical time slices.\n\n\n\nNotes\n\nTime steps do not need to be uniformly spaced.\nNo governing equations are implied; this is a pure data container.\nSpatial operations (gradient, divergence, projections, etc.) are handled by separate utility functions.\nElement-wise storage is the primary representation; nodal storage may be empty depending on construction.\n\n\n\nExample\n\nvx(x,y,z) = x + y\nvy(x,y,z) = z\n\nfv = field(\"body\", fx=vx, fy=vy, fz=3)\nV1 = VectorField(problem, [fv])\n\nV2 = VectorField(problem, \"body\", [vx, vy, 3])\n\nHere V1 and V2 define equivalent element-wise vector fields.\n\n\n\n\n\n","category":"type"},{"location":"General/#Base.getindex-Tuple{TensorField, Colon, Int64}","page":"General","title":"Base.getindex","text":"T[:,j] -> VectorField\n\nExtract the j-th column of a 3×3 TensorField as a 3-component VectorField.\n\nEquivalent to: [T[1,j], T[2,j], T[3,j]]\n\nArguments\n\nj::Int: column index (1 ≤ j ≤ 3).\n\nReturns\n\nA VectorField of size 3.\n\nNotes\n\nColon indexing is required; T[j] is not allowed.\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.getindex-Tuple{TensorField, Int64, Colon}","page":"General","title":"Base.getindex","text":"T[i,:] -> VectorField\n\nExtract the i-th row of a 3×3 TensorField as a 3-component VectorField.\n\nEquivalent to: [T[i,1], T[i,2], T[i,3]]\n\nArguments\n\ni::Int: row index (1 ≤ i ≤ 3).\n\nReturns\n\nA VectorField of size 3.\n\nNotes\n\nColon indexing is required; T[i] is not allowed.\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.getindex-Tuple{TensorField, Int64, Int64}","page":"General","title":"Base.getindex","text":"T[i,j] -> ScalarField\n\nExtract a single tensor component (i,j) from a 3×3 TensorField.\n\nArguments\n\ni::Int, j::Int: tensor indices in 1:3.\n\nReturns\n\nA ScalarField corresponding to component Tᵢⱼ.\n\nNotes\n\nBlock extraction is done elementwise or nodally depending on the representation of T.\n\nErrors\n\nRaises an error if i or j is outside 1:3.\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.getindex-Tuple{TensorField, Vararg{Any}}","page":"General","title":"Base.getindex","text":"Invalid index pattern for TensorField.\n\nAllowed:\n\nT[i,j]    → ScalarField\nT[i,:]    → VectorField (row)\nT[:,j]    → VectorField (column)\n\nNot allowed:\n\nT[i]\nT[:]\nT[1:2,1]\nT[:, :]\nT[[1,3],2]\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.getindex-Tuple{VectorField, Int64}","page":"General","title":"Base.getindex","text":"v[k] -> ScalarField\n\nExtract the k-th component (1,2,3) of a VectorField as a ScalarField.\n\nArguments\n\nk::Int: component index (1 → x, 2 → y, 3 → z).\n\nReturns\n\nA ScalarField in the same representation as the parent field (elementwise or nodal).\n\nErrors\n\nRaises an error for any non-scalar indexing:\n\nv[1:2]    → ERROR  \nv[[1,3]]  → ERROR  \nv[:]      → ERROR\n\nOnly single-component extraction v[k] is allowed.\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.setindex!-Tuple{TensorField, ScalarField, Int64, Int64}","page":"General","title":"Base.setindex!","text":"T[i, j] = s\nT[i, :] = v\nT[:, j] = v\n\nAssign a scalar or vector component into a TensorField.\n\nSupported forms\n\n1. Assign scalar component\n\nT[i, j] = s\n\nInserts the scalar field s into the tensor component (i, j)   (with i,j ∈ 1:3).\nOnly the rows of the (i,j) block are overwritten.\n\n2. Assign row vector\n\nT[i, :] = v\n\nv must be a VectorField with 3 components.\nReplaces the entire i-th tensor row with the components of v.\n\n3. Assign column vector\n\nT[:, j] = v\n\nv must be a VectorField.\nReplaces the entire j-th tensor column with the components of v.\n\nRequirements\n\nAssigned field(s) must belong to the same problem as T.\nThe number of time steps must match.\nStorage mode must match:\nElementwise tensor → only elementwise scalar/vector may be assigned.\nNodal tensor → only nodal scalar/vector may be assigned.\nElement counts or nodal sizes must be identical.\n\nExamples\n\n# scalar insertion\nT[1,1] = s1\nT[2,3] = s2\n\n# row insertion\nT[1,:] = v1    # v1 is VectorField([s11, s12, s13])\n\n# column insertion\nT[:,3] = v2\n\nErrors\n\nErrors are thrown when:\n\nindices are out of bounds\nshapes do not match (nodal vs elementwise mismatch)\ncomponent sizes differ\nattempting unsupported forms like T[1] = ... or T[:, :] = ...\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.setindex!-Tuple{VectorField, ScalarField, Int64}","page":"General","title":"Base.setindex!","text":"v[k] = s\n\nAssign a scalar component into a VectorField.\n\nThis operation overwrites the k-th component (k = 1, 2, 3) of the vector field.\n\nRequirements\n\nv must be a VectorField\ns must be a ScalarField\nboth fields must belong to the same problem\nboth must have the same number of time steps\nstorage layout must match:\nIf v is elementwise (v.A ≠ []), then s must also be elementwise and must have the same number of elements (numElem).\nIf v is nodal (v.a ≠ [;;]), then s must also be nodal and must have the same nodal size.\n\nOnly the rows belonging to component k are modified.   Other components remain unchanged.\n\nExample\n\nv = VectorField([s1, s2, s3])\n\nv[1] = s4       # overwrite first component\nv[3] = 2s1      # scale and assign into third component\n\nErrors\n\nAn informative error is thrown if:\n\nk ∉ 1:3\nthe fields belong to different problems\nstorage layouts do not match (nodal vs. elementwise)\nnodal or element counts differ\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}","page":"General","title":"Base.show","text":"Base.show(io::IO, M::SystemMatrix)\n\nInternal function to display SystemMatrix as a SparseMatrixCSC{Float64}.\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Union{ScalarField, TensorField, VectorField}}","page":"General","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", M::Union{ScalarField,VectorField,TensorField})\n\nPlain-text display in REPL and notebooks.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.DoFs-Tuple{LowLevelFEM.AbstractField}","page":"General","title":"LowLevelFEM.DoFs","text":"DoFs(f::AbstractField)\n\nReturn the vector of degrees of freedom (DOFs) associated with a field.\n\nThis corresponds to the nodal representation used in linear algebra operations (assembly, solving, post-processing).\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.allDoFs-Tuple{Any}","page":"General","title":"LowLevelFEM.allDoFs","text":"allDoFs(problem)\n\nReturns the serial numbers of degrees of freedom of the whole model.\n\nReturn: DoFs\n\nTypes:\n\nproblem: Problem\nDoFs: Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.constrainedDoFs","text":"constrainedDoFs(problem, supports)\n\nReturns the serial numbers of constrained degrees of freedom. Support is a vector of boundary conditions given with the function displacementConstraint.\n\nReturn: DoFs\n\nTypes:\n\nproblem: Problem\nsupports: Vector{BoundaryCondition}\nDoFs: Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.displacementConstraint-Tuple{Any}","page":"General","title":"LowLevelFEM.displacementConstraint","text":"displacementConstraint(name; ux=..., uy=..., uz=...)\n\nSpecifies displacement constraints on the physical group name. At least one of ux, uy, or uz must be provided (depending on the problem dimension). ux, uy, or uz can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); displacementConstraint(\"support1\", ux=fn))\n\nReturns: BoundaryCondition\n\nExamples\n\nhc = heatConvection(\"outer\", h=10.0, T∞=20.0)\n\nExamples\n\nsrc = heatSource(\"body\", h=1.0e6)\n\nExamples\n\nq = heatFlux(\"out\", qn=500.0)\n\nExamples\n\nbcT = temperatureConstraint(\"hot_face\", T=100.0)\n\nExamples\n\nld = load(\"load\", fy=-1.0)\n\nExamples\n\nbc = displacementConstraint(\"supp\", ux=0, uy=0)\n\nTypes:\n\nname: String\nux: Float64 or Function\nuy: Float64 or Function\nuz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.elasticSupport-Tuple{Any}","page":"General","title":"LowLevelFEM.elasticSupport","text":"elasticSupport(name; kx=..., ky=..., kz=...)\n\nSpecifies distributed stiffness for an elastic support on the physical group name. kx, ky, or kz can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); elasticSupport(\"supp1\", kx=fn)) Default values are 1.\n\nReturns: BoundaryCondition\n\nTypes:\n\nname: String\nkx: Float64 or Function\nky: Float64 or Function\nkz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.elementsToNodes-Tuple{Any}","page":"General","title":"LowLevelFEM.elementsToNodes","text":"elementsToNodes(T)\n\nSolves the nodal results F from the elemental results T. T can be ScalarField, VectorField or TensorField.\n\nReturn: F\n\nTypes:\n\nT: ScalarField, VectorField or TensorField\nF: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.expandTo3D-Tuple{VectorField}","page":"General","title":"LowLevelFEM.expandTo3D","text":"expandTo3D(v2D::VectorField)\n\nExpand a 2D vector field into 3D by adding a zero z-component.\n\nreturn: VectorField\n\nExamples\n\nV3D = expandTo3D(V2D)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.field-Tuple{Any}","page":"General","title":"LowLevelFEM.field","text":"field(name; f=..., fx=..., fy=..., fz=..., fxy=..., fyz=..., fzx=...)\n\nSpecifies the value of a scalar, vector, or tensor field on the physical group name. At least one of fx, fy, or fz etc. must be provided (depending on the problem dimension). Each component can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); field(\"surf1\", fx=fn))\n\nReturns: BoundaryCondition\n\nTypes:\n\nname: String\nf: Float64 or Function\nfx: Float64 or Function\nfy: Float64 or Function\nfz: Float64 or Function\nfxy: Float64 or Function\nfyz: Float64 or Function\nfzx: Float64 or Function\n\nExamples\n\nf1(x, y, z) = y\nf2 = field(\"face1\", f=f1)\nqq = scalarField(problem, [f2])\nqqq = showDoFResults(qq, :scalar)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.fieldError-Tuple{Any}","page":"General","title":"LowLevelFEM.fieldError","text":"fieldError(F)\n\nComputes the deviation of field results F (stresses, strains, heat flux components) at nodes where the field has jumps. The result can be displayed with the showDoFResults function.\n\nReturns: e\n\nTypes:\n\nF: VectorField or TensorField\ne: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.freeDoFs-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.freeDoFs","text":"freeDoFs(problem, supports)\n\nReturns the serial numbers of unconstrained degrees of freedom. Support is  a vector of boundary conditions given with the function displacementConstraint.\n\nReturn: DoFs\n\nTypes:\n\nproblem: Problem\nsupports: Vector{BoundaryCondition}\nDoFs: Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.getDimForPhysicalName-Tuple{Any}","page":"General","title":"LowLevelFEM.getDimForPhysicalName","text":"getDimForPhysicalName(name)\n\nReturns dim of elements of physical group name.\n\nReturns: dim\n\nTypes:\n\nname: String\ndim: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.getEigenValues-Tuple{VectorField}","page":"General","title":"LowLevelFEM.getEigenValues","text":"getEigenValues(A::VectorField)\n\nA function to extract the elements of a vector field to separate scalar fields.\n\nReturn: λ1, λ2, λ3\n\nTypes:\n\nA: VectorField\nλ1: ScalarField\nλ2: ScalarField\nλ3: ScalarField\n\nExamples:\n\nusing LinearAlgebra\nλ, Q = eigen(S)\nλ1, λ2, λ2 = getEigenValues(λ)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.getEigenVectors-Tuple{TensorField}","page":"General","title":"LowLevelFEM.getEigenVectors","text":"getEigenVectors(A::TensorField)\n\nA function to extract the columns of a tensor field to separate vector fields.\n\nReturn: N1, N2, N3\n\nTypes:\n\nA: TensorField\nN1: VectorField\nN2: VectorField\nN3: VectorField\n\nExamples:\n\nusing LinearAlgebra\nλ, Q = eigen(S)\nN1, N2, N2 = getEigenVectors(Q)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.getTagForPhysicalName-Tuple{Any}","page":"General","title":"LowLevelFEM.getTagForPhysicalName","text":"getTagForPhysicalName(name)\n\nReturns tag of elements of physical group name.\n\nReturns: tag\n\nTypes:\n\nname: String\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.heatConvection-Tuple{Any}","page":"General","title":"LowLevelFEM.heatConvection","text":"heatConvection(name; h=..., T∞=...)\n\nSpecifies convective boundary conditions on the surface in the physical group name. h is the heat transfer coefficient of the surrounding medium; Tₐ is the ambient temperature. Tₐ can be either a constant or a function of x, y, and z.\n\nReturns: BoundaryCondition\n\nTypes:\n\nname: String\nh: Float64\nTₐ: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.heatFlux-Tuple{Any}","page":"General","title":"LowLevelFEM.heatFlux","text":"heatFlux(name; qn=...)\n\nSpecifies the heat flux normal to the surface of the physical group name. qn can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); load(\"flux1\", qn=fn))\n\nReturns: BoundaryCondition\n\nTypes:\n\nname: String\nqn: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.heatSource-Tuple{Any}","page":"General","title":"LowLevelFEM.heatSource","text":"heatSource(name; h=...)\n\nSpecifies the volumetric heat source in the physical group name. h can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); load(\"source1\", h=fn))\n\nReturns: BoundaryCondition\n\nTypes:\n\nname: String\nh: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.integrate-Tuple{Problem, String, Union{Function, ScalarField}}","page":"General","title":"LowLevelFEM.integrate","text":"integrate(problem::Problem, phName::String, f::Union{Function,ScalarField}; step::Int64=1, order::Int64=...)\n∫(problem::Problem, phName::String, f::Union{Function,ScalarField}; step::Int64=1, order::Int64=...)\n\nIntegrates the function or scalar field f over the physical group phName defined in the geometry of problem. If f is a ScalarField, the time step step will be integrated. The optional parameter order controls the  numerical integration rule. If order > 0, it is used as a hint for selecting the Gauss quadrature order (i.e. the number of integration points) employed during integration. The exactness of the integration depends  on the element geometry and the regularity of the integrand.\n\nReturns: integral\n\nTypes:\n\nproblem: Problem\nphName: String\nf: Function (of x, y and z) or ScalarField\nintegral: Number\n\nExamples:\n\nf(x, y, z) = x^2 + y^2\nIz = integrate(prob, \"body\", f)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.integrate-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.integrate","text":"integrate(s::Union{ScalarField,VectorField,TensorField})\n∫(s::Union{ScalarField,VectorField,TensorField})\n\nCompute the time integral of a time-dependent field using a discrete inverse of the central finite-difference time derivative.\n\nThe result reproduces the original field (up to a time-independent constant) when applied to a field obtained by ∂t.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.isElementwise-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.isElementwise","text":"isElementwise(field)\n\nCheck if a given field is defined per element (elementwise quantity).\n\nElementwise quantities are associated with finite elements as a whole, for example stresses, strains, or energy densities evaluated inside elements.\n\nExamples\n\nisElementwise(displacement_field)   # returns false\nisElementwise(strain_field)         # returns true\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.isNodal-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.isNodal","text":"isNodal(field)\n\nCheck if a given field is defined at nodes (nodal quantity).\n\nNodal quantities are associated with mesh nodes, for example displacements, nodal forces, or nodal temperatures.\n\nExamples\n\nisNodal(displacement_field)   # returns true\nisNodal(strain_field)         # returns false\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.isSaved-Tuple{String}","page":"General","title":"LowLevelFEM.isSaved","text":"isSaved(fileName::String)\n\nChecks whether a variable has been saved or not.\n\nReturns: Boolean\n\nTypes:\n\nfileName: String\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.load-Tuple{Any}","page":"General","title":"LowLevelFEM.load","text":"load(name; fx=..., fy=..., fz=...)\n\nSpecifies a distributed load on the physical group name. At least one of fx, fy, or fz must be provided (depending on the problem dimension). fx, fy, or fz can be a constant or a function of x, y, and z or ScalarField. (e.g., fn(x,y,z) = 5*(5-x); load(\"load1\", fx=fn))\n\nReturns: BoundaryCondition\n\nTypes:\n\nname: String\nfx: Float64 or Function\nfy: Float64 or Function\nfz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.loadField-Tuple{String}","page":"General","title":"LowLevelFEM.loadField","text":"loadField(fileName::String)\n\nLoads a ScalarField, VectorField, or TensorField from a file named fileName (without \"-LLF-Data.jld2\"). \n\nReturns: variable\n\nTypes:\n\nfileName: String\nvariable: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.nodesToElements-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.nodesToElements","text":"nodesToElements(T, onPhysicalGroup=\"\")\n\nSolves the element results F from the nodal results T. T can be ScalarField, VectorField or TensorField. If onPhysicalGroup is an existing physical group in gmsh, field T will be solve only on elements belonging to that physical group. Dimension of physical group can be different than the dimension of the problem. (eg. mapping from 3D volume to a 2D surface)\n\nReturn: F\n\nTypes:\n\nT: ScalarField, VectorField or TensorField\nF: ScalarField, VectorField or TensorField\nonPhysicalGroup: String\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.normalVector-Tuple{Problem, String}","page":"General","title":"LowLevelFEM.normalVector","text":"normalVector(problem::Problem, phName::String) -> VectorField\n\nCompute outward unit normal vectors for all nodes belonging to a surface-type physical group in a 3D Gmsh model.\n\nFor curve-type physical groups, the function returns normal curvature vectors: the direction corresponds to the unit normal within the curve’s osculating plane, and the vector magnitude equals the local curvature of the curve.\n\nArguments\n\nproblem::Problem: A Problem structure containing the current Gmsh model  (name, dimension, number of nodes, etc.).\nphName::String: The name of a physical surface group in Gmsh for which the normal vectors are computed.\n\nDescription\n\nThe function sets the current model, queries the elements and nodes that belong to the  given physical surface group, and evaluates the gradients of the Lagrange basis functions  to compute local tangent vectors of the surface. Normal vectors are obtained as cross  products of these tangents and normalized to unit length.\n\nEach node belonging to the physical surface group is assigned its corresponding  3D unit normal vector.\n\nReturns\n\nVectorField: A VectorField structure that stores the nodal normal vectors  on the given physical surface.\n\nErrors\n\nThrows an error if the provided physical group is not of surface type (dim != 2).\n\nExample\n\nusing LowLevelFEM\n\n# Load a 3D geometry and mesh it in Gmsh\ngmsh.initialize()\ngmsh.open(\"box_with_surface.msh\")\n\n# Define a 3D model on the volume physical group \"body\"\nmat = material(\"body\")\nprob = Problem([mat])\n\n# Compute nodal normals on a physical surface named \"leftWall\"\nnv = normalVector(problem, \"leftWall\")\n\n# Show the normal vectors on the model\nshowDoFResults(nv)\nopenPostProcessor()\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.openPostProcessor-Tuple{}","page":"General","title":"LowLevelFEM.openPostProcessor","text":"openPostProcessor(; model=...)\n\nLaunches the Gmsh postprocessor window with the postprocessor tree opened (of model).\n\nReturns: nothing\n\nTypes:\n\nmodel: Int64\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.openPreProcessor-Tuple{}","page":"General","title":"LowLevelFEM.openPreProcessor","text":"openPreProcessor(; openGL=...)\n\nLaunches the Gmsh preprocessor window with OpenGL disabled by default.\n\nReturns: nothing\n\nTypes:\n\nopenGL: Boolean\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.plotOnPath-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.plotOnPath","text":"plotOnPath(pathName, field; points=100, step=..., plot=..., name=..., visible=..., offsetX=..., offsetY=..., offsetZ=...)\n\nLoads a 2D plot along a path into a View in Gmsh. field is the View id in Gmsh from which the field data is imported. pathName is the name of a physical group that contains a curve. The curve is divided into equal-length segments with points sampling points. The field is shown at these points. step is the sequence number of the displayed step. If no step is given, it shows all available steps as an animation. If plot is true, an additional return parameter (a tuple of vectors) is returned, where x is the horizontal axis and y is the vertical axis of the plot (see the Plots package). name is the title of the graph, and visible is a Boolean to toggle the initial visibility in Gmsh on or off. This function returns the tag of the View.\n\nReturns: tag\n\nor\n\nReturns: tag, xy\n\nTypes:\n\nproblem: Problem\npathName: String\nfield: Integer\npoints: Integer\nstep: Integer\nplot: Boolean\nname: String\nvisible: Boolean\ntag: Integer\nxy: Tuples{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.probe-Tuple{TensorField, Any, Any, Any}","page":"General","title":"LowLevelFEM.probe","text":"probe(A::Union{ScalarField,VectorField,TensorField}, x::Number, y::Number, z::Number; step=Int)\n\nGet the value of the field A at point coordinates x, y, z at time step step.\n\nReturns: Float64 or Vector{Float64} or Matrix{Float64}\n\nTypes:\n\nA: ScalarField or VectorField or TensorField\nx: Number\ny: Number\nz: Number\nstep: Int\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.probe-Tuple{Union{ScalarField, TensorField, VectorField}, String}","page":"General","title":"LowLevelFEM.probe","text":"probe(A::Union{ScalarField,VectorField,TensorField}, s::String; step=Int)\n\nGet the value of the field A at a point given by its physical name in Gmsh at time step step.\n\nReturns: Float64 or Vector{Float64} or Matrix{Float64}\n\nTypes:\n\nA: ScalarField or VectorField or TensorField\nx: Number\ny: Number\nz: Number\nstep: Int\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.projectTo2D-Tuple{VectorField}","page":"General","title":"LowLevelFEM.projectTo2D","text":"projectTo2D(v3D::VectorField)\n\nProject a 3D vector field onto the xy-plane by discarding the z-component.\n\nreturn: VectorField\n\nExamples\n\nV2D = expandTo3D(V3D)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.resultant-Tuple{VectorField, String}","page":"General","title":"LowLevelFEM.resultant","text":"resultant(field, phName)\n\nComputes the resultant of vector field field on the physical group phName. Returns the resultant(s) in a tuple. The number of elements in the tuple depends on the dimension of problem (dimension of field). It can solve for example the resultant of a load vector (sum of the elements of the vector).\n\nReturn: resx\n\nor\n\nReturn: resx, resy\n\nor\n\nReturn: resx, resy, resz\n\nTypes:\n\nfield: VectorField\nphName: String \nresx: Float64 \nresy: Float64 \nresz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}","page":"General","title":"LowLevelFEM.rotateNodes","text":"rotateNodes(problem, phName, CoordSys)\n\nCreates the T transformation matrix, which rotates the nodal coordinate system of the nodes in phName physical group to the coordinate systen defined by CoordSys. The mesh belongs to problem.\n\nReturn: T\n\nTypes:\n\nproblem: Problem\nphName: String\nCoordSys: CoordinateSystem\nT: SparseMatrix\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.saveField-Tuple{String, Union{Number, ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.saveField","text":"saveField(fileName::String, variable::Union{ScalarField,VectorField,TensorField,Number})\n\nSaves variable of type ScalarField, VectorField, or TensorField to a file named fileName. The name of the file will be complemented with the string \"-LLF-Data.jld2\"\n\nReturns: nothing\n\nTypes:\n\nfileName: String\nvariable: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.scalarField-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.scalarField","text":"scalarField(problem, dataField)\n\nDefines a scalar field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem.\n\nReturn: Vector{Float64}\n\nTypes:\n\nproblem: Problem\ndataField: Vector{BoundaryCondition}\n\nExamples\n\nf2 = field(\"face1\", f=1)\nqq = scalarField(problem, [f2])\nqqq = showDoFResults(qq)\n\nqq2 = scalarField(problem, \"body\", 2.0)\n\nHere ScalarField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.setParameter-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.setParameter","text":"setParameter(name, value)\n\nDefines a parameter name and sets its value to value. \n\nReturns: nothing\n\nTypes:\n\nname: String\nvalue: Float64\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.setParameters-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.setParameters","text":"setParameters(name, value)\n\nDefines a parameter name and sets its value to value, which is a Vector{Float64}. \n\nReturns: nothing\n\nTypes:\n\nname: String\nvalue: Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}","page":"General","title":"LowLevelFEM.showBucklingResults","text":"showBucklingResults(Φ, name=..., visible=...)\n\nLoads buckling results into a View in Gmsh. Φ is an Eigen struct. name is a title to display and visible is a Boolean to toggle the initial visibility in Gmsh on or off. Click on ▷| to change the results. This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nΦ: Eigen\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showDoFResults-Tuple{Union{ScalarField, TensorField, VectorField}, Symbol}","page":"General","title":"LowLevelFEM.showDoFResults","text":"showDoFResults(q, comp; name=..., visible=..., factor=0)\n\nLoads nodal results into a View in Gmsh. q is the field to show, comp is the component of the field (:vector, :uvec, :ux, :uy, :uz, :vvec, :vx, :vy, :vz, :qvec, :qx, :qy, :qz, :T, :p, :qn, :s, :sx, :sy, :sz, :sxy, :syx, :syz, :szy, :szx, :sxz, :e, :ex, :ey, :ez, :exy, :eyx, :eyz, :ezy, :ezx, :exz, :seqv, :scalar, :tensor), name is a title to display and visible is a Boolean to toggle the initial visibility in Gmsh on or off. If q has more columns, then a sequence of results will be shown (e.g., as an animation). factor multiplies the DoF result to increase for better visibility. This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nq: ScalarField, VectorField or TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showElementResults-Tuple{Union{ScalarField, TensorField, VectorField}, Any}","page":"General","title":"LowLevelFEM.showElementResults","text":"showElementResults(F, comp; name=..., visible=..., smooth=...)\n\nSame as ShowStressResults or showStrainResults, depending on the type of F data field.\n\nReturn: tag\n\nTypes:\n\nF: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showHeatFluxResults-Tuple{VectorField, Any}","page":"General","title":"LowLevelFEM.showHeatFluxResults","text":"showHeatFluxResults(Q, comp; name=..., visible=..., smooth=...)\n\nLoads heat flux results into a View in Gmsh. Q is a heat flux field to show, comp is the component of the field (:qvec, :qx, :qy, :qz, :q), name is a title to display, visible is a Boolean to toggle the initial visibility in Gmsh on or off, and smooth is a Boolean to toggle smoothing on or off. If Q contains more than one time step, a sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nS: VectorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}","page":"General","title":"LowLevelFEM.showModalResults","text":"showModalResults(Φ, name=..., visible=...)\n\nLoads modal results into a View in Gmsh. Φ is an Eigen struct. name is a title to display and visible is a Boolean to toggle the initial visibility in Gmsh on or off. Click on ▷| to change the results. This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nΦ: Eigen\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showOnSurface-Tuple{Number, String}","page":"General","title":"LowLevelFEM.showOnSurface","text":"showOnSurface(field, phName; grad=false, component=:x, offsetX=0, offsetY=0, offsetZ=0, name=phName, visible=false)\n\nShows the values of a scalar field on a surface with physical name phName. field is the tag of a View in Gmsh. The values of the field are calculated at the intersection with the surface. grad is a Boolean to toggle the gradient of the field on or off. component is the component of the gradient of field (:x, :y, :z) to be shown. offsetX, offsetY, offsetZ are the offsets in the x, y, and z directions where the values are sampled. name is a title to display, and visible is a Boolean to toggle the initial visibility in Gmsh on or off.\n\nReturns: tag\n\nTypes:\n\nfield: Integer\nphName: String\ngrad: Boolean\ncomponent: Symbol\noffsetX: Float64\noffsetY: Float64\noffsetZ: Float64\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showStrainResults-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.showStrainResults","text":"showStrainResults(E, comp; name=..., visible=..., smooth=...)\n\nLoads strain results into a View in Gmsh. E is a strain field to show, comp is the component of the field (:e, :ex, :ey, :ez, :exy, :eyz, :ezx), name is a title to display, visible is a Boolean to toggle the initial visibility in Gmsh on or off and smooth is a Boolean to toggle smoothing the stress field on or off. If E contains more than one time steps, then a  sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nE: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showStressResults-Tuple{TensorField, Any}","page":"General","title":"LowLevelFEM.showStressResults","text":"showStressResults(S, comp; name=..., visible=..., smooth=...)\n\nLoads stress results into a View in Gmsh. S is a stress field to show, comp is the component of the field (:s, :sx, :sy, :sz, :sxy, :syz, :szx, :seqv), name is a title to display, visible is a Boolean to toggle the initial visibility in Gmsh on or off, and smooth is a Boolean to toggle smoothing the stress field on or off. If S contains more than one time step, a sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nS: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.tangentVector-Tuple{Problem, String}","page":"General","title":"LowLevelFEM.tangentVector","text":"tangentVector(problem::Problem, phName::String) -> VectorField\n\nCompute unit tangent vectors for all nodes of a curve-type physical group in a 3D Gmsh model.\n\nArguments\n\nproblem::Problem: A Problem structure containing the current Gmsh model (name, dimension, number of nodes, etc.).\nphName::String: The name of a physical curve group in Gmsh for which the tangent vectors are computed.\n\nDescription\n\nThe function sets the current model, queries the elements and nodes that belong to the given 1D physical group, and evaluates the gradients of the Lagrange basis functions to determine the local mapping derivative ∂x/∂ξ. Since this derivative represents the geometric tangent direction of the curve at each evaluation point, it is normalized to produce a unit tangent vector.\n\nEach node belonging to the physical curve group is assigned the corresponding 3D unit tangent vector aligned with the parametric direction of the curve.\n\nReturns\n\nVectorField: A VectorField structure that stores the nodal tangent vectors on the given physical curve.\n\nErrors\n\nThrows an error if the provided physical group is not of curve type (dim != 1).\n\nExample\n\nusing LowLevelFEM\n\n# Load a 3D geometry containing a curved edge\ngmsh.initialize()\ngmsh.open(\"curve_geometry.msh\")\n\n# Create a problem structure\nmat = material(\"body\")\nprob = Problem([mat])\n\n# Compute tangent vectors along the curve named \"leadingEdge\"\ntv = tangentVector(prob, \"leadingEdge\")\n\n# Visualize the tangent field\nshowDoFResults(tv)\nopenPostProcessor()\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.temperatureConstraint-Tuple{Any}","page":"General","title":"LowLevelFEM.temperatureConstraint","text":"temperatureConstraint(name; T=...)\n\nSpecifies temperature constraints on the physical group name. T can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); temperatureConstraint(\"surf1\", T=fn))\n\nReturns: BoundaryCondition\n\nTypes:\n\nname: String\nT: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.tensorField-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.tensorField","text":"tensorField(problem, dataField; type=...)\n\nDefines a vector field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem. type can be an arbitrary Symbol, e.g., :u or :f.\n\nReturn: TensorField\n\nTypes:\n\nproblem: Problem\ndataField: Vector{BoundaryCondition}\n\nExamples\n\nf1(x, y, z) = sin(x)\nf2(x, y, z) = 5y\nff1 = field(\"face1\", fx=f1, fy=f2, fz=0, fxy=1, fyz=1, fzx=f2)\nff2 = field(\"face2\", fx=f2, fy=f1, fz=1, fxy=1, fyz=f1, fzx=1)\nqq = tensorField(problem, [ff1, ff2])\nqq0 = showDoFResults(qq)\n\nqq2 = tensorField(problem, \"body\", [1 0 0; 0 2 0; 0 0 f1])\n\nHere TensorField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.vectorField-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.vectorField","text":"vectorField(problem, dataField; type=...)\n\nDefines a vector field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem. type can be an arbitrary Symbol, e.g., :u or :f.\n\nReturn: VectorField\n\nTypes:\n\nproblem: Problem\ndataField: Vector{BoundaryCondition}\n\nExamples\n\nf1(x, y, z) = sin(x)\nf2(x, y, z) = 5y\nff1 = field(\"face1\", fx=f1, fy=f2, fz=0)\nff2 = field(\"face2\", fx=f2, fy=f1, fz=1)\nqq = vectorField(problem, [ff1, ff2])\nqq0 = showDoFResults(qq)\n\nqq2 = vectorField(problem, \"body\", [1, 2, ff2])\n\nHere VectorField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.∂-Tuple{ScalarField, Int64}","page":"General","title":"LowLevelFEM.∂","text":"∂(r::ScalarField, dir::Int) -> ScalarField\n\nCompute the spatial derivative of a scalar field in the global x, y, or z direction. The input field may be nodal or elementwise; nodal fields are automatically converted to elementwise form using nodesToElements(r).\n\nArguments\n\nr::ScalarField: scalar field to differentiate.\ndir::Int: spatial direction:\n1 → ∂/∂x  \n2 → ∂/∂y  \n3 → ∂/∂z\n\nReturns\n\nA new ScalarField in elementwise representation, containing   the gradient component ∂r/∂(dir) at all nodes of each element.\n\nNotes\n\nWorks for 1D, 2D, and 3D meshes.\nUses the element Jacobian and shape-function derivatives in global coordinates.\nThe global problem mesh is accessed via r.model.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.∂e-Tuple{ScalarField, Int64}","page":"General","title":"LowLevelFEM.∂e","text":"∂e(r::ScalarField, dir::Int) -> ScalarField\n\nCompute the spatial derivative of an elementwise scalar field purely at the element level, without nodal conversion. This avoids mixing contributions from neighboring elements and is suitable for discontinuous fields or post-processing of elementwise quantities.\n\nArguments\n\nr::ScalarField: must already be elementwise (isElementwise(r) == true).\ndir::Int: spatial direction (1 → x, 2 → y, 3 → z).\n\nReturns\n\nAn elementwise ScalarField containing the derivative ∂r/∂(dir) at the local nodes of each element.\n\nNotes\n\nUses the element-local Jacobian per integration point.\nSafer for interfaces or discontinuities than nodal differentiation.\nOnly elementwise → elementwise transformations are performed.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.∂x-Tuple{ScalarField}","page":"General","title":"LowLevelFEM.∂x","text":"∂x(r::ScalarField)\n∂y(r::ScalarField)\n∂z(r::ScalarField)\n\nCompute directional derivatives of a scalar field r with respect to the global coordinates x, y, or z.\n\nThese functions are convenience wrappers that automatically choose between   the nodal differentiation (∂) and the elementwise differentiation (∂e) depending on the representation of the input field.\n\nDispatch logic\n\nIf isNodal(r) is true:  \n∂x(r) → ∂(r, 1)  \n∂y(r) → ∂(r, 2)  \n∂z(r) → ∂(r, 3)  \nOtherwise (elementwise field):  \n∂x(r) → ∂e(r, 1)  \n∂y(r) → ∂e(r, 2)  \n∂z(r) → ∂e(r, 3)\n\nCoordinate conventions\n\nIn 3D: (x, y, z) are the global Cartesian coordinates.\nIn 2D (plane stress/strain):  \n∂x and ∂y operate in the plane.  \n∂z is mathematically allowed and returns zero for planar meshes.\n\nReturns\n\nA ScalarField storing the derivative in elementwise representation.\n\nExamples\n\n1) Derivative of a nodal field (automatic nodal→element conversion)\n\ns = ScalarField(prob, \"vol\", (x,y,z) -> x^2 + y)\n\ndxs = ∂x(s)      # computes 2x\ndys = ∂y(s)      # computes 1\ndzs = ∂z(s)      # computes 0\n\n2) Derivative of an elementwise field\n\nse = elementsToNodes(s) |> r -> ∂e(r, 1)  # manually\ndxs = ∂x(se)                              # same result, auto-detected\n\n3) Works on 2D meshes as well\n\ns = ScalarField(prob2D, \"surf\", (x,y,z) -> x - y)\n\ndxs = ∂x(s)      # = 1 everywhere\ndys = ∂y(s)      # = -1 everywhere\ndzs = ∂z(s)      # = zero field (2D mesh)\n\n4) Using derivatives to build a gradient vector field\n\ns = ScalarField(prob, \"vol\", (x,y,z) -> sin(x)*y)\n\ngx = ∂x(s)       # y*cos(x)\ngy = ∂y(s)       # sin(x)\ngz = ∂z(s)       # 0\n\ngrad_s = VectorField([gx, gy, gz])\n\nNotes\n\nThe output is always elementwise, enabling consistent post-processing.\nDirection indices follow FEM convention: 1 → x, 2 → y, 3 → z.\n\n\n\n\n\n","category":"method"},{"location":"#LowLevelFEM","page":"Introduction","title":"LowLevelFEM","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"LowLevelFEM is a Julia package for finite element analysis with an engineering-first workflow, designed to assemble finite element operators explicitly at matrix and field level.   It exposes each phase of the workflow as simple functions (mesh → matrices → loads/BCs → solve → postprocess → visualize), so you can customize, combine, or inspect any step at matrix and field level.   Typical tasks such as strain energy or resultants are one-liners (for example, U = q' * K * q / 2). The package is suitable not only for classical structural mechanics problems, but also for assembling general linear PDEs expressed in weak form.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Operator-level FEM workflow in LowLevelFEM)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Operator-level finite element workflow in LowLevelFEM. Weak forms are discretized into elementary differential operators (grad, div, curl), which are assembled into bilinear forms and global system matrices.","category":"page"},{"location":"#Requirements","page":"Introduction","title":"Requirements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia 1.x\nGmsh C API is bundled via gmsh_jll and re-exported as gmsh from this package; no separate Gmsh.jl installation is required.","category":"page"},{"location":"#Capabilities","page":"Introduction","title":"Capabilities","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Geometry and meshing: integrates with gmsh for 2D/3D geometry, meshing, and physical groups.\nProblem types: 3D solids, 2D plane stress/plane strain, axisymmetric; 3D/2D heat conduction and axisymmetric heat conduction.\nElements and order: standard line/triangle/quad/tetra/hex/pyramid/wedge with Lagrange order up to 10.\nMaterials: linear elastic (Hooke) and large deformation laws (St. Venant–Kirchhoff, compressible Neo-Hooke).\nMatrices: stiffness K, mass M (lumped or consistent), proportional damping C (Rayleigh/Caughey), heat conduction/capacity, latent heat, convection matrices/vectors, and generic Poisson-type operators for scalar and vector fields.\nMatrix- and field-oriented FEM workflow: global stiffness, mass, damping and coupling matrices, together with scalar, vector and tensor fields, are explicit and user-accessible objects, enabling direct implementation, inspection and modification of PDE operators (including Poisson-type operators) and constitutive laws at matrix and field level.\nLoads and constraints: nodal and distributed loads on physical groups; function-based loads and temperature BCs; elastic supports; initial displacement/velocity/temperature.\nThermal–structural coupling: thermal expansion, thermal stresses, and heat generated by elastic deformation.\nSolvers: static (direct and iterative solvers with arbitrary preconditioners) and transient dynamics (central difference and HHT-α from the Newmark family).\nEigenproblems: modal analysis (frequencies and mode shapes, optionally prestressed) and linear buckling (critical factors and modes).\nField operators and results: gradient/divergence/curl; stress/strain and heat flux as element or nodal fields; smoothing at nodes with field jumps; user-defined scalar/vector/tensor FE fields.\nVisualization and plots: Gmsh-based views for displacements, stresses, strains, heat flux, with animation for dynamics; plot results along user-defined paths; show results on surfaces.\nCoordinate systems: rotate nodal DOFs with constant or function-defined local coordinate systems (incl. curvilinear).\nTruss structures (static, transient, modal analysis)","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"LowLevelFEM\")","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using LowLevelFEM\n\n# `gmsh` is exported by LowLevelFEM\ngmsh.initialize()\ngmsh.open(\"your_model.geo\")\n\nmat = Material(\"body\", E=2e5, ν=0.3)\nprob = Problem([mat], type=:PlaneStress)  # :Solid, :PlaneStrain, :AxiSymmetric, :HeatConduction, ...\n\nbc    = displacementConstraint(\"supp\", ux=0, uy=0)\nforce = load(\"load\", fy=-1)\n\nu = solveDisplacement(prob, load=[force], support=[bc])\nS = solveStress(u)\n\nshowDoFResults(u)\nshowDoFResults(u, :ux)\nshowStressResults(S)\nshowStressResults(S, :sxy, name=\"Shear stress\")\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note: physical group names in your geometry (created in Gmsh) must match the strings used above (e.g., \"body\", \"supp\", \"load\").","category":"page"},{"location":"#An-alternative-solution-(instead-of-u-...,-S-...)","page":"Introduction","title":"An alternative solution (instead of u = ..., S = ...)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"K = stiffnessMatrix(prob)\nf = loadVector(prob, [force])\nu = solveDisplacement(K, f, support=[bc])\n\nE = mat.E\nν = mat.ν\n\nA = (u ∘ ∇ + ∇ ∘ u) / 2\nI = TensorField(prob, \"body\", [1 0 0; 0 1 0; 0 0 1])\nS = E / (1 + ν) * (A + ν / (1 - 2ν) * trace(A) * I)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More end-to-end examples are available under examples and in the documentation.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Latest docs: https://perebalazs.github.io/LowLevelFEM.jl/dev\nStable docs: https://perebalazs.github.io/LowLevelFEM.jl/stable","category":"page"},{"location":"#Planned-features","page":"Introduction","title":"Planned features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Other material laws (incompressible Neo-Hooke, Mooney-Rivlin, etc.)\nBeam, shell elements\nContact problems (penalty, Lagrange multiplier)\nMultithreading (partially implemented)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Any suggestions are welcome. In case of any issue, please send a bug report.","category":"page"},{"location":"#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This project is licensed under the MIT License — see LICENSE for details.","category":"page"}]
}
