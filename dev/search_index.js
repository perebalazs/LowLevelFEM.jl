var documenterSearchIndex = {"docs":
[{"location":"Operators/#Operators-and-Algebra","page":"Operators","title":"Operators and Algebra","text":"","category":"section"},{"location":"Operators/#Base.:*-Tuple{Number, ScalarField}","page":"Operators","title":"Base.:*","text":"*(b::Number, A::ScalarField)\n\nPerforms multiplication of a ScalarField objects and a Number.\n\nReturn: ScalarField\n\nExamples\n\nC = 2.0 * A\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{ScalarField, Number}","page":"Operators","title":"Base.:*","text":"*(A::ScalarField, b::Number)\n\nPerforms multiplication of a ScalarField objects and a Number.\n\nReturn: ScalarField\n\nExamples\n\nC = A * 2.0\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:*","text":"*(A::ScalarField, B::ScalarField)\n\nPerforms element-wise multiplication of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A * B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{ScalarField, VectorField}","page":"Operators","title":"Base.:*","text":"*(A::ScalarField, B::VectorField)\n\nScales a VectorField by a ScalarField element-wise on matching elements.\n\nReturns: VectorField\n\nExamples\n\nv2 = s .* v  # equivalent to s * v\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{TensorField, TensorField}","page":"Operators","title":"Base.:*","text":"*(A::TensorField, B::TensorField)\n\nTensor contraction (matrix multiplication) for each element/node: reshapes 9×1 blocks into 3×3, multiplies, then flattens back.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:*-Tuple{VectorField, ScalarField}","page":"Operators","title":"Base.:*","text":"*(B::VectorField, A::ScalarField)\n\nScales a VectorField by a ScalarField element-wise on matching elements.\n\nReturns: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:+-Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:+","text":"+(A::ScalarField, B::ScalarField)\n\nPerforms element-wise addition of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A + B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:--Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:-","text":"-(A::ScalarField, B::ScalarField)\n\nPerforms element-wise subtraction of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A - B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:/-Tuple{ScalarField, ScalarField}","page":"Operators","title":"Base.:/","text":"/(A::ScalarField, B::ScalarField)\n\nPerforms element-wise division of two ScalarField objects on the same set of elements.\n\nReturns: ScalarField\n\nExamples\n\nC = A / B\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:/-Tuple{VectorField, ScalarField}","page":"Operators","title":"Base.:/","text":"/(B::VectorField, A::ScalarField)\n\nDivides a VectorField by a ScalarField element-wise on matching elements.\n\nReturns: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:∘-Tuple{Function, Union{ScalarField, VectorField}}","page":"Operators","title":"Base.:∘","text":"∘(D::Function, A::Union{ScalarField,VectorField})\n\nLeft application of differential operator D to field A.\n\nIf D == ∇ and A is ScalarField: returns grad(A).\nIf D == ∇ and A is VectorField: returns grad(A)' (transpose).\n\nReturns: VectorField or TensorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->x, fy=y->y, fz=z->z)])\nT = ∇ ∘ V      # equals grad(V)'\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.:∘-Tuple{Union{ScalarField, VectorField}, Function}","page":"Operators","title":"Base.:∘","text":"∘(A::Union{ScalarField,VectorField}, D::Function)\n\nRight application of differential operator D to field A.\n\nIf D == ∇ and A is ScalarField: returns grad(A).\nIf D == ∇ and A is VectorField: returns grad(A).\n\nReturns: VectorField or TensorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nS = scalarField(problem, [field(\"body\", f=(x,y,z)->x*y)])\nG = S ∘ ∇      # grad of scalar field\nV = vectorField(problem, [field(\"body\", fx=x->x, fy=y->y, fz=z->z)])\nH = V ∘ ∇      # grad of vector field (tensor)\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.adjoint-Tuple{TensorField}","page":"Operators","title":"Base.adjoint","text":"adjoint(A::TensorField)\n\nAdjoint (conjugate transpose) of each 3×3 tensor block.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.inv-Tuple{TensorField}","page":"Operators","title":"Base.inv","text":"inv(A::TensorField)\n\nMatrix inverse of each 3×3 tensor block.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#Base.transpose-Tuple{TensorField}","page":"Operators","title":"Base.transpose","text":"transpose(A::TensorField)\n\nTransposes each 3×3 tensor block.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:×-Tuple{Function, VectorField}","page":"Operators","title":"LinearAlgebra.:×","text":"×(D::Function, A::VectorField)\n\nLeft curl. With D == ∇, returns curl(A).\n\nReturns: VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->0, fy=x->x, fz=z->0)])\nC = ∇ × V\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:×-Tuple{VectorField, Function}","page":"Operators","title":"LinearAlgebra.:×","text":"×(A::VectorField, D::Function)\n\nRight curl with sign convention. With D == ∇, returns -curl(A).\n\nReturns: VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->0, fy=x->x, fz=z->0)])\nCneg = V × ∇   # -curl(V)\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:×-Tuple{VectorField, VectorField}","page":"Operators","title":"LinearAlgebra.:×","text":"×(a::VectorField, b::VectorField)\n\nElement-wise 3D vector cross product on matching elements.\n\nReturns: VectorField\n\nExamples\n\nw = u × v\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:⋅-Tuple{Function, Union{TensorField, VectorField}}","page":"Operators","title":"LinearAlgebra.:⋅","text":"⋅(D::Function, A::Union{VectorField,TensorField})\n\nLeft contraction with the differential operator. With D == ∇:\n\nIf A is VectorField: returns div(A).\nIf A is TensorField: returns div(A').\n\nReturns: ScalarField or VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nT = tensorField(problem, [field(\"body\", fz=z->z)])\nDV = ∇ ⋅ T     # VectorField (divergence of tensor)\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:⋅-Tuple{TensorField, TensorField}","page":"Operators","title":"LinearAlgebra.:⋅","text":"⋅(A::TensorField, B::TensorField)\n\nElement-wise (Hadamard) product followed by summation of all components, yielding a scalar per tensor (i.e., Frobenius inner product).\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.:⋅-Tuple{Union{TensorField, VectorField}, Function}","page":"Operators","title":"LinearAlgebra.:⋅","text":"⋅(A::Union{VectorField,TensorField}, D::Function)\n\nRight contraction with the differential operator. With D == ∇:\n\nIf A is VectorField: returns div(A) (scalar field).\nIf A is TensorField: returns div(A) (vector field).\n\nReturns: ScalarField or VectorField\n\nExamples\n\n# 3D (assumes `problem` and a \"body\" physical group are defined)\nV = vectorField(problem, [field(\"body\", fx=x->x, fy=y->y, fz=z->z)])\ndivV = V ⋅ ∇   # ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.det-Tuple{TensorField}","page":"Operators","title":"LinearAlgebra.det","text":"det(A::TensorField)\n\nComputes the determinant of each 3×3 tensor block.\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.diagm-Tuple{VectorField}","page":"Operators","title":"LinearAlgebra.diagm","text":"diagm(A::VectorField)\n\nCreates a diagonal TensorField from a VectorField (dim=3), i.e., places vector components on the tensor diagonal for each node/element.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LinearAlgebra.norm-Tuple{VectorField}","page":"Operators","title":"LinearAlgebra.norm","text":"norm(A::VectorField)\n\nElement-wise Euclidean norm of a VectorField.\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LowLevelFEM.trace-Tuple{TensorField}","page":"Operators","title":"LowLevelFEM.trace","text":"trace(A::TensorField)\n\nComputes the trace of each 3×3 tensor block.\n\nReturns: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Operators/#LowLevelFEM.unitTensor-Tuple{TensorField}","page":"Operators","title":"LowLevelFEM.unitTensor","text":"unitTensor(A::TensorField)\n\nCreates an identity tensor field (I) with the same element structure and time steps as A.\n\nReturns: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#Nonlinear-Mechanics-and-Fields","page":"Nonlinear","title":"Nonlinear Mechanics and Fields","text":"","category":"section"},{"location":"Nonlinear/#Base.div-Tuple{Union{TensorField, VectorField}}","page":"Nonlinear","title":"Base.div","text":"div(r::Union{VectorField,TensorField})\n\nSolves the divergence of the vector field or tensor field r. An alternative way to solve div is to use ∇ as a differencial operator.\n\nReturn: ScalarField or VectorField\n\nTypes:\n\nr: VectorField or TensorField\n\n3D Examples (assumes problem is set as in the ∇ doc setup)\n\n# Assumes a 3D mesh with physical group \"body\".\n\n# 1) Divergence of a 3D vector field → ScalarField\nv1(X,Y,Z) = X\nv2(X,Y,Z) = Y\nv3(X,Y,Z) = Z\nv = vectorField(problem, [field(\"body\", fx=v1, fy=v2, fz=v3)])\nD1 = div(v)\nD2 = ∇ ⋅ v\n\n# 2) Divergence of a 3D tensor field → VectorField\nfsz(X, Y, Z) = 10 - Z\nS = tensorField(problem, [field(\"body\", fz=fsz)])\nb1 = -div(S)\nb2 = -S ⋅ ∇\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.applyDeformationBoundaryConditions!-Tuple{Any, Any}","page":"Nonlinear","title":"LowLevelFEM.applyDeformationBoundaryConditions!","text":"applyDeformationBoundaryConditions!(deformVec, supports)\n\nApplies displacement boundary conditions supports on deformation vector deformVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturns: nothing\n\nTypes:\n\ndeformVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.curl-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.curl","text":"curl(r::VectorField)\n\nSolves the rotation of the vector field r. An alternative way to solve curl is to use ∇ as a differencial operator.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n3D Example (assumes problem is set as in the ∇ doc setup)\n\n# Assumes a 3D mesh with physical group \"body\".\nvx(X, Y, Z) = 0\nvy(X, Y, Z) = X\nvz(X, Y, Z) = 0\nv = vectorField(problem, [field(\"body\", fx=vx, fy=vy, fz=vz)])\nD1 = curl(v)\nD2 = ∇ × v\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.equivalentNodalForce-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.equivalentNodalForce","text":"equivalentNodalForce(r::VectorField)\n\nSolves the equivalent nodal force (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.grad-Tuple{Union{ScalarField, VectorField}}","page":"Nonlinear","title":"LowLevelFEM.grad","text":"grad(r::Union{ScalarField,VectorField})\n\nSolves the gradient of the scalar field or vector field r. An alternative way to solve grad is to use ∇ as a differencial operator.\n\nReturn: VectorField or TensorField\n\nTypes:\n\nr: ScalarField or VectorField\n\n3D Examples\n\n# Assumes a 3D mesh with physical group \"body\".\n\n# 1) Gradient of a 3D scalar field → VectorField\nf(X,Y,Z) = X^2 + Y*Z\nS = scalarField(problem, [field(\"body\", f=f)])\nG1 = grad(S)\nG2 = ∇(S)\n\n# 2) Gradient of a 3D vector field → TensorField\nvx(X,Y,Z) = X\nvy(X,Y,Z) = Y\nvz(X,Y,Z) = Z\nV = vectorField(problem, [field(\"body\", fx=vx, fy=vy, fz=vz)])\nT1 = grad(V)\nT2 = V ∘ ∇\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.nodePositionVector-Tuple{Any}","page":"Nonlinear","title":"LowLevelFEM.nodePositionVector","text":"nodePositionVector(problem)\n\nReturns the position vectors of all mesh nodes as a VectorField (initial configuration).\n\nReturns: R\n\nTypes:\n\nproblem: Problem\nR: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.nonFollowerLoadVector-Tuple{VectorField, Any}","page":"Nonlinear","title":"LowLevelFEM.nonFollowerLoadVector","text":"nonFollowerLoadVector(r::VectorField, load)\n\nSolves the non-follower load vector (when solving large deformation problems). r is the position vector field in the current configuration.\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.rot-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.rot","text":"rot(r::VectorField)\n\nSolves the rotation of the vector field r. In some countries \"rot\" denotes the English \"curl\". (See the curl function.)\n\nReturn: VectorField\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.showDeformationResults-Tuple{VectorField, Any}","page":"Nonlinear","title":"LowLevelFEM.showDeformationResults","text":"showDeformationResults(r::VectorField, comp; name=String, visible=Boolean)\n\nShows deformation result, where r contains the position vectors of nodes  in the current configuration.\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.solveDeformation-Tuple{Any, Any, Any}","page":"Nonlinear","title":"LowLevelFEM.solveDeformation","text":"solveDeformation(problem::Problem, load, supp;\n                followerLoad=false,\n                loadSteps = 3,\n                rampedLoad = true,\n                rampedSupport = false,\n                maxIteration = 10,\n                saveSteps = false,\n                saveIterations = false,\n                plotConvergence = false,\n                relativeError = 1e-5,\n                initialDeformation=nodePositionVector(problem))\n\nSolves the deformed shape of a non-linearly elastic body...\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.suppressDeformationAtBoundaries!-Tuple{Any, Any, Any}","page":"Nonlinear","title":"LowLevelFEM.suppressDeformationAtBoundaries!","text":"suppressDeformationAtBoundaries!(stiffMat, loadVec, supports)\n\nSuppresses the displacements given in support in stiffMat and loadVec  so that it is only necessary to consider them once during iteration. stiffMat is the stiffness matrix, loadVec is the load vector. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturns: nothing\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.suppressDeformationAtBoundaries-Tuple{Any, Any, Any}","page":"Nonlinear","title":"LowLevelFEM.suppressDeformationAtBoundaries","text":"suppressDeformationAtBoundaries(stiffMat, loadVec, supports)\n\nSuppresses the displacements given in support in stiffMat and loadVec  so that it is only necessary to consider them once during iteration. stiffMat is the stiffness matrix, loadVec is the load vector. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturn: stiffMat1, loadVec1\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\nstiffMat1: SystemMatrix \nloadVec1: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.tangentMatrixConstitutive-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.tangentMatrixConstitutive","text":"tangentMatrixConstitutive(r::VectorField)\n\nSolves the constitutive part of the tangent matrix (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: SystemMatrix\n\nTypes:     - r: VectorField\n\n[6]: Javier Bonet, Richard D. Wood: Nonlinear Continuum Mechanics for Finite Element Analysis,  Cambridge University Press, 2008, https://doi.org/10.1017/CBO9780511755446\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.tangentMatrixInitialStress-Tuple{VectorField}","page":"Nonlinear","title":"LowLevelFEM.tangentMatrixInitialStress","text":"tangentMatrixInitialStress(r::VectorField)\n\nSolves the initial stress part of the tangent matrix (when solving large deformation problems). (See [6]) r is the position vector field in the current configuration.\n\nReturn: SystemMatrix\n\nTypes:\n\nr: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Nonlinear/#LowLevelFEM.∇-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"Nonlinear","title":"LowLevelFEM.∇","text":"∇(rr::Union{VectorField, ScalarField, TensorField}; nabla=:grad)\n\nComputes derivatives of rr.\n\nIf rr is a ScalarField and nabla == :grad, returns the gradient (a VectorField).\nIf rr is a VectorField and nabla == :grad, returns the gradient (a TensorField).\nIf rr is a VectorField and nabla == :curl, returns the curl (a VectorField).\nIf rr is a VectorField and nabla == :div, returns the divergence (a ScalarField).\nIf rr is a TensorField and nabla == :div, returns the divergence (a VectorField).\n\nReturns: ScalarField, VectorField, or TensorField\n\nTypes:\n\nrr: ScalarField, VectorField, or TensorField\nnabla: Symbol\n\n3D Examples (assumes problem is set as in the ∇ doc setup)\n\n# One-time 3D setup (assumes examples/Fields/cube.geo exists with physical group \"body\")\nusing LowLevelFEM\ngmsh.initialize()\ngmsh.open(\"examples/Fields/cube.geo\")\nmat = material(\"body\", E=210e3, ν=0.3, ρ=7.85e-9)\nproblem = Problem([mat], type=:Solid)\n\n# 1) Gradient of a 3D scalar field: ∇f → VectorField\nf(X,Y,Z) = X^2 + Y*Z\nS = scalarField(problem, [field(\"body\", f=f)])\nG = ∇(S)  # VectorField with 3 components\n\n# 2) Curl of a 3D vector field: ∇ × v → VectorField\nvx(X,Y,Z) = 0\nvy(X,Y,Z) = X\nvz(X,Y,Z) = 0\nV = vectorField(problem, [field(\"body\", fx=vx, fy=vy, fz=vz)])\nC = ∇(V, nabla=:curl)  # approx (0, 0, 1) everywhere\n\n# 3) Divergence of a 3D vector field: ∇ ⋅ v → ScalarField\nv1(X,Y,Z) = X\nv2(X,Y,Z) = Y\nv3(X,Y,Z) = Z\nV2 = vectorField(problem, [field(\"body\", fx=v1, fy=v2, fz=v3)])\nD = ∇(V2, nabla=:div)  # ≈ 3\n\n# 4) Divergence of a 3D tensor field: ∇ · T → VectorField (if T is TensorField)\n# For example, a diagonal tensor T with only Tzz = g(Z): div(T) = (0, 0, ∂g/∂Z)\ng(Z) = 10 - Z\nT = tensorField(problem, [field(\"body\", fz=g)])\nDV = ∇(T, nabla=:div)  # VectorField\n\n# Symmetric displacement gradient via operators\n# A = (u ∘ ∇ + ∇ ∘ u) / 2\ngmsh.finalize()\n\n\n\n\n\n","category":"method"},{"location":"Linear/#Linear-Mechanics","page":"Linear","title":"Linear Mechanics","text":"","category":"section"},{"location":"Linear/#LowLevelFEM.CDM-NTuple{8, Any}","page":"Linear","title":"LowLevelFEM.CDM","text":"CDM(K, M, C, f, u0, v0, T, Δt)\n\nSolves a transient dynamic problem using central difference method (CDM) (explicit). K is the stiffness Matrix, M is the mass matrix, C is the damping matrix, f is the load vector, u0 is the initial displacement, v0 is the initial velocity, T is the upper bound of the time intervall (lower bound is zero) and Δt is the time step size. Returns the displacement vectors and velocity vectors in each time step arranged in the columns of the two matrices u and v and a vector t of the time instants used.\n\nThe critical (largest allowed) time step is Δtₘₐₓ = Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ) where Tₘᵢₙ is the time period of the largest eigenfrequency and ξₘₐₓ is the largest modal damping.\n\nReturn: u, v\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nC: SystemMatrix\nf: VectorField\nu0: VectorField\nv0: VectorField\nT: Float64\nΔt: Float64 \nu: VectorField\nv: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}","page":"Linear","title":"LowLevelFEM.CDMaccuracyAnalysis","text":"CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)\n\nGives some functions (graphs) for accuracy analysis of the CDM method.  ωₘᵢₙ and ωₘₐₓ are the square root of smallest and largest eigenvalues of the Kϕ=ω²Mϕ eigenvalue problem, Δt is the time step size. type is one of the following values:\n\n:SR: spectral radius\n:PDR: physical damping ratio\n:ADR: algorithmic damping ratio\n:PE: period error\n\nFor details see [3].  n is the number of points in the graph. The damping matrix is assembled in the  following ways: C=αM+βK or C=αM+β₁K+β₂KM⁻¹K+β₃KM⁻¹KM⁻¹K+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (ξ in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (β in the argument list) are the  coefficients of the series. (see [4]) Either ξ or β must be specified. ξ or β are scalars or  vectors. If show_β or show_ξ is true, the corresponding β or ξ values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with plot(xy))\n\n[4]: Serfőző, D., Pere, B.: An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems, Meccanica, https://doi.org/10.1007/s11012-025-02036-9\n\nReturn: xy\n\nTypes:\n\nωₘᵢₙ: Float64\nωₘₐₓ: Float64\nΔt: Float64 \nn: Int64\nα: Float64\nβ: Float64 of Vector{Float64}\nξ: Float64 of Vector{Float64}\nshow_β: Boolean\nshow_ξ: Boolean\nxy: Tuple{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.HHT-NTuple{7, Any}","page":"Linear","title":"LowLevelFEM.HHT","text":"HHT(K, M, f, u0, v0, T, Δt; α=..., δ=..., γ=..., β=...)\n\nSolves a transient dynamic problem using HHT-α method[1] (implicit). K is the stiffness Matrix, M is the mass matrix, f is the load vector,  u0 is the initial displacement, v0 is the initial velocity, T is the  upper bound of the time intervall (lower bound is zero) and Δt is the time  step size. Returns the displacement vectors and velocity vectors in each time  step arranged in the columns of the two matrices u and v and a vector t  of the time instants used. For the meaning of α, β and γ see [1]. If δ is given, γ=0.5+δ and β=0.25⋅(0.5+γ)².\n\n[1]: Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. Improved  numerical dissipation for time integration algorithms in structural  dynamics. Earthquake Engineering & Structural Dynamics 5.3 (1977): 283-292.\n\nReturn: u, v\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nf: VectorField\nu0: VectorField\nv0: VectorField\nT: Float64\nΔt: Float64 \nα: Float64\nβ: Float64\nγ: Float64\nδ: Float64\nu: VectorField\nv: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}","page":"Linear","title":"LowLevelFEM.HHTaccuracyAnalysis","text":"HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)\n\nGives some functions (graphs) for accuracy analysis of the HHT-α method[1].  ωₘᵢₙ and ωₘₐₓ are the square root of smallest and largest eigenvalues of the Kϕ=ω²Mϕ eigenvalue problem, Δt is the time step size. type is one of the following values:\n\n:SR: spectral radius\n:ADR: algorithmic damping ratio\n:PE: period error\n\nFor details see [2] and [3].  n is the number of points in the graph. For the meaning of α, β and γ see [1]. If δ is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with plot(xy))\n\n[2]: Belytschko, Ted, and Thomas JR, Hughes: Computational methods for  transient analysis, North-Holland, (1983).\n\n[3]: Serfőző, D., Pere, B.: A method to accurately define arbitrary algorithmic damping character as viscous damping. Arch Appl Mech 93, 3581–3595 (2023). https://doi.org/10.1007/s00419-023-02454-9\n\nReturn: xy\n\nTypes:\n\nωₘᵢₙ: Float64\nωₘₐₓ: Float64\nΔt: Float64 \nn: Int64\nα: Float64\nβ: Float64\nγ: Float64\nδ: Float64\nxy: Tuple{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, Any, Any}","page":"Linear","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(stiffMat, loadVec, supports)\n\nApplies displacement boundary conditions supports on a stiffness matrix stiffMat and load vector loadVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturns: nothing\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}","page":"Linear","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(heatCondMat, heatCapMat, heatFluxVec, supports)\n\nApplies boundary conditions supports on a heat conduction matrix heatCondMat, heat capacity matrix heatCapMat and heat flux vector heatFluxVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed temperature T.\n\nReturns: nothing\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyBoundaryConditions!-Tuple{LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, LowLevelFEM.SystemMatrix, Any, Any}","page":"Linear","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(stiffMat, massMat, dampMat, loadVec, supports)\n\nApplies displacement boundary conditions supports on a stiffness matrix stiffMat, mass matrix massMat, damping matrix dampMat and load vector loadVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturns: nothing\n\nTypes:\n\nstiffMat: SystemMatrix \nmassMat: SystemMatrix \ndampMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyBoundaryConditions!-Tuple{Problem, Matrix, Any}","page":"Linear","title":"LowLevelFEM.applyBoundaryConditions!","text":"applyBoundaryConditions!(dispVec, supports)\n\nApplies displacement boundary conditions supports on a displacement vector dispVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz.\n\nReturns: nothing\n\nTypes:\n\nproblem: Problem\ndispVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyBoundaryConditions-Tuple{Any, Any, Any}","page":"Linear","title":"LowLevelFEM.applyBoundaryConditions","text":"applyBoundaryConditions(stiffMat, loadVec, supports)\n\nApplies displacement boundary conditions supports on a stiffness matrix stiffMat and load vector loadVec. Mesh details are in problem. supports is a tuple of name of physical group and prescribed displacements ux, uy and uz. Creates a new stiffness matrix and load vector.\n\nReturns: stiffMat, loadVec\n\nTypes:\n\nstiffMat: SystemMatrix \nloadVec: VectorField\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.applyElasticSupport!-Tuple{LowLevelFEM.SystemMatrix, Any}","page":"Linear","title":"LowLevelFEM.applyElasticSupport!","text":"applyElasticSupport!(stiffMat, elastSupp)\n\nApplies elastic support boundary conditions elastSupp on a stiffness matrix stiffMat. Mesh details are in problem. elastSupp is a tuple of name of physical group and prescribed kx, ky and kz stiffnesses.\n\nReturns: nothing\n\nTypes:\n\nstiffMat: SystemMatrix \nelastSupp: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}","page":"Linear","title":"LowLevelFEM.dampingMatrix","text":"dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)\n\nGenerates the damping matrix for proportional damping. C = αM + βK, or C = αM + β₁K + β₂KM⁻¹K + β₃KM⁻¹KM⁻¹K + ⋯. The latter corresponds to a damping characteristic given by a power series in the natural frequencies with odd exponents. ξᵢ (ξ in the arguments) are the values of the individual terms of the series at ωₘₐₓ. βᵢ (β in the arguments) are the coefficients of the series. Either ξ or β must be specified; each may be a scalar or a vector. K is the stiffness matrix, M is the mass matrix, and ωₘₐₓ is the largest natural frequency.\n\nReturns: dampingMatrix\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nωₘₐₓ: Float64\nα: Float64\nξ: Float64 or Vector{Float64}\nβ: Float64 or Vector{Float64}\ndampingMatrix: SystemMatrix\n\nExamples\n\nK = stiffnessMatrix(problem)\nM = massMatrix(problem; lumped=true)\nωmax = 2π * 1000\nC = dampingMatrix(K, M, ωmax; α=0.0, ξ=[0.02, 0.02])\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.elasticSupportMatrix","text":"elasticSupportMatrix(problem, elSupp)\n\nSolves the elastic support matrix of the problem. elSupp is a vector of elastic supports defined in function elasticSupport. With the displacementent vector q in hand the reaction force vector fR arising from the elastic support can be solved. (fR = heatConvMat * q)\n\nReturn: elSuppMat\n\nTypes:\n\nproblem: Problem\nelSupp: Vector{Tuple{String, Float64, Float64, Float64}}\nelSuppMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.getTagForPhysicalName-Tuple{Any}","page":"Linear","title":"LowLevelFEM.getTagForPhysicalName","text":"getTagForPhysicalName(name)\n\nReturns tags of elements of physical group name.\n\nReturns: tags\n\nTypes:\n\nname: String\ntags: Vector{Integer}\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialDisplacement!","text":"initialDisplacement!(name, u0; ux=..., uy=..., uz=...)\n\nChanges the displacement values to ux, uy and uz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in displacement vector u0.\n\nReturn: u0\n\nTypes:\n\nname: String \nux: Float64 \nuy: Float64 \nuz: Float64 \nu0: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialDisplacement-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialDisplacement","text":"initialDisplacement(problem, name; ux=..., uy=..., uz=...)\n\nSets the displacement values ux, uy and uz (depending on the dimension of the problem) at nodes belonging to physical group name. Returns the initial displacement vector u0.\n\nReturn: u0\n\nTypes:\n\nproblem: Problem\nname: String \nu0: VectorField\nux: Float64 \nuy: Float64 \nuz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialVelocity!-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialVelocity!","text":"initialVelocity!(name, v0; vx=..., vy=..., vz=...)\n\nChanges the velocity values vx, vy and vz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in velocity vector v0.\n\nReturns: nothing\n\nTypes:\n\nname: String \nv0: VectorField\nvx: Float64 \nvy: Float64 \nvz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.initialVelocity-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.initialVelocity","text":"initialVelocity(problem, name; vx=..., vy=..., vz=...)\n\nSets the velocity values vx, vy and vz (depending on the dimension of the problem) at nodes belonging to physical group name. Returns the initial velocity vector v0.\n\nReturn: v0\n\nTypes:\n\nproblem: Problem\nname: String \nvx: Float64 \nvy: Float64 \nvz: Float64 \nv0: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.largestEigenValue-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.largestEigenValue","text":"largestEigenValue(K, M)\n\nSolves the smallest eigenvalue for a transient problem given by stiffness (heat conduction) matrix K and the mass (heat capacity) matrix M (C).\n\nReturn: λₘᵢₙ\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nλₘᵢₙ: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.largestPeriodTime","text":"largestPeriodTime(K, M)\n\nSolves the largest period of time for a dynamic problem given by stiffness matrix K and the mass matrix M.\n\nReturn: Δt\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nΔt: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.loadVector-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.loadVector","text":"loadVector(problem, loads)\n\nSolves a load vector of problem. loads is a tuple of name of physical group  name, coordinates fx, fy and fz or pressure p which are intensities of a distributed force. It can solve traction or body force depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated force.\nIn case of 2D problems and Line physical group means surface force.\nIn case of 2D problems and Surface physical group means body force.\nIn case of 3D problems and Point physical group means concentrated force.\nIn case of 3D problems and Line physical group means edge force.\nIn case of 3D problems and Surface physical group means surface force.\nIn case of 3D problems and Volume physical group means body force.\n\nReturn: loadVec\n\nTypes:\n\nproblem: Problem\nloads: Vector{Tuple{String, Float64, Float64, Float64}}\nloadVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.massMatrix-Tuple{Any}","page":"Linear","title":"LowLevelFEM.massMatrix","text":"massMatrix(problem; lumped=...)\n\nSolves the mass matrix of the problem. If lumped is true, computes the lumped mass matrix.\n\nReturns: massMat\n\nTypes:\n\nproblem: Problem\nlumped: Boolean\nmassMat: SystemMatrix\n\nExamples\n\nM = massMatrix(problem; lumped=true)\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.nodalAcceleration!-Tuple{Any}","page":"Linear","title":"LowLevelFEM.nodalAcceleration!","text":"nodalAcceleration!(name, a0; ax=..., ay=..., az=...)\n\nChanges the acceleration values ax, ay and az (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in acceleration vector a0.\n\nReturns: nothing\n\nTypes:\n\nname: String \na0: VectorField\nax: Float64\nay: Float64\naz: Float64\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.nodalForce!-Tuple{Any}","page":"Linear","title":"LowLevelFEM.nodalForce!","text":"nodalForce!(name, f0; fx=..., fy=..., fz=...)\n\nChanges the force values fx, fy and fz (depending on the dimension of the problem) at nodes belonging to physical group name. Original values are in load vector f0.\n\nReturns: nothing\n\nTypes:\n\nname: String \nf0: VectorField\nfx: Float64 \nfy: Float64 \nfz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}","page":"Linear","title":"LowLevelFEM.nonLinearStiffnessMatrix","text":"nonLinearStiffnessMatrix(problem, q)\n\nSolves the nonlinear stiffness matrix of the problem. q is a displacement field.\n\nReturns: stiffMat\n\nTypes:\n\nproblem: Problem\nq: VectorField\nstiffMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.smallestEigenValue-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.smallestEigenValue","text":"smallestEigenValue(K, M)\n\nSolves the largest eigenvalue for a transient problem given by stiffness (heat conduction) matrix K and the mass (heat capacity) matrix M (C).\n\nReturn: λₘₐₓ\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nλₘₐₓ: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.smallestPeriodTime","text":"smallestPeriodTime(K, M)\n\nSolves the smallest period of time for a dynamic problem given by stiffness matrix K and the mass matrix M.\n\nReturn: Δt\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nΔt: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveAxialForce-Tuple{VectorField}","page":"Linear","title":"LowLevelFEM.solveAxialForce","text":"solveAxialForce(u::VectorField)\n\nCompute axial (bar/truss) forces from a displacement field.\n\nThe input displacement field u must be nodal (VectorField), typically containing the nodal displacements of a truss or bar structure.   The output is a scalar field (ScalarField), where each value represents  the axial force in a truss element.\n\nArguments\n\nu::VectorField: nodal displacement field.\n\nReturns\n\nScalarField: axial forces defined per element.\n\nExamples\n\nu = solveDisplacement(problem, [loads], [supports])  # VectorField of nodal displacements\nN = solveAxialForce(u)                               # ScalarField of axial element forces\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveBuckling-Tuple{Any, Any, Any}","page":"Linear","title":"LowLevelFEM.solveBuckling","text":"solveBuckling(problem, loads, constraints; n=6)\n\nSolves the multipliers for the first n critical forces and the corresponding  buckling shapes for the instability of the problem, when loads and  constraints are applied. Result can be presented by showBucklingResults function. loads and constraints can be defined by load and displacementConstraint functions, respectively.\n\nReturn: buckling\n\nTypes:\n\nproblem: Problem\nloads: Vector{tuples}\nconstraints: Vector{tuples}\nn: Int64\nbuckling: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.solveBucklingModes","text":"solveBucklingModes(K, Knl; n=6)\n\nSolves the critical force multipliers and buckling mode shapes of a problem given by stiffness matrix K and the nonlinear stiffness matrix Knl. n is the number of buckling modes to solve. Returns the struct of critical forces and buckling modes. Results can be presented by showBucklingResults function.\n\nReturn: modes\n\nTypes:\n\nK: SystemMatrix\nKnl: SystemMatrix\nn: Int64\nmodes: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveDisplacement-NTuple{4, Any}","page":"Linear","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(problem, load, supp, elSupp; condensed=false)\n\nComputes the displacement vector q for the given problem subject to  loads load, supports supp and elastic supports elSupp. When condensed is true, the  reduced stiffness matrix and load vector are used in the solution. (see load, displacementConstraint and elasticSupport)\n\nReturn: q\n\nTypes:\n\nproblem: Problem \nload: Vector{Tuple} \nsupp: Vector{Tuple}\nelSupp: Vector{Tuple}\ncondensed: Boolean\nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveDisplacement-Tuple{Any, Any, Any}","page":"Linear","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(problem, load, supp; condensed=false)\n\nComputes the displacement vector q for the given problem subject to  loads load and supports supp. When condensed is true, the  reduced stiffness matrix and load vector are used in the solution. (see load, displacementConstraint and elasticSupport)\n\nReturn: q\n\nTypes:\n\nproblem: Problem \nload: Vector{Tuple} \nsupp: Vector{Tuple}\nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveDisplacement-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.solveDisplacement","text":"solveDisplacement(K, q)\n\nSolves the equation K*q=f for the displacement vector q. K is the stiffness Matrix, q is the load vector.\n\nReturn: q\n\nTypes:\n\nK: SystemMatrix \nf: VectorField \nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveEigenModes-Tuple{Any, Any}","page":"Linear","title":"LowLevelFEM.solveEigenModes","text":"solveEigenModes(K, M; n=6, fₘᵢₙ=1.01)\n\nSolves the eigen frequencies and mode shapes of a problem given by stiffness matrix K and the mass matrix M. n is the number of eigenfrequencies to solve, and solves the eigenfrequencies greater than fₘᵢₙ. Returns the struct of eigenfrequencies and eigen modes. Results can be presented by showModalResults function.\n\nReturn: modes\n\nTypes:\n\nK: SystemMatrix\nM: SystemMatrix\nn: Int64\nfₘᵢₙ: Float64\nmodes: Eigen \n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveModalAnalysis-Tuple{Any}","page":"Linear","title":"LowLevelFEM.solveModalAnalysis","text":"solveModalAnalysis(problem; constraints=[]; loads=[], n=6)\n\nSolves the first n eigenfrequencies and the corresponding  mode shapes for the problem, when loads and  constraints are applied. loads and contraints are optional.  Result can be presented by showModalResults function.  loads and constraints can be defined by load and displacementConstraint functions, respectively. If loads are given, it solves the eigenfrequencies of a prestressed structure.\n\nReturn: modes\n\nTypes:\n\nproblem: Problem\nloads: Vector{tuples}\nconstraints: Vector{tuples}\nn: Int64\nmodes: Eigen\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveStrainNew-Tuple{Any}","page":"Linear","title":"LowLevelFEM.solveStrainNew","text":"solveStrain(q; DoFResults=false)\n\nSolves the strain field E from displacement vector q. Strain field is given per elements, so it usually contains jumps at the boundaries of elements. Details of mesh is available in problem. If DoFResults is true, E is a matrix with nodal results. In this case showDoFResults can be used to show the results  (otherwise showStrainResults or showElementResults).\n\nReturn: E\n\nTypes:\n\nq: VectorField\nE: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.solveStressSlow-Tuple{Any}","page":"Linear","title":"LowLevelFEM.solveStressSlow","text":"solveStress(q; T=..., T₀=..., DoFResults=false)\n\nSolves the stress field S from displacement vector q. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in problem. If DoFResults is true, S is a matrix with nodal results. In this case showDoFResults can be used to show the results  (otherwise showStressResults or showElementResults). If the T temperature field (and T₀ initial temperature field if it differs from zero) is given, the function solves also the thermal stresses.\n\nReturn: S\n\nTypes:\n\nq: VectorField\nT: ScalarField\nT₀: ScalarField\nS: TensorField\n\n\n\n\n\n","category":"method"},{"location":"Linear/#LowLevelFEM.stiffnessMatrix-Tuple{Any}","page":"Linear","title":"LowLevelFEM.stiffnessMatrix","text":"stiffnessMatrix(problem)\n\nSolves the stiffness matrix of the problem.\n\nReturns: stiffMat\n\nTypes:\n\nproblem: Problem\nstiffMat: SystemMatrix\n\nExamples\n\nK = stiffnessMatrix(problem)\n\n\n\n\n\n","category":"method"},{"location":"Heat/#Heat-Conduction","page":"Heat","title":"Heat Conduction","text":"","category":"section"},{"location":"Heat/#LowLevelFEM.FDM-NTuple{6, Any}","page":"Heat","title":"LowLevelFEM.FDM","text":"FDM(K, C, q, T0, tₘₐₓ, Δt; ϑ=...)\n\nSolves a transient heat conduction problem using Finite Difference Method (FDM). Introducing a ϑ parameter, special cases can be used as the Forward Euler (explicit, ϑ=0), Backward Euler (implicit, ϑ=1), Crank-Nicolson (ϑ=0.5) and intermediate cases (0<ϑ<1). (This method is known as ϑ-method. See [5].) K is the heat conduction matrix, C is the heat capacity matrix, q is the heat flux vector, T0 is the initial temperature, tₘₐₓ is the upper  bound of the time intervall (lower bound is zero) and Δt is the time step size. Returns the nodal temperature vectors in each time  step arranged in the columns of the matrix T and a vector t of the time instants used.\n\nThe critical (largest allowed) time step is Δtₘₐₓ = 2 / ((1-2ϑ)*λₘₐₓ) where λₘₐₓ is the largest eigenvalue of (K+λC)θ=0  eigenvalue problem and ϑ is the parameter of the ϑ-method. Default value of ϑ is 1/2.\n\n[5]: Bathe, K. J.: Finite element procedures, Wiley, 1983, https://doi.org/10.1002/nag.1610070412\n\nReturn: T\n\nTypes:\n\nK: SystemMatrix\nC: SystemMatrix\nq: ScalarField\nT0: ScalarField\ntₘₐₓ: Float64\nΔt: Float64 \nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.applyHeatConvection!-Tuple{Any, Any, Any}","page":"Heat","title":"LowLevelFEM.applyHeatConvection!","text":"applyHeatConvection!(heatCondMat, heatFluxVec, heatConv)\n\nApplies heat convectiom boundary conditions heatConv on a heat conduction matrix heatCondMat and heat flux vector heatFluxVec. Mesh details are in problem. heatConv is a tuple of name of physical group and prescribed heat transfer coefficient h and ambient temperature Tₐ. The ambient temperature can be either a constant or a  function of x, y and z coordinates.\n\nReturns: nothing\n\nTypes:\n\nproblem: Problem\nheatCondMat: SystemMatrix \nheatFluxVec: VectorField\nheatConv: Vector{Tuple{String, Float64, Float64, Float64}}\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatCapacityMatrix-Tuple{Any}","page":"Heat","title":"LowLevelFEM.heatCapacityMatrix","text":"heatCapacityMatrix(problem; lumped=...)\n\nSolves the heat capacity matrix of the problem. If lumped is true, solves lumped heat capacity matrix.\n\nReturn: heatCapMat\n\nTypes:\n\nproblem: Problem\nlumped: Boolean\nmassMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatConductionMatrix-Tuple{Any}","page":"Heat","title":"LowLevelFEM.heatConductionMatrix","text":"heatConductionMatrix(problem)\n\nSolves the heat conduction matrix of the problem.\n\nReturns: heatCondMat\n\nTypes:\n\nproblem: Problem\nheatCondMat: SystemMatrix\n\nExamples\n\nKth = heatConductionMatrix(problem)\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatConvectionMatrix-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatConvectionMatrix","text":"heatConvectionMatrix(problem, heatConvection)\n\nSolves the heat convection matrix of the problem. heatConvection  is a vector of heat convection boundary condicions defined in function heatConduction. With the heat convection vector (see the heatConvectionVector function) heatConvVec, temperature field vector T in hand the heat flux vector qCV arising from the heat convection boundary condition can be solved. qCV = heatConvMat * T - heatConvVec\n\nReturn: heatConvMat\n\nTypes:\n\nproblem: Problem\nheatConvection: Vector{Tuple{String, Float64, Float64, Float64}}\nheatConvMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatConvectionVector-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatConvectionVector","text":"heatConvectionVector(problem, heatConvection)\n\nSolves a heat convection vector of problem. heatConvection  is a vector of heat convection boundary condicions defined in function heatConduction. With the heat convection matrix (see the heatConvectionMatrix function) heatConvMat, temperature field vector T in hand the heat flux vector qCV arising from the heat convection boundary condition can be solved. qCV = heatConvMat * T - heatConvVec\n\nReturn: heatConvVec\n\nTypes:\n\nproblem: Problem\nheatConvection: Vector{Tuple{String, Float64, Float64, Float64}}\nheatConvVec: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatFluxVector-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatFluxVector","text":"heatFluxVector(problem, heatFlux)\n\nSolves a heat flux or heat source vector of problem. heatFlux is a tuple of name of physical group  name, heat flux qn normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated heat flux.\nIn case of 2D problems and Line physical group means surface heat flux.\nIn case of 2D problems and Surface physical group means body heat source.\nIn case of 3D problems and Point physical group means concentrated heat flux.\nIn case of 3D problems and Line physical group means edge heat source.\nIn case of 3D problems and Surface physical group means surface heat flux.\nIn case of 3D problems and Volume physical group means body heat source.\n\nReturn: heatFluxVec\n\nTypes:\n\nproblem: Problem\nheatFlux: Vector{Tuple{String, Float64, Float64, Float64}}\nheatFluxVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.heatSourceVector-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.heatSourceVector","text":"heatSourceVector(problem, heatSource)\n\nSolves a heat flux or heat source vector of problem. heatSource is a tuple of name of physical group  name, heat flux qn normal to the surface of the body. The outward direction is positive. It can solve heat flux (or heat source) depending on the problem.\n\nIn case of 2D problems and Point physical group means concentrated heat flux.\nIn case of 2D problems and Line physical group means surface heat flux.\nIn case of 2D problems and Surface physical group means body heat source.\nIn case of 3D problems and Point physical group means concentrated heat flux.\nIn case of 3D problems and Line physical group means edge heat source.\nIn case of 3D problems and Surface physical group means surface heat flux.\nIn case of 3D problems and Volume physical group means body heat source.\n\nSame as the heatFluxVector function.\n\nReturn: heatSourceVec\n\nTypes:\n\nproblem: Problem\nheatSource: Vector{Tuple{String, Float64, Float64, Float64}}\nheatSourceVec: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.initialTemperature!-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.initialTemperature!","text":"initialTemperature!(name, T0; T=...)\n\nChanges the tempetature value to T at nodes belonging to physical group name. Original values are in temperature vector T0.\n\nReturns: nothing\n\nTypes:\n\nname: String \nT0: ScalarField\nT: Float64 \n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.initialTemperature-Tuple{Any, Any}","page":"Heat","title":"LowLevelFEM.initialTemperature","text":"initialTemperature(problem, name; T=...)\n\nSets the temperature value T at nodes belonging to physical group name. Returns the T0 initial nodal temperature vector.\n\nReturn: T0\n\nTypes:\n\nproblem: Problem\nname: String \nT: Float64 \nT0: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.latentHeatMatrix-Tuple{Any, Any, Any}","page":"Heat","title":"LowLevelFEM.latentHeatMatrix","text":"latentHeatMatrix(problem, u, v, T0)\n\nSolves the latent heat matrix of the problem. With this matrix the generated heat due to deformations (given with displacement field u and velocity field v) can be solved. T0 is the current temperature field which is given in absolute temperature scale (Kelvin).\n\nReturn: latHeatMat\n\nTypes:\n\nproblem: Problem\nu: VectorField\nv: VectorField\nT0: ScalarField\nlatHeatMat: SystemMatrix\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveHeatFlux-Tuple{Any}","page":"Heat","title":"LowLevelFEM.solveHeatFlux","text":"solveHeatFlux(T; DoFResults=false)\n\nSolves the heat flux field q from temperature vector T. heat flux is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in problem. If DoFResults is true, q is a matrix with nodal results. In this case showDoFResults can be used to show the results (otherwise showHeatFluxResults or showElementResults).\n\nReturn: q\n\nTypes:\n\nproblem: Problem\nT: ScalarField\nq: VectorField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveTemperature-NTuple{4, Any}","page":"Heat","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem, flux, temp, heatconv)\n\nSolves the temperature field T of problem with given heat flux flux, temperature temp and heat convection heatconv.\n\nReturn: T\n\nTypes:\n\nproblem: Problem \nflux: Vector{Tuple} \ntemp: Vector{Tuple}\nheatconv: Vector{Tuple}\nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveTemperature-Tuple{Any, Any, Any}","page":"Heat","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem, flux, temp)\n\nSolves the temperature field T of problem with given heat flux flux and temperature temp.\n\nReturn: T\n\nTypes:\n\nproblem: Problem \nflux: Vector{Tuple} \ntemp: Vector{Tuple}\nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveTemperature-Tuple{Any, VectorField}","page":"Heat","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(problem, u; T0=273.0)\n\nSolves the raise of temperature T during reversible (no dissipation) elastic deformations, where u is the displacement field, and problem is a heat cunduction problem.\n\nReturn: T\n\nTypes:\n\nproblem: Problem \nu: VectorField \nT0: Float64\nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Heat/#LowLevelFEM.solveTemperature-Tuple{LowLevelFEM.SystemMatrix, ScalarField}","page":"Heat","title":"LowLevelFEM.solveTemperature","text":"solveTemperature(K, q)\n\nSolves the equation K*T=q for the temperature field T. K is the heat conduction matrix, q is the heat flux vector.\n\nReturn: T\n\nTypes:\n\nK: SystemMatrix \nq: ScalarField \nT: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/#2D-Cantilever","page":"Examples","title":"2D Cantilever","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ on deformed shape)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ and $\\tau_{yx}$ on path)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever2D.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\ngmsh.open(\"cantilever2D.geo\")\nmat = material(\"body\", E=2e5, ν=0.3)\nproblem = Problem([mat], type=:PlaneStress)\n\nsupp = displacementConstraint(\"supp\", ux=0, uy=0)\nload = load(\"load\", fy=-1)\n\nq = solveDisplacement(problem, [load], [supp])\nS = solveStress(q)\n\nu = showDoFResults(q, :uvec)\nux = showDoFResults(q, :ux)\nuy = showDoFResults(q, :uy)\n\ns = showStressResults(S, :s, visible=true, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\n\nplotOnPath(\"path\", sx, name=\"σx\", visible=false)\nplotOnPath(\"path\", sxy, name=\"τxy\", visible=false)\nplotOnPath(\"path\", ux, name=\"ux\", visible=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever2D.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"SetFactory(\"OpenCASCADE\");\n\nRectangle(1) = {0, 0, 0, 100, 10, 0};\n\nPhysical Curve(\"supp\", 5) = {4};\nPhysical Curve(\"load\", 6) = {2};\nPhysical Surface(\"body\", 7) = {1};\n\nRecombine Surface {1};\n\nTransfinite Line {2,4} = 4;\nTransfinite Line {1,3} = 31;\nTransfinite Surface {1};\n\nMesh.ElementOrder = 3;\n\nSetName \"cantilever2D\";\nMesh 2;\n\nPoint(5) = {10, 0, 0, 1.0};\nPoint(6) = {10, 10, 0, 1.0};\nLine(5) = {5, 6};\n\nPhysical Curve(\"path\", 8) = {5};","category":"page"},{"location":"Examples/#3D-Cantilever","page":"Examples","title":"3D Cantilever","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: $\\sigma_x$ on deformed shape)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever3D.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\ngmsh.open(\"cantilever3D.geo\")\nmat = material(\"body\", E=2e5, ν=0.3)\nproblem = Problem([mat])\n\nsupp = displacementConstraint(\"supp\", ux=0, uy=0, uz=0)\nld = load(\"load\", fy=-1)\n\nK = stiffnessMatrix(problem)\nf = loadVector(problem, [ld])\n\napplyBoundaryConditions!(K, f, [supp])\n\nq = solveDisplacement(K, f)\nS = solveStress(q)\n\nu = showDoFResults(q, :uvec, name=\"uvec\", visible=false)\nux = showDoFResults(q, :ux, name=\"ux\", visible=false)\nuy = showDoFResults(q, :uy, name=\"uy\", visible=false)\nuz = showDoFResults(q, :uz, name=\"uz\", visible=false)\n\ns = showStressResults(S, :s, name=\"σ\", visible=true, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = showStressResults(S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = showStressResults(S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = showStressResults(S, :szx, name=\"τzx\", visible=false, smooth=true)\n\nplotOnPath(\"path\", sx, name=\"σx\", visible=false)\nplotOnPath(\"path\", sxy, name=\"τxy\", visible=false)\nplotOnPath(\"path\", ux, name=\"ux\", visible=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"cantilever3D.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"SetFactory(\"OpenCASCADE\");\n\nBox(1) = {0, 0, 0, 100, 10, 10};\n\nPhysical Surface(\"supp\", 13) = {1};\nPhysical Surface(\"load\", 14) = {2};\nPhysical Volume(\"body\", 15) = {1};\n\nRecombine Surface {1:6};\n\nTransfinite Line {1:8} = 4;\nTransfinite Line {9:12} = 31;\nTransfinite Surface {1:6};\nTransfinite Volume {1};\n\nMesh.ElementOrder = 3;\n\nSetName \"cantilever3D\";\nMesh 3;\n\nPoint(9) = {10, 0, 5, 1.0};\nPoint(10) = {10, 10, 5, 1.0};\nLine(13) = {9, 10};\n\nPhysical Curve(\"path\", 16) = {13};","category":"page"},{"location":"Examples/#L-shaped-plate","page":"Examples","title":"L-shaped plate","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Mesh with a path for graphs)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Fillet)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Equivalent stress)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: Equivalent stress on path)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n#gmsh.open(\"LshapedPlate.geo\")\ngmsh.open(\"LshapedPlate2.geo\")\n\nmat = material(\"body\", E=2e5, ν=0.3)\nproblem = Problem([mat], type=:PlaneStress, thickness=1)\n\nbc1 = displacementConstraint(\"fix\", ux=0, uy=0)\nld1 = load(\"load\", fy=-1)\n\nK = stiffnessMatrix(problem)\nf = loadVector(problem, [ld1])\napplyBoundaryConditions!(K, f, [bc1])\n\nq = solveDisplacement(K, f)\nS = solveStress(q)\n\nu = showDoFResults(q, :uvec, name=\"uvec\", visible=false)\nux = showDoFResults(q, :ux, name=\"ux\", visible=false)\nuy = showDoFResults(q, :uy, name=\"uy\", visible=false)\nuz = showDoFResults(q, :uz, name=\"uz\", visible=false)\ns = showStressResults(S, :s, name=\"σ red\", visible=false, smooth=false)\nss = showStressResults(S, :s, name=\"σ red smooth\", visible=true, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = showStressResults(S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = showStressResults(S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = showStressResults(S, :szx, name=\"τzx\", visible=false, smooth=true)\n\nplotOnPath(\"path\", s, name=\"σred\", visible=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"Point(1) = {0, 0, 0, 15.0};\nPoint(2) = {100, 0, 0, 15.0};\nPoint(3) = {100, 50, 0, 15.0};\nPoint(4) = {50, 50, 0, 0.5};\nPoint(5) = {50, 100, 0, 15.0};\nPoint(6) = {0, 100, 0, 15.0};\nLine(1) = {1, 2};\nLine(2) = {2, 3};\nLine(3) = {3, 4};\nLine(4) = {4, 5};\nLine(5) = {5, 6};\nLine(6) = {6, 1};\nCurve Loop(1) = {6, 1, 2, 3, 4, 5};\nPlane Surface(1) = {1};\n\nPhysical Curve(\"fix\", 7) = {5};\nPhysical Curve(\"load\", 8) = {2};\nPhysical Surface(\"body\", 11) = {1};\n\nSetName \"Lshape\";\n\nMesh.ElementOrder = 4;\nMesh.HighOrderOptimize = 1;\nMesh 2;\n\nPoint(7) = {0, 0, 0, 1.0};\nPoint(8) = {50, 50, 0, 1.0};\nLine(7) = {7, 8};\n\nPhysical Curve(\"path\", 9) = {7};","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"LshapedPlate2.geo","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"R=1;\n\nPoint(1) = {0, 0, 0, 15.0};\nPoint(2) = {100, 0, 0, 15.0};\nPoint(3) = {100, 50, 0, 15.0};\nPoint(4) = {50+R, 50, 0, R/1.6};\nPoint(5) = {50, 50+R, 0, R/1.6};\nPoint(6) = {50, 100, 0, 15.0};\nPoint(7) = {0, 100, 0, 15.0};\nPoint(8) = {50+R, 50+R, 0, 0.0};\nLine(1) = {1, 2};\nLine(2) = {2, 3};\nLine(3) = {3, 4};\nCircle(4) = {4, 8, 5};\nLine(5) = {5, 6};\nLine(6) = {6, 7};\nLine(7) = {7, 1};\nCurve Loop(1) = {1, 2, 3, 4, 5, 6, 7};\nPlane Surface(1) = {1};\n\nPhysical Curve(\"fix\", 8) = {6};\nPhysical Curve(\"load\", 9) = {2};\nPhysical Surface(\"body\", 11) = {1};\n\nSetName \"Lshape\";\nMesh.ElementOrder = 4;\nMesh.HighOrderOptimize = 1;\nMesh 2;\n\nPoint(9) = {0, 0, 0, 1.0};\nPoint(10) = {50+0.415*R, 50+0.415*R, 0, 1.0};\nLine(8) = {9, 10};\n\nPhysical Curve(\"path\", 10) = {8};","category":"page"},{"location":"Examples/#Wave-propagation-in-a-plate","page":"Examples","title":"Wave propagation in a plate","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"(Image: velocity field)","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"wavePropagation.jl","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\nE = 2e5\nν = 0.3\nρ = 7.85e-9\nthick = 1\nheight = 10\nbase = 100\nelemSize = 2 #22\n\napproxOrder = 2\ninternalNodes = true\nquadElements = true\n\ngmsh.model.add(\"rectangle\")\n\np1 = gmsh.model.occ.addPoint(0, 0, 0)\np2 = gmsh.model.occ.addPoint(base, 0, 0)\np3 = gmsh.model.occ.addPoint(base, height, 0)\np4 = gmsh.model.occ.addPoint(0, height, 0)\n\nl1 = gmsh.model.occ.addLine(p1, p2)\nl2 = gmsh.model.occ.addLine(p2, p3)\nl3 = gmsh.model.occ.addLine(p3, p4)\nl4 = gmsh.model.occ.addLine(p4, p1)\n\ncl1 = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])\n\nl5 = gmsh.model.occ.addCircle(base / 2, height / 2, 0, min(base, height) / 4)\ncl2 = gmsh.model.occ.addCurveLoop([l5])\n\nsf1 = gmsh.model.occ.addPlaneSurface([cl1, cl2])\n\ngmsh.model.occ.synchronize()\n\nphg = gmsh.model.addPhysicalGroup(1, [l2])\ngmsh.model.setPhysicalName(1, phg, \"supp\")\nphg = gmsh.model.addPhysicalGroup(1, [l4])\ngmsh.model.setPhysicalName(1, phg, \"load\")\nphg = gmsh.model.addPhysicalGroup(2, [sf1])\ngmsh.model.setPhysicalName(2, phg, \"body\")\n\ngenerateMesh(sf1, elemSize, approxOrder=approxOrder, algorithm=6, quadrangle=quadElements, internalNodes=internalNodes)\n\nmat = material(\"body\", E=E, ν=ν)\nproblem = Problem([mat], type=:PlaneStress, thickness=thick)\n\nsupp = displacementConstraint(\"supp\", ux=0, uy=0)\nld = load(\"load\", fx=1, fy=0)\n\ngmsh.option.setNumber(\"Mesh.Lines\", 0)\n\nK = stiffnessMatrix(problem)\nf = loadVector(problem, [ld])\nM = massMatrix(problem)\nC = 4e-3 * K\n\napplyBoundaryConditions!(K, M, C, f, [supp])\n\nTₘᵢₙ = smallestPeriodTime(K, M)\nq = solveDisplacement(K, f)\n\ndof, dof = size(K)\nu0 = zeros(dof)\nv0 = zeros(dof)\ninitialDisplacement!(\"supp\", u0, ux=0)\ninitialVelocity!(\"body\", v0, vx=1000)\ninitialVelocity!(\"supp\", v0, vx=0)\nf = zeros(dof)\n\nE = problem.material[1].E\nρ = problem.material[1].ρ\nc = √(E / ρ)\nξₘₐₓ = 1e-1\nβ = ξₘₐₓ * Tₘᵢₙ / π\nC = β * K\nu, v, t = CDM(K, M, C, f, u0, v0, base / c * 2, Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ) * 1.0)\n\nS = solveStress(q)\n\nuvec = showDoFResults(q, :uvec, name=\"uvec\", visible=false)\nux = showDoFResults(q, :ux, name=\"ux\", visible=false)\nuy = showDoFResults(q, :uy, name=\"uy\", visible=false)\nuz = showDoFResults(q, :uz, name=\"uz\", visible=false)\ns = showStressResults(S, :s, name=\"σ\", visible=false, smooth=true)\nsx = showStressResults(S, :sx, name=\"σx\", visible=false, smooth=true)\nsy = showStressResults(S, :sy, name=\"σy\", visible=false, smooth=true)\nsz = showStressResults(S, :sz, name=\"σz\", visible=false, smooth=true)\nsxy = showStressResults(S, :sxy, name=\"τxy\", visible=false, smooth=true)\nsyz = showStressResults(S, :syz, name=\"τyz\", visible=false, smooth=true)\nszx = showStressResults(S, :szx, name=\"τzx\", visible=false, smooth=true)\n\n# Show velocity time history as a VectorField with time vector t\nvVF = VectorField([], v, t, [], length(t), :u2D, problem)\nvvec = showDoFResults(vVF, :uvec, name=\"v(t)\", visible=true)\ngmsh.view.option.setNumber(vvec, \"NormalRaise\", 0.03)\n\nsts = ceil(Int64, (base / c * 2) / 6 / (Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ)))\ndisplay(sts)\nuVF_sts = VectorField([], u[:, sts:sts], [t[sts]], [], 1, :u2D, problem)\nSp = solveStress(uVF_sts)\nsp = showStressResults(Sp, :s, name=\"σ at t\", visible=false, smooth=false)\n\nuVF_anim = VectorField([], u[:, 1:sts], t[1:sts], [], sts, :u2D, problem)\nSanim = solveStress(uVF_anim)\nsanim = showStressResults(Sanim, :s, name=\"σ anim\", visible=false, smooth=false)\n\ngmsh.fltk.run()\ngmsh.finalize()","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"For more examples see examples on GitHub","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"Examples/#2D-Heat-Conduction-(steady-state)","page":"Examples","title":"2D Heat Conduction (steady state)","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n# Problem and BCs\nmat = material(\"body\", k=45.0)\nproblem = Problem([mat], type=:PlaneHeatConduction, thickness=1.0)\n\nbc_hot = temperatureConstraint(\"hot\", T=100.0)\nbc_cold = temperatureConstraint(\"cold\", T=0.0)\n\n# Assemble and solve K*T = q with Dirichlet BCs\nKth = heatConductionMatrix(problem)\nqth = heatFluxVector(problem, [])\napplyBoundaryConditions!(Kth, qth, [bc_hot, bc_cold])\nT = solveTemperature(Kth, qth)\n\n# Postprocess: temperature and heat flux\nshowDoFResults(T, :T, name=\"T\", visible=true)\nqflux = solveHeatFlux(T)\nshowHeatFluxResults(qflux, :qvec, name=\"q\", visible=false, smooth=true)\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"Examples/#2D-Heat-Conduction-with-Convection","page":"Examples","title":"2D Heat Conduction with Convection","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n# Heat problem and BCs\nmatT = material(\"body\", k=45.0)\nprobT = Problem([matT], type=:PlaneHeatConduction, thickness=1.0)\n\nbc_hot = temperatureConstraint(\"hot\", T=100.0)\nhcv = heatConvection(\"conv\", h=15.0, Tₐ=20.0)\n\nKth = heatConductionMatrix(probT)\nqth = heatFluxVector(probT, [])\napplyHeatConvection!(Kth, qth, [hcv])\napplyBoundaryConditions!(Kth, qth, [bc_hot])\nT = solveTemperature(Kth, qth)\n\nshowDoFResults(T, :T, name=\"T\", visible=true)\nqflux = solveHeatFlux(T)\nshowHeatFluxResults(qflux, :qvec, name=\"q\", visible=false, smooth=true)\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"Examples/#Thermo‑Mechanical-Coupling-(Plane-Stress)","page":"Examples","title":"Thermo‑Mechanical Coupling (Plane Stress)","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using LowLevelFEM\n\ngmsh.initialize()\n\n# 1) Heat problem to compute T(x)\nmatT = material(\"body\", k=45.0)\nprobT = Problem([matT], type=:PlaneHeatConduction, thickness=1.0)\nbc_hot = temperatureConstraint(\"hot\", T=100.0)\nhcv = heatConvection(\"conv\", h=15.0, Tₐ=20.0)\nKth = heatConductionMatrix(probT)\nqth = heatFluxVector(probT, [])\nCth = heatCapacityMatrix(probT)\napplyHeatConvection!(Kth, qth, [hcv])\napplyBoundaryConditions!(Kth, Cth, qth, [bc_hot])\nT = solveTemperature(Kth, qth)\n\n# 2) Elastic problem with thermal load\nmatE = material(\"body\", E=210e3, ν=0.3, α=1.2e-5)\nprobE = Problem([matE], type=:PlaneStress, thickness=1.0)\nK = stiffnessMatrix(probE)\nfth = thermalLoadVector(probE, T)  # from temperature field\nbc_fix = displacementConstraint(\"hot\", ux=0.0, uy=0.0)\napplyBoundaryConditions!(K, fth, [bc_fix])\nq = solveDisplacement(K, fth)\nS = solveStress(q)\n\nshowDoFResults(q, :uvec, name=\"u\", visible=false)\nshowStressResults(S, :s, name=\"σ\", visible=true, smooth=true)\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"General/#General-API","page":"General","title":"General API","text":"","category":"section"},{"location":"General/#LowLevelFEM.CoordinateSystem","page":"General","title":"LowLevelFEM.CoordinateSystem","text":"CoordinateSystem(vec1, vec2)\n\nA structure containing the data of a coordinate system.\n\nvec1: direction of the new x axis.\nvec2: together with vec1 determine the xy plane\n\nIf the problem is two dimensional, it is enough to give the first two elements of vec1. Elements of vec1 and vec2 can be functions. In 3D case the functions have three arguments (x, y, and z coordinates), otherwise (in 2D case) the number of arguments is two (x and y coordinates).\n\nTypes:\n\nvec1: Vector{Float64}\nvec2: Vector{Float64}\n\nExamples\n\n# 2D case\nnx(x, y) = x\nny(x, y) = y\ncs = CoordinateSystem([nx, ny])\nQ = rotateNodes(problem, \"body\", cs)\nq2 = Q' * q1 # where `q1` is in Cartesian, `q2` is in Axisymmetric coordinate system and\n# `q1` is a nodal displacement vector.\nS2 = Q' * S1 * Q # where `S1` is a stress field in Cartesian coordinate system while\n# `S2` is in Axisymmetric coordinate system.\n\n# 3D case\nn1x(x, y, z) = x\nn1y(x, y, z) = y\nn2x(x, y, z) = -y\nn2y = n1x\ncs = CoordinateSystem([n1x, n1y, 0], [n2x, n2y, 0])\nQ = rotateNodes(problem, \"body\", cs)\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Eigen","page":"General","title":"LowLevelFEM.Eigen","text":"Eigen(f, ϕ, model)\n\nA structure containing the eigenfrequencies and eigen modes.\n\nf: eigenfrequencies\nϕ: eigen modes\nmodel: same as Problem\n\nTypes:\n\nf: Matrix{Float64}\nϕ: Vector{Float64}\nmodel: Problem\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Material","page":"General","title":"LowLevelFEM.Material","text":"Material(phName, type, E, ν, ρ, k, c, α, λ, μ, κ)\n\nStructure containing the material type and constants.\n\ntype: constitutive law (:Hooke, :StVenantKirchhoff, :NeoHookeCompressible)\nE: elastic modulus\nν: Poisson's ratio\nρ: mass density\nk: thermal conductivity\nc: specific heat\nα: thermal expansion coefficient\nλ: Lamé parameter\nμ: Lamé parameter\nκ: bulk modulus\n\nphName is the name of the physical group where the material is used.\n\nTypes:\n\nphName: String\ntype: Symbol\nE: Float64\nν: Float64\nρ: Float64\nk: Float64\nc: Float64\nα: Float64\nλ: Float64\nμ: Float64\nκ: Float64\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Problem","page":"General","title":"LowLevelFEM.Problem","text":"Problem(materials; thickness=..., type=..., bandwidth=...)\n\nStructure containing key data for a problem.\n\nParts of the model with their material constants. Multiple materials can be provided (see material).\nProblem type: :Solid, :PlaneStrain, :PlaneStress, :AxiSymmetric, :HeatConduction, :PlaneHeatConduction, \n\n:AxiSymmetricHeatConduction, :Truss.   For :AxiSymmetric, the symmetry axis is y, and the geometry must be drawn in the positive x half-plane.\n\nBandwidth optimization using Gmsh's built-in reordering. Options: :RCMK, :Hilbert, :Metis, or :none (default).\nDimension of the problem, determined by type.\nMaterial constants (vector of Material; see the Material struct).\nPlate thickness (for 2D plate problems).\nNumber of nodes (non).\nGeometry dimension.\nProblem dimension (e.g., a 3D heat conduction problem is a 1D problem).\nIn case of 2D truss displacements have to be fixed in the third direction.\n\nTypes:\n\nmaterials: Material\ntype: Symbol\nbandwidth: Symbol\ndim: Integer\nthickness: Float64\nnon: Integer\ndim: Integer\npdim: Integer\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.ScalarField","page":"General","title":"LowLevelFEM.ScalarField","text":"ScalarField(A, a, t, numElem, nsteps, type, model)\nScalarField(problem, dataField)\n\nStructure containing all data of a scalar field (e.g., temperature).\n\nA: vector of element-wise scalar data\na: matrix of nodal values of the scalar field\nnumElem: vector of element tags\nnsteps: number of time steps stored in A (for animations)\ntype: type of data (e.g., :T for temperature)\nmodel: associated Problem\n\nTypes:\n\nA: Vector{Vector{Float64}}\na: Matrix{Float64}\nt: Vector{Float64}\nnumElem: Vector{Integer}\nnsteps: Integer\ntype: Symbol\nmodel: Problem\n\nExample\n\ns(x,y,z) = 2x + 3y\nfs = field(\"body\", f=s)\nS = ScalarField(problem, [fs])\n\nHere S is defined element-wise.\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.SystemMatrix","page":"General","title":"LowLevelFEM.SystemMatrix","text":"SystemMatrix(A::SparseMatrixCSC{Float64}, model::Problem)\n\nStructure containing the stiffness/mass/heat conduction/heat capacity/latent heat/... matrix and the associated Problem.\n\nTypes:\n\nA: SparseMatrixCSC{Float64}\nmodel: Problem\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.TensorField","page":"General","title":"LowLevelFEM.TensorField","text":"TensorField(A, a, t, numElem, nsteps, type, model)\nTensorField(problem, dataField)\n\nStructure containing the data of a tensor field (e.g., stress or strain).\n\nA: tensor of element-wise tensor data\na: matrix of nodal values of the tensor field\nnumElem: vector of element tags\nnsteps: number of time steps stored in A (for animations)\ntype: type of data (e.g., :u, :q)\nmodel: associated Problem\n\nTypes:\n\nA: Vector{Matrix{Float64}}\na: Matrix{Float64}\nt: Vector{Float64}\nnumElem: Vector{Integer}\nnsteps: Integer\ntype: Symbol\nmodel: Problem\n\nExample\n\ntx(x,y,z) = x + y\ntxy(x,y,z) = z\nft = field(\"body\", fx=tx, fxy=txy, fz=3)\nT = TensorField(problem, [ft])\n\nHere T is defined element-wise\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.Transformation","page":"General","title":"LowLevelFEM.Transformation","text":"Transformation(T::SparseMatrixCSC{Float64}, non::Int64, dim::Int64)\n\nStructure containing the transformation matrix T at each node in the FE mesh, the number of nodes non, and the problem dimension dim.\n\nTypes:\n\nT: SparseMatrixCSC{Float64}\nnon: Int64\ndim: Int64\n\n\n\n\n\n","category":"type"},{"location":"General/#LowLevelFEM.VectorField","page":"General","title":"LowLevelFEM.VectorField","text":"VectorField(A, a, t, numElem, nsteps, type, model)\nVectorField(problem, dataField)\n\nStructure containing the data of a vector field (e.g., displacement or heat flux).\n\nA: vector of element-wise vector data\na: matrix of nodal values of the vector field\nnumElem: vector of element tags\nnsteps: number of time steps stored in A (for animations)\ntype: type of data (e.g., :u, :q)\nmodel: associated Problem\n\nTypes:\n\nA: Vector{Matrix{Float64}}\na: Matrix{Float64}\nt: Vector{Float64}\nnumElem: Vector{Integer}\nnsteps: Integer\ntype: Symbol\nmodel: Problem\n\nExample\n\nvx(x,y,z) = x + y\nvy(x,y,z) = z\nfv = field(\"body\", fx=vx, fy=vy, fz=3)\nV = VectorField(problem, [fv])\n\nHere V is defined element-wise\n\n\n\n\n\n","category":"type"},{"location":"General/#Base.copy-Tuple{LowLevelFEM.SystemMatrix}","page":"General","title":"Base.copy","text":"Base.copy(A::SystemMatrix)\n\nInternal function to copy the whole content of a SystemMatrix.\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.show-Tuple{IO, LowLevelFEM.SystemMatrix}","page":"General","title":"Base.show","text":"Base.show(io::IO, M::SystemMatrix)\n\nInternal function to display SystemMatrix as a SparseMatrixCSC{Float64}.\n\n\n\n\n\n","category":"method"},{"location":"General/#Base.show-Tuple{IO, Union{ScalarField, TensorField, VectorField}}","page":"General","title":"Base.show","text":"Base.show(io::IO, M::Union{ScalarField,VectorField,TensorField})\n\nInternal function to display ScalarField, VectorField and TensorField as a Matrix{Float64} or Vector{Matrix{Float64}}.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.constrainedDoFs-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.constrainedDoFs","text":"constrainedDoFs(problem, supports)\n\nReturns the serial numbers of constrained degrees of freedom. Support is a vector of boundary conditions given with the function displacementConstraint.\n\nReturn: DoFs\n\nTypes:\n\nproblem: Problem\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\nDoFs: Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.displacementConstraint-Tuple{Any}","page":"General","title":"LowLevelFEM.displacementConstraint","text":"displacementConstraint(name; ux=..., uy=..., uz=...)\n\nSpecifies displacement constraints on the physical group name. At least one of ux, uy, or uz must be provided (depending on the problem dimension). ux, uy, or uz can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); displacementConstraint(\"support1\", ux=fn))\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nExamples\n\nhc = heatConvection(\"outer\", h=10.0, Tₐ=20.0)\n\nExamples\n\nsrc = heatSource(\"body\", h=1.0e6)\n\nExamples\n\nq = heatFlux(\"out\", qn=500.0)\n\nExamples\n\nbcT = temperatureConstraint(\"hot_face\", T=100.0)\n\nExamples\n\nld = load(\"load\", fy=-1.0)\n\nExamples\n\nbc = displacementConstraint(\"supp\", ux=0, uy=0)\n\nTypes:\n\nname: String\nux: Float64 or Function\nuy: Float64 or Function\nuz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.elasticSupport-Tuple{Any}","page":"General","title":"LowLevelFEM.elasticSupport","text":"elasticSupport(name; kx=..., ky=..., kz=...)\n\nSpecifies distributed stiffness for an elastic support on the physical group name. kx, ky, or kz can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); elasticSupport(\"supp1\", kx=fn)) Default values are 1.\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nkx: Float64 or Function\nky: Float64 or Function\nkz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.elementsToNodes-Tuple{Any}","page":"General","title":"LowLevelFEM.elementsToNodes","text":"elementsToNodes(T)\n\nSolves the nodal results F from the elemental results T. T can be ScalarField, VectorField or TensorField.\n\nReturn: F\n\nTypes:\n\nT: ScalarField, VectorField or TensorField\nF: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.expandTo3D-Tuple{VectorField}","page":"General","title":"LowLevelFEM.expandTo3D","text":"expandTo3D(v2D::VectorField)\n\nExpand a 2D vector field into 3D by adding a zero z-component.\n\nreturn: VectorField\n\nExamples\n\nV3D = expandTo3D(V2D)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.field-Tuple{Any}","page":"General","title":"LowLevelFEM.field","text":"field(name; f=..., fx=..., fy=..., fz=..., fxy=..., fyz=..., fzx=...)\n\nSpecifies the value of a scalar, vector, or tensor field on the physical group name. At least one of fx, fy, or fz etc. must be provided (depending on the problem dimension). Each component can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); field(\"surf1\", fx=fn))\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function, ... x7}\n\nTypes:\n\nname: String\nf: Float64 or Function\nfx: Float64 or Function\nfy: Float64 or Function\nfz: Float64 or Function\nfxy: Float64 or Function\nfyz: Float64 or Function\nfzx: Float64 or Function\n\nExamples\n\nf1(x, y, z) = y\nf2 = field(\"face1\", f=f1)\nqq = scalarField(problem, [f2])\nqqq = showDoFResults(qq, :scalar)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.fieldError-Tuple{Any}","page":"General","title":"LowLevelFEM.fieldError","text":"fieldError(F)\n\nComputes the deviation of field results F (stresses, strains, heat flux components) at nodes where the field has jumps. The result can be displayed with the showDoFResults function.\n\nReturns: e\n\nTypes:\n\nF: VectorField or TensorField\ne: ScalarField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.freeDoFs-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.freeDoFs","text":"freeDoFs(problem, supports)\n\nReturns the serial numbers of unconstrained degrees of freedom. Support is a vector of boundary conditions given with the function displacementConstraint.\n\nReturn: DoFs\n\nTypes:\n\nproblem: Problem\nsupports: Vector{Tuple{String, Float64, Float64, Float64}}\nDoFs: Vector{Int64}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.getEigenValues-Tuple{VectorField}","page":"General","title":"LowLevelFEM.getEigenValues","text":"getEigenValues(A::VectorField)\n\nA function to extract the elements of a vector field to separate scalar fields.\n\nReturn: λ1, λ2, λ3\n\nTypes:\n\nA: VectorField\nλ1: ScalarField\nλ2: ScalarField\nλ3: ScalarField\n\nExamples:\n\nusing LinearAlgebra\nλ, Q = eigen(S)\nλ1, λ2, λ2 = getEigenValues(λ)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.getEigenVectors-Tuple{TensorField}","page":"General","title":"LowLevelFEM.getEigenVectors","text":"getEigenVectors(A::TensorField)\n\nA function to extract the columns of a tensor field to separate vector fields.\n\nReturn: N1, N2, N3\n\nTypes:\n\nA: TensorField\nN1: VectorField\nN2: VectorField\nN3: VectorField\n\nExamples:\n\nusing LinearAlgebra\nλ, Q = eigen(S)\nN1, N2, N2 = getEigenVectors(Q)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.heatConvection-Tuple{Any}","page":"General","title":"LowLevelFEM.heatConvection","text":"heatConvection(name; h=..., Tₐ=...)\n\nSpecifies convective boundary conditions on the surface in the physical group name. h is the heat transfer coefficient of the surrounding medium; Tₐ is the ambient temperature. Tₐ can be either a constant or a function of x, y, and z.\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nh: Float64\nTₐ: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.heatFlux-Tuple{Any}","page":"General","title":"LowLevelFEM.heatFlux","text":"heatFlux(name; qn=...)\n\nSpecifies the heat flux normal to the surface of the physical group name. qn can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); load(\"flux1\", qn=fn))\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nqn: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.heatSource-Tuple{Any}","page":"General","title":"LowLevelFEM.heatSource","text":"heatSource(name; h=...)\n\nSpecifies the volumetric heat source in the physical group name. h can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); load(\"source1\", h=fn))\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nh: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.integrate-Tuple{Problem, String, Union{Function, ScalarField}}","page":"General","title":"LowLevelFEM.integrate","text":"integrate(problem::Problem, phName::String, f::Union{Function,ScalarField})\n\nIntegrates the function or scalar field f over the physical group phName defined in the geometry of problem.\n\nReturns: integral\n\nTypes:\n\nproblem: Problem\nphName: String\nf: Function (of x, y and z) or ScalarField\nintegral: Number\n\nExamples:\n\nf(x, y, z) = x^2 + y^2\nIz = integrate(prob, \"body\", f)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.isElementwise-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.isElementwise","text":"isElementwise(field)\n\nCheck if a given field is defined per element (elementwise quantity).\n\nElementwise quantities are associated with finite elements as a whole, for example stresses, strains, or energy densities evaluated inside elements.\n\nExamples\n\nisElementwise(displacement_field)   # returns false\nisElementwise(strain_field)         # returns true\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.isNodal-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.isNodal","text":"isNodal(field)\n\nCheck if a given field is defined at nodes (nodal quantity).\n\nNodal quantities are associated with mesh nodes, for example displacements, nodal forces, or nodal temperatures.\n\nExamples\n\nisNodal(displacement_field)   # returns true\nisNodal(strain_field)         # returns false\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.isSaved-Tuple{String}","page":"General","title":"LowLevelFEM.isSaved","text":"isSaved(fileName::String)\n\nChecks whether a variable has been saved or not.\n\nReturns: Boolean\n\nTypes:\n\nfileName: String\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.load-Tuple{Any}","page":"General","title":"LowLevelFEM.load","text":"load(name; fx=..., fy=..., fz=...)\n\nSpecifies a distributed load on the physical group name. At least one of fx, fy, or fz must be provided (depending on the problem dimension). fx, fy, or fz can be a constant or a function of x, y, and z or ScalarField. (e.g., fn(x,y,z) = 5*(5-x); load(\"load1\", fx=fn))\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nfx: Float64 or Function\nfy: Float64 or Function\nfz: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.loadField-Tuple{String}","page":"General","title":"LowLevelFEM.loadField","text":"loadField(fileName::String)\n\nLoads a ScalarField, VectorField, or TensorField from a file named fileName (without \"-LLF-Data.jld2\"). \n\nReturns: variable\n\nTypes:\n\nfileName: String\nvariable: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.material-Tuple{Any}","page":"General","title":"LowLevelFEM.material","text":"material(name; type=:Hooke, E=2.0e5, ν=0.3, ρ=7.85e-9, k=45, c=4.2e8, α=1.2e-5, λ=νE/(1+ν)/(1-2ν), μ=E/(1+ν)/2, κ=E/(1-2ν)/3)\n\nReturns a structure in which name is the name of a physical group, type is the name of the constitutive law (e.g., :Hooke), E is the modulus of elasticity, ν is Poisson's ratio, and ρ is the mass density. k is the thermal conductivity, c is the specific heat, α is the coefficient of thermal expansion, λ and μ are the  Lamé parameters, and κ is the bulk modulus.\n\nReturns: mat\n\nExamples\n\nmat = material(\"body\", E=210e3, ν=0.3, ρ=7.85e-9)\n\nTypes:\n\nmat: Material\nname: String\ntype: Symbol\nE: Float64\nν: Float64\nρ: Float64\nk: Float64\nc: Float64\nα: Float64\nλ: Float64\nμ: Float64\nκ: Float64\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.nodesToElements-Tuple{Union{ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.nodesToElements","text":"nodesToElements(T, onPhysicalGroup=\"\")\n\nSolves the element results F from the nodal results T. T can be ScalarField, VectorField or TensorField. If onPhysicalGroup is an existing physical group in gmsh, field T will be solve only on elements belonging to that physical group. Dimension of physical group can be different than the dimension of the problem. (eg. mapping from 3D volume to a 2D surface)\n\nReturn: F\n\nTypes:\n\nT: ScalarField, VectorField or TensorField\nF: ScalarField, VectorField or TensorField\nonPhysicalGroup: String\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.normalVector-Tuple{Problem, String}","page":"General","title":"LowLevelFEM.normalVector","text":"normalVector(problem::Problem, phName::String) -> VectorField\n\nCompute outward unit normal vectors for all nodes of a surface-type physical group in a 3D Gmsh model.\n\nArguments\n\nproblem::Problem: A Problem structure containing the current Gmsh model  (name, dimension, number of nodes, etc.).\nphName::String: The name of a physical surface group in Gmsh for which the normal vectors are computed.\n\nDescription\n\nThe function sets the current model, queries the elements and nodes that belong to the  given physical surface group, and evaluates the gradients of the Lagrange basis functions  to compute local tangent vectors of the surface. Normal vectors are obtained as cross  products of these tangents and normalized to unit length.\n\nEach node belonging to the physical surface group is assigned its corresponding  3D unit normal vector.\n\nReturns\n\nVectorField: A VectorField structure that stores the nodal normal vectors  on the given physical surface.\n\nErrors\n\nThrows an error if the provided physical group is not of surface type (dim != 2).\n\nExample\n\nusing LowLevelFEM\n\n# Load a 3D geometry and mesh it in Gmsh\ngmsh.initialize()\ngmsh.open(\"box_with_surface.msh\")\n\n# Define a 3D model on the volume physical group \"body\"\nmat = material(\"body\")\nprob = Problem([mat])\n\n# Compute nodal normals on a physical surface named \"leftWall\"\nnv = normalVector(problem, \"leftWall\")\n\n# Show the normal vectors on the model\nshowDoFResults(nv)\nopenPostProcessor()\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.openPostProcessor-Tuple{}","page":"General","title":"LowLevelFEM.openPostProcessor","text":"openPostProcessor(; model=...)\n\nLaunches the Gmsh postprocessor window with the postprocessor tree opened (of model).\n\nReturns: nothing\n\nTypes:\n\nmodel: Int64\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.openPreProcessor-Tuple{}","page":"General","title":"LowLevelFEM.openPreProcessor","text":"openPreProcessor(; openGL=...)\n\nLaunches the Gmsh preprocessor window with OpenGL disabled by default.\n\nReturns: nothing\n\nTypes:\n\nopenGL: Boolean\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.plotOnPath-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.plotOnPath","text":"plotOnPath(problem, pathName, field; points=100, step=..., plot=..., name=..., visible=..., offsetX=..., offsetY=..., offsetZ=...)\n\nLoads a 2D plot along a path into a View in Gmsh. field is the View id in Gmsh from which the field data is imported. pathName is the name of a physical group that contains a curve. The curve is divided into equal-length segments with points sampling points. The field is shown at these points. step is the sequence number of the displayed step. If no step is given, it shows all available steps as an animation. If plot is true, an additional return parameter (a tuple of vectors) is returned, where x is the horizontal axis and y is the vertical axis of the plot (see the Plots package). name is the title of the graph, and visible is a Boolean to toggle the initial visibility in Gmsh on or off. This function returns the tag of the View.\n\nReturns: tag\n\nor\n\nReturns: tag, xy\n\nTypes:\n\nproblem: Problem\npathName: String\nfield: Integer\npoints: Integer\nstep: Integer\nplot: Boolean\nname: String\nvisible: Boolean\ntag: Integer\nxy: Tuples{Vector{Float64},Vector{Float64}}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.probe-Tuple{TensorField, Any, Any, Any}","page":"General","title":"LowLevelFEM.probe","text":"probe(A::Union{ScalarField,VectorField,TensorField}, x::Number, y::Number, z::Number; step=Int)\n\nGet the value of the field A at point coordinates x, y, z at time step step.\n\nReturns: Float64 or Vector{Float64} or Matrix{Float64}\n\nTypes:\n\nA: ScalarField or VectorField or TensorField\nx: Number\ny: Number\nz: Number\nstep: Int\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.probe-Tuple{Union{ScalarField, TensorField, VectorField}, String}","page":"General","title":"LowLevelFEM.probe","text":"probe(A::Union{ScalarField,VectorField,TensorField}, s::String; step=Int)\n\nGet the value of the field A at a point given by its physical name in Gmsh at time step step.\n\nReturns: Float64 or Vector{Float64} or Matrix{Float64}\n\nTypes:\n\nA: ScalarField or VectorField or TensorField\nx: Number\ny: Number\nz: Number\nstep: Int\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.projectTo2D-Tuple{VectorField}","page":"General","title":"LowLevelFEM.projectTo2D","text":"projectTo2D(v3D::VectorField)\n\nProject a 3D vector field onto the xy-plane by discarding the z-component.\n\nreturn: VectorField\n\nExamples\n\nV2D = expandTo3D(V3D)\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.resultant-Tuple{VectorField, String}","page":"General","title":"LowLevelFEM.resultant","text":"resultant(field, phName)\n\nComputes the resultant of vector field field on the physical group phName. Returns the resultant(s) in a tuple. The number of elements in the tuple depends on the dimension of problem (dimension of field). It can solve for example the resultant of a load vector (sum of the elements of the vector).\n\nReturn: resx\n\nor\n\nReturn: resx, resy\n\nor\n\nReturn: resx, resy, resz\n\nTypes:\n\nfield: VectorField\nphName: String \nresx: Float64 \nresy: Float64 \nresz: Float64 \n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.rotateNodes-Tuple{Any, Any, Any}","page":"General","title":"LowLevelFEM.rotateNodes","text":"rotateNodes(problem, phName, CoordSys)\n\nCreates the T transformation matrix, which rotates the nodal coordinate system of the nodes in phName physical group to the coordinate systen defined by CoordSys. The mesh belongs to problem.\n\nReturn: T\n\nTypes:\n\nproblem: Problem\nphName: String\nCoordSys: CoordinateSystem\nT: SparseMatrix\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.saveField-Tuple{String, Union{Number, ScalarField, TensorField, VectorField}}","page":"General","title":"LowLevelFEM.saveField","text":"saveField(fileName::String, variable::Union{ScalarField,VectorField,TensorField,Number})\n\nSaves variable of type ScalarField, VectorField, or TensorField to a file named fileName. The name of the file will be complemented with the string \"-LLF-Data.jld2\"\n\nReturns: nothing\n\nTypes:\n\nfileName: String\nvariable: ScalarField, VectorField or TensorField\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.scalarField-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.scalarField","text":"scalarField(problem, dataField)\n\nDefines a scalar field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem.\n\nReturn: Vector{Float64}\n\nTypes:\n\nproblem: Problem\ndataField: Vector{Tuple{String, Float64,...}}\n\nExamples\n\nf2 = field(\"face1\", f=1)\nqq = scalarField(problem, [f2])\nqqq = showDoFResults(qq, :scalar)\n\nHere ScalarField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.setParameter-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.setParameter","text":"setParameter(name, value)\n\nDefines a parameter name and sets its value to value. \n\nReturns: nothing\n\nTypes:\n\nname: String\nvalue: Float64\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.setParameters-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.setParameters","text":"setParameters(name, value)\n\nDefines a parameter name and sets its value to value, which is a Vector{Float64}. \n\nReturns: nothing\n\nTypes:\n\nname: String\nvalue: Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showBucklingResults-Tuple{LowLevelFEM.Eigen}","page":"General","title":"LowLevelFEM.showBucklingResults","text":"showBucklingResults(Φ, name=..., visible=...)\n\nLoads buckling results into a View in Gmsh. Φ is an Eigen struct. name is a title to display and visible is a Boolean to toggle the initial visibility in Gmsh on or off. Click on ▷| to change the results. This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nΦ: Eigen\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showDoFResults-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.showDoFResults","text":"showDoFResults(q, comp; name=..., visible=...)\n\nLoads nodal results into a View in Gmsh. q is the field to show, comp is the component of the field (:vector, :uvec, :ux, :uy, :uz, :vvec, :vx, :vy, :vz, :qvec, :qx, :qy, :qz, :T, :p, :qn, :s, :sx, :sy, :sz, :sxy, :syx, :syz, :szy, :szx, :sxz, :e, :ex, :ey, :ez, :exy, :eyx, :eyz, :ezy, :ezx, :exz, :seqv, :scalar, :tensor), name is a title to display and visible is a Boolean to toggle the initial visibility in Gmsh on or off. If q has more columns, then a sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nq: ScalarField, VectorField or TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showElementResults-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.showElementResults","text":"showElementResults(F, comp; name=..., visible=..., smooth=...)\n\nSame as ShowStressResults or showStrainResults, depending on the type of F data field.\n\nReturn: tag\n\nTypes:\n\nF: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showHeatFluxResults-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.showHeatFluxResults","text":"showHeatFluxResults(Q, comp; name=..., visible=..., smooth=...)\n\nLoads heat flux results into a View in Gmsh. Q is a heat flux field to show, comp is the component of the field (:qvec, :qx, :qy, :qz, :q), name is a title to display, visible is a Boolean to toggle the initial visibility in Gmsh on or off, and smooth is a Boolean to toggle smoothing on or off. If Q contains more than one time step, a sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nS: VectorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showModalResults-Tuple{LowLevelFEM.Eigen}","page":"General","title":"LowLevelFEM.showModalResults","text":"showModalResults(Φ, name=..., visible=...)\n\nLoads modal results into a View in Gmsh. Φ is an Eigen struct. name is a title to display and visible is a Boolean to toggle the initial visibility in Gmsh on or off. Click on ▷| to change the results. This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nΦ: Eigen\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showOnSurface-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.showOnSurface","text":"showOnSurface(field, phName; grad=false, component=:x, offsetX=0, offsetY=0, offsetZ=0, name=phName, visible=false)\n\nShows the values of a scalar field on a surface with physical name phName. field is the tag of a View in Gmsh. The values of the field are calculated at the intersection with the surface. grad is a Boolean to toggle the gradient of the field on or off. component is the component of the gradient of field (:x, :y, :z) to be shown. offsetX, offsetY, offsetZ are the offsets in the x, y, and z directions where the values are sampled. name is a title to display, and visible is a Boolean to toggle the initial visibility in Gmsh on or off.\n\nReturns: tag\n\nTypes:\n\nfield: Integer\nphName: String\ngrad: Boolean\ncomponent: Symbol\noffsetX: Float64\noffsetY: Float64\noffsetZ: Float64\nname: String\nvisible: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showStrainResults-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.showStrainResults","text":"showStrainResults(E, comp; name=..., visible=..., smooth=...)\n\nLoads strain results into a View in Gmsh. E is a strain field to show, comp is the component of the field (:e, :ex, :ey, :ez, :exy, :eyz, :ezx), name is a title to display, visible is a Boolean to toggle the initial visibility in Gmsh on or off and smooth is a Boolean to toggle smoothing the stress field on or off. If E contains more than one time steps, then a  sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nE: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.showStressResults-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.showStressResults","text":"showStressResults(S, comp; name=..., visible=..., smooth=...)\n\nLoads stress results into a View in Gmsh. S is a stress field to show, comp is the component of the field (:s, :sx, :sy, :sz, :sxy, :syz, :szx, :seqv), name is a title to display, visible is a Boolean to toggle the initial visibility in Gmsh on or off, and smooth is a Boolean to toggle smoothing the stress field on or off. If S contains more than one time step, a sequence of results will be shown (e.g., as an animation). This function returns the tag of the View.\n\nReturns: tag\n\nTypes:\n\nS: TensorField\ncomp: Symbol\nname: String\nvisible: Boolean\nsmooth: Boolean\ntag: Integer\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.temperatureConstraint-Tuple{Any}","page":"General","title":"LowLevelFEM.temperatureConstraint","text":"temperatureConstraint(name; T=...)\n\nSpecifies temperature constraints on the physical group name. T can be a constant or a function of x, y, and z. (e.g., fn(x,y,z) = 5*(5-x); temperatureConstraint(\"surf1\", T=fn))\n\nReturns: Tuple{String, Float64 or Function, Float64 or Function, Float64 or Function}\n\nTypes:\n\nname: String\nT: Float64 or Function\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.tensorField-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.tensorField","text":"tensorField(problem, dataField; type=...)\n\nDefines a vector field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem. type can be an arbitrary Symbol, e.g., :u or :f.\n\nReturn: TensorField\n\nTypes:\n\nproblem: Problem\ndataField: Vector{Tuple{String, Float64,...}}\n\nExamples\n\nf1(x, y, z) = sin(x)\nf2(x, y, z) = 5y\nff1 = field(\"face1\", fx=f1, fy=f2, fz=0, fxy=1, fyz=1, fzx=f2)\nff2 = field(\"face2\", fx=f2, fy=f1, fz=1, fxy=1, fyz=f1, fzx=1)\nqq = tensorField(problem, [ff1, ff2])\nqq0 = showDoFResults(qq, :tensor)\n\nHere TensorField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"General/#LowLevelFEM.vectorField-Tuple{Any, Any}","page":"General","title":"LowLevelFEM.vectorField","text":"vectorField(problem, dataField; type=...)\n\nDefines a vector field from dataField, which is a tuple of name of physical group and prescribed values or functions. Mesh details are in problem. type can be an arbitrary Symbol, e.g., :u or :f.\n\nReturn: VectorField\n\nTypes:\n\nproblem: Problem\ndataField: Vector{Tuple{String, Float64,...}}\n\nExamples\n\nf1(x, y, z) = sin(x)\nf2(x, y, z) = 5y\nff1 = field(\"face1\", fx=f1, fy=f2, fz=0)\nff2 = field(\"face2\", fx=f2, fy=f1, fz=1)\nqq = vectorField(problem, [ff1, ff2])\nqq0 = showDoFResults(qq, :vector)\n\nHere VectorField is defined in nodes.\n\n\n\n\n\n","category":"method"},{"location":"#LowLevelFEM","page":"Introduction","title":"LowLevelFEM","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"LowLevelFEM is a Julia package for finite element analysis with an engineering-first workflow. It exposes each phase of the workflow as simple functions (mesh → matrices → loads/BCs → solve → postprocess → visualize), so you can customize, combine, or inspect any step. Typical tasks such as strain energy or resultants are one-liners (for example, U = q' * K * q / 2).","category":"page"},{"location":"#Requirements","page":"Introduction","title":"Requirements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia 1.x\nGmsh C API is bundled via gmsh_jll and re-exported as gmsh from this package; no separate Gmsh.jl installation is required.","category":"page"},{"location":"#Capabilities","page":"Introduction","title":"Capabilities","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Geometry and meshing: integrates with gmsh for 2D/3D geometry, meshing, and physical groups.\nProblem types: 3D solids, 2D plane stress/plane strain, axisymmetric; 3D/2D heat conduction and axisymmetric heat conduction.\nElements and order: standard line/triangle/quad/tetra/hex/pyramid/wedge with Lagrange order up to 10.\nMaterials: linear elastic (Hooke) and large deformation laws (St. Venant–Kirchhoff, compressible Neo-Hooke).\nMatrices: stiffness K, mass M (lumped or consistent), proportional damping C (Rayleigh/Caughey), heat conduction/capacity, latent heat, and convection matrices/vectors.\nLoads and constraints: nodal and distributed loads on physical groups; function-based loads and temperature BCs; elastic supports; initial displacement/velocity/temperature.\nThermal–structural coupling: thermal expansion, thermal stresses, and heat generated by elastic deformation.\nSolvers: static and transient dynamics (central difference and HHT-α from the Newmark family).\nEigenproblems: modal analysis (frequencies and mode shapes, optionally prestressed) and linear buckling (critical factors and modes).\nField operators and results: gradient/divergence/curl; stress/strain and heat flux as element or nodal fields; smoothing at nodes with field jumps; user-defined scalar/vector/tensor FE fields.\nVisualization and plots: Gmsh-based views for displacements, stresses, strains, heat flux, with animation for dynamics; plot results along user-defined paths; show results on surfaces.\nCoordinate systems: rotate nodal DOFs with constant or function-defined local coordinate systems (incl. curvilinear).\nTruss stuctures (static, transient, modal analysis)","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"LowLevelFEM\")","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using LowLevelFEM\n\n# `gmsh` is exported by LowLevelFEM\ngmsh.initialize()\ngmsh.open(\"your_model.geo\")\n\nmat = material(\"body\", E=2e5, ν=0.3)\nprob = Problem([mat], type=:PlaneStress)  # :Solid, :PlaneStrain, :AxiSymmetric, :HeatConduction, ...\n\nbc   = displacementConstraint(\"supp\", ux=0, uy=0)\nforce = load(\"load\", fy=-1)\n\nq = solveDisplacement(prob, [force], [bc])\nS = solveStress(q)\n\nshowDoFResults(q, :uvec)\nshowStressResults(S, :s)\n\nopenPostProcessor()\ngmsh.finalize()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note: physical group names in your geometry (created in Gmsh) must match the strings used above (e.g., \"body\", \"supp\", \"load\").","category":"page"},{"location":"#An-alternative-solution-(instead-of-q-...,-S-...)","page":"Introduction","title":"An alternative solution (instead of q = ..., S = ...)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"K = stiffnessMatrix(prob)\nf = loadVector(prob, [force])\napplyBoundaryConditions!(K, f, [bc])\nq = K \\ f\n\nE = mat.E\nν = mat.ν\n\nA = (u ∘ ∇ + ∇ ∘ u) / 2\nI = unitTensor(A)\nS = E / (1 + ν) * (A + ν / (1 - 2ν) * trace(A) * I)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More end-to-end examples are available under examples and in the documentation.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Latest docs: https://perebalazs.github.io/LowLevelFEM.jl/dev\nStable docs: https://perebalazs.github.io/LowLevelFEM.jl/stable","category":"page"},{"location":"#Planned-features","page":"Introduction","title":"Planned features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Other material laws (incompressible Neo-Hooke, Mooney-Rivlin, etc.)\nBeam, shell elements\nContact problems (penalty, Lagrange multiplier)\nMultithreading (partially implemented)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Any suggestions are welcome. In case of any issue, please send a bug report.","category":"page"},{"location":"#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This project is licensed under the MIT License — see LICENSE for details.","category":"page"}]
}
