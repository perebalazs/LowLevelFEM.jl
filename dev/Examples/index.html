<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · LowLevelFEM</title><meta name="title" content="Examples · LowLevelFEM"/><meta property="og:title" content="Examples · LowLevelFEM"/><meta property="twitter:title" content="Examples · LowLevelFEM"/><meta name="description" content="Documentation for LowLevelFEM."/><meta property="og:description" content="Documentation for LowLevelFEM."/><meta property="twitter:description" content="Documentation for LowLevelFEM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelFEM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../General/">General</a></li><li><a class="tocitem" href="../Linear/">Linear</a></li><li><a class="tocitem" href="../Heat/">Heat</a></li><li><a class="tocitem" href="../Nonlinear/">Nonlinear</a></li><li><a class="tocitem" href="../Operators/">Operators</a></li></ul></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#2D-Cantilever"><span>2D Cantilever</span></a></li><li><a class="tocitem" href="#3D-Cantilever"><span>3D Cantilever</span></a></li><li><a class="tocitem" href="#L-shaped-plate"><span>L-shaped plate</span></a></li><li><a class="tocitem" href="#Wave-propagation-in-a-plate"><span>Wave propagation in a plate</span></a></li><li><a class="tocitem" href="#2D-Heat-Conduction-(steady-state)"><span>2D Heat Conduction (steady state)</span></a></li><li><a class="tocitem" href="#2D-Heat-Conduction-with-Convection"><span>2D Heat Conduction with Convection</span></a></li><li><a class="tocitem" href="#Thermo‑Mechanical-Coupling-(Plane-Stress)"><span>Thermo‑Mechanical Coupling (Plane Stress)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/main/docs/src/Examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="2D-Cantilever"><a class="docs-heading-anchor" href="#2D-Cantilever">2D Cantilever</a><a id="2D-Cantilever-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Cantilever" title="Permalink"></a></h2><p><img src="../pic/bending_2D.png" alt="\$\\sigma_x\$ on deformed shape"/></p><p><img src="../pic/bending_2D_path.png" alt="\$\\sigma_x\$ and \$\\tau_{yx}\$ on path"/></p><p>cantilever2D.jl</p><pre><code class="language-Julia hljs">using LowLevelFEM

gmsh.initialize()

gmsh.open(&quot;cantilever2D.geo&quot;)
mat = material(&quot;body&quot;, E=2e5, ν=0.3)
problem = Problem([mat], type=:PlaneStress)

supp = displacementConstraint(&quot;supp&quot;, ux=0, uy=0)
load = load(&quot;load&quot;, fy=-1)

q = solveDisplacement(problem, [load], [supp])
S = solveStress(q)

u = showDoFResults(q, :uvec)
ux = showDoFResults(q, :ux)
uy = showDoFResults(q, :uy)

s = showStressResults(S, :s, visible=true, smooth=true)
sx = showStressResults(S, :sx, name=&quot;σx&quot;, visible=false, smooth=true)
sy = showStressResults(S, :sy, name=&quot;σy&quot;, visible=false, smooth=true)
sxy = showStressResults(S, :sxy, name=&quot;τxy&quot;, visible=false, smooth=true)

plotOnPath(&quot;path&quot;, sx, name=&quot;σx&quot;, visible=false)
plotOnPath(&quot;path&quot;, sxy, name=&quot;τxy&quot;, visible=false)
plotOnPath(&quot;path&quot;, ux, name=&quot;ux&quot;, visible=false)

gmsh.fltk.run()
gmsh.finalize()</code></pre><p>cantilever2D.geo</p><pre><code class="language-gmsh hljs">SetFactory(&quot;OpenCASCADE&quot;);

Rectangle(1) = {0, 0, 0, 100, 10, 0};

Physical Curve(&quot;supp&quot;, 5) = {4};
Physical Curve(&quot;load&quot;, 6) = {2};
Physical Surface(&quot;body&quot;, 7) = {1};

Recombine Surface {1};

Transfinite Line {2,4} = 4;
Transfinite Line {1,3} = 31;
Transfinite Surface {1};

Mesh.ElementOrder = 3;

SetName &quot;cantilever2D&quot;;
Mesh 2;

Point(5) = {10, 0, 0, 1.0};
Point(6) = {10, 10, 0, 1.0};
Line(5) = {5, 6};

Physical Curve(&quot;path&quot;, 8) = {5};</code></pre><h2 id="3D-Cantilever"><a class="docs-heading-anchor" href="#3D-Cantilever">3D Cantilever</a><a id="3D-Cantilever-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Cantilever" title="Permalink"></a></h2><p><img src="../pic/bending_3D.png" alt="\$\\sigma_x\$ on deformed shape"/></p><p>cantilever3D.jl</p><pre><code class="language-Julia hljs">using LowLevelFEM

gmsh.initialize()

gmsh.open(&quot;cantilever3D.geo&quot;)
mat = material(&quot;body&quot;, E=2e5, ν=0.3)
problem = Problem([mat])

supp = displacementConstraint(&quot;supp&quot;, ux=0, uy=0, uz=0)
ld = load(&quot;load&quot;, fy=-1)

K = stiffnessMatrix(problem)
f = loadVector(problem, [ld])

applyBoundaryConditions!(K, f, [supp])

q = solveDisplacement(K, f)
S = solveStress(q)

u = showDoFResults(q, :uvec, name=&quot;uvec&quot;, visible=false)
ux = showDoFResults(q, :ux, name=&quot;ux&quot;, visible=false)
uy = showDoFResults(q, :uy, name=&quot;uy&quot;, visible=false)
uz = showDoFResults(q, :uz, name=&quot;uz&quot;, visible=false)

s = showStressResults(S, :s, name=&quot;σ&quot;, visible=true, smooth=true)
sx = showStressResults(S, :sx, name=&quot;σx&quot;, visible=false, smooth=true)
sy = showStressResults(S, :sy, name=&quot;σy&quot;, visible=false, smooth=true)
sz = showStressResults(S, :sz, name=&quot;σz&quot;, visible=false, smooth=true)
sxy = showStressResults(S, :sxy, name=&quot;τxy&quot;, visible=false, smooth=true)
syz = showStressResults(S, :syz, name=&quot;τyz&quot;, visible=false, smooth=true)
szx = showStressResults(S, :szx, name=&quot;τzx&quot;, visible=false, smooth=true)

plotOnPath(&quot;path&quot;, sx, name=&quot;σx&quot;, visible=false)
plotOnPath(&quot;path&quot;, sxy, name=&quot;τxy&quot;, visible=false)
plotOnPath(&quot;path&quot;, ux, name=&quot;ux&quot;, visible=false)

gmsh.fltk.run()
gmsh.finalize()</code></pre><p>cantilever3D.geo</p><pre><code class="language-gmsh hljs">SetFactory(&quot;OpenCASCADE&quot;);

Box(1) = {0, 0, 0, 100, 10, 10};

Physical Surface(&quot;supp&quot;, 13) = {1};
Physical Surface(&quot;load&quot;, 14) = {2};
Physical Volume(&quot;body&quot;, 15) = {1};

Recombine Surface {1:6};

Transfinite Line {1:8} = 4;
Transfinite Line {9:12} = 31;
Transfinite Surface {1:6};
Transfinite Volume {1};

Mesh.ElementOrder = 3;

SetName &quot;cantilever3D&quot;;
Mesh 3;

Point(9) = {10, 0, 5, 1.0};
Point(10) = {10, 10, 5, 1.0};
Line(13) = {9, 10};

Physical Curve(&quot;path&quot;, 16) = {13};</code></pre><h2 id="L-shaped-plate"><a class="docs-heading-anchor" href="#L-shaped-plate">L-shaped plate</a><a id="L-shaped-plate-1"></a><a class="docs-heading-anchor-permalink" href="#L-shaped-plate" title="Permalink"></a></h2><p><img src="../pic/Lshaped_mesh.png" alt="Mesh with a path for graphs"/></p><p><img src="../pic/Lshaped_mesh2.png" alt="Fillet"/></p><p><img src="../pic/sigma_eqv.png" alt="Equivalent stress"/></p><p><img src="../pic/sigma_eqv_path.png" alt="Equivalent stress on path"/></p><p>LshapedPlate.jl</p><pre><code class="language-Julia hljs">using LowLevelFEM

gmsh.initialize()

#gmsh.open(&quot;LshapedPlate.geo&quot;)
gmsh.open(&quot;LshapedPlate2.geo&quot;)

mat = material(&quot;body&quot;, E=2e5, ν=0.3)
problem = Problem([mat], type=:PlaneStress, thickness=1)

bc1 = displacementConstraint(&quot;fix&quot;, ux=0, uy=0)
ld1 = load(&quot;load&quot;, fy=-1)

K = stiffnessMatrix(problem)
f = loadVector(problem, [ld1])
applyBoundaryConditions!(K, f, [bc1])

q = solveDisplacement(K, f)
S = solveStress(q)

u = showDoFResults(q, :uvec, name=&quot;uvec&quot;, visible=false)
ux = showDoFResults(q, :ux, name=&quot;ux&quot;, visible=false)
uy = showDoFResults(q, :uy, name=&quot;uy&quot;, visible=false)
uz = showDoFResults(q, :uz, name=&quot;uz&quot;, visible=false)
s = showStressResults(S, :s, name=&quot;σ red&quot;, visible=false, smooth=false)
ss = showStressResults(S, :s, name=&quot;σ red smooth&quot;, visible=true, smooth=true)
sx = showStressResults(S, :sx, name=&quot;σx&quot;, visible=false, smooth=true)
sy = showStressResults(S, :sy, name=&quot;σy&quot;, visible=false, smooth=true)
sz = showStressResults(S, :sz, name=&quot;σz&quot;, visible=false, smooth=true)
sxy = showStressResults(S, :sxy, name=&quot;τxy&quot;, visible=false, smooth=true)
syz = showStressResults(S, :syz, name=&quot;τyz&quot;, visible=false, smooth=true)
szx = showStressResults(S, :szx, name=&quot;τzx&quot;, visible=false, smooth=true)

plotOnPath(&quot;path&quot;, s, name=&quot;σred&quot;, visible=false)

gmsh.fltk.run()
gmsh.finalize()</code></pre><p>LshapedPlate.geo</p><pre><code class="language-gmsh hljs">Point(1) = {0, 0, 0, 15.0};
Point(2) = {100, 0, 0, 15.0};
Point(3) = {100, 50, 0, 15.0};
Point(4) = {50, 50, 0, 0.5};
Point(5) = {50, 100, 0, 15.0};
Point(6) = {0, 100, 0, 15.0};
Line(1) = {1, 2};
Line(2) = {2, 3};
Line(3) = {3, 4};
Line(4) = {4, 5};
Line(5) = {5, 6};
Line(6) = {6, 1};
Curve Loop(1) = {6, 1, 2, 3, 4, 5};
Plane Surface(1) = {1};

Physical Curve(&quot;fix&quot;, 7) = {5};
Physical Curve(&quot;load&quot;, 8) = {2};
Physical Surface(&quot;body&quot;, 11) = {1};

SetName &quot;Lshape&quot;;

Mesh.ElementOrder = 4;
Mesh.HighOrderOptimize = 1;
Mesh 2;

Point(7) = {0, 0, 0, 1.0};
Point(8) = {50, 50, 0, 1.0};
Line(7) = {7, 8};

Physical Curve(&quot;path&quot;, 9) = {7};</code></pre><p>LshapedPlate2.geo</p><pre><code class="language-gmsh hljs">R=1;

Point(1) = {0, 0, 0, 15.0};
Point(2) = {100, 0, 0, 15.0};
Point(3) = {100, 50, 0, 15.0};
Point(4) = {50+R, 50, 0, R/1.6};
Point(5) = {50, 50+R, 0, R/1.6};
Point(6) = {50, 100, 0, 15.0};
Point(7) = {0, 100, 0, 15.0};
Point(8) = {50+R, 50+R, 0, 0.0};
Line(1) = {1, 2};
Line(2) = {2, 3};
Line(3) = {3, 4};
Circle(4) = {4, 8, 5};
Line(5) = {5, 6};
Line(6) = {6, 7};
Line(7) = {7, 1};
Curve Loop(1) = {1, 2, 3, 4, 5, 6, 7};
Plane Surface(1) = {1};

Physical Curve(&quot;fix&quot;, 8) = {6};
Physical Curve(&quot;load&quot;, 9) = {2};
Physical Surface(&quot;body&quot;, 11) = {1};

SetName &quot;Lshape&quot;;
Mesh.ElementOrder = 4;
Mesh.HighOrderOptimize = 1;
Mesh 2;

Point(9) = {0, 0, 0, 1.0};
Point(10) = {50+0.415*R, 50+0.415*R, 0, 1.0};
Line(8) = {9, 10};

Physical Curve(&quot;path&quot;, 10) = {8};</code></pre><h2 id="Wave-propagation-in-a-plate"><a class="docs-heading-anchor" href="#Wave-propagation-in-a-plate">Wave propagation in a plate</a><a id="Wave-propagation-in-a-plate-1"></a><a class="docs-heading-anchor-permalink" href="#Wave-propagation-in-a-plate" title="Permalink"></a></h2><pre><code class="language- hljs">![velocity field](pic/wave.mp4)</code></pre><p>wavePropagation.jl</p><pre><code class="language-Julia hljs">using LowLevelFEM

gmsh.initialize()

E = 2e5
ν = 0.3
ρ = 7.85e-9
thick = 1
height = 10
base = 100
elemSize = 2 #22

approxOrder = 2
internalNodes = true
quadElements = true

gmsh.model.add(&quot;rectangle&quot;)

p1 = gmsh.model.occ.addPoint(0, 0, 0)
p2 = gmsh.model.occ.addPoint(base, 0, 0)
p3 = gmsh.model.occ.addPoint(base, height, 0)
p4 = gmsh.model.occ.addPoint(0, height, 0)

l1 = gmsh.model.occ.addLine(p1, p2)
l2 = gmsh.model.occ.addLine(p2, p3)
l3 = gmsh.model.occ.addLine(p3, p4)
l4 = gmsh.model.occ.addLine(p4, p1)

cl1 = gmsh.model.occ.addCurveLoop([l1, l2, l3, l4])

l5 = gmsh.model.occ.addCircle(base / 2, height / 2, 0, min(base, height) / 4)
cl2 = gmsh.model.occ.addCurveLoop([l5])

sf1 = gmsh.model.occ.addPlaneSurface([cl1, cl2])

gmsh.model.occ.synchronize()

phg = gmsh.model.addPhysicalGroup(1, [l2])
gmsh.model.setPhysicalName(1, phg, &quot;supp&quot;)
phg = gmsh.model.addPhysicalGroup(1, [l4])
gmsh.model.setPhysicalName(1, phg, &quot;load&quot;)
phg = gmsh.model.addPhysicalGroup(2, [sf1])
gmsh.model.setPhysicalName(2, phg, &quot;body&quot;)

generateMesh(sf1, elemSize, approxOrder=approxOrder, algorithm=6, quadrangle=quadElements, internalNodes=internalNodes)

mat = material(&quot;body&quot;, E=E, ν=ν)
problem = Problem([mat], type=:PlaneStress, thickness=thick)

supp = displacementConstraint(&quot;supp&quot;, ux=0, uy=0)
ld = load(&quot;load&quot;, fx=1, fy=0)

gmsh.option.setNumber(&quot;Mesh.Lines&quot;, 0)

K = stiffnessMatrix(problem)
f = loadVector(problem, [ld])
M = massMatrix(problem)
C = 4e-3 * K

applyBoundaryConditions!(K, M, C, f, [supp])

Tₘᵢₙ = smallestPeriodTime(K, M)
q = solveDisplacement(K, f)

dof, dof = size(K)
u0 = zeros(dof)
v0 = zeros(dof)
initialDisplacement!(&quot;supp&quot;, u0, ux=0)
initialVelocity!(&quot;body&quot;, v0, vx=1000)
initialVelocity!(&quot;supp&quot;, v0, vx=0)
f = zeros(dof)

E = problem.material[1].E
ρ = problem.material[1].ρ
c = √(E / ρ)
ξₘₐₓ = 1e-1
β = ξₘₐₓ * Tₘᵢₙ / π
C = β * K
u, v, t = CDM(K, M, C, f, u0, v0, base / c * 2, Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ) * 1.0)

S = solveStress(q)

uvec = showDoFResults(q, :uvec, name=&quot;uvec&quot;, visible=false)
ux = showDoFResults(q, :ux, name=&quot;ux&quot;, visible=false)
uy = showDoFResults(q, :uy, name=&quot;uy&quot;, visible=false)
uz = showDoFResults(q, :uz, name=&quot;uz&quot;, visible=false)
s = showStressResults(S, :s, name=&quot;σ&quot;, visible=false, smooth=true)
sx = showStressResults(S, :sx, name=&quot;σx&quot;, visible=false, smooth=true)
sy = showStressResults(S, :sy, name=&quot;σy&quot;, visible=false, smooth=true)
sz = showStressResults(S, :sz, name=&quot;σz&quot;, visible=false, smooth=true)
sxy = showStressResults(S, :sxy, name=&quot;τxy&quot;, visible=false, smooth=true)
syz = showStressResults(S, :syz, name=&quot;τyz&quot;, visible=false, smooth=true)
szx = showStressResults(S, :szx, name=&quot;τzx&quot;, visible=false, smooth=true)

# Show velocity time history as a VectorField with time vector t
vVF = VectorField([], v, t, [], length(t), :u2D, problem)
vvec = showDoFResults(vVF, :uvec, name=&quot;v(t)&quot;, visible=true)
gmsh.view.option.setNumber(vvec, &quot;NormalRaise&quot;, 0.03)

sts = ceil(Int64, (base / c * 2) / 6 / (Tₘᵢₙ / π * (√(1 + ξₘₐₓ^2) - ξₘₐₓ)))
display(sts)
uVF_sts = VectorField([], u[:, sts:sts], [t[sts]], [], 1, :u2D, problem)
Sp = solveStress(uVF_sts)
sp = showStressResults(Sp, :s, name=&quot;σ at t&quot;, visible=false, smooth=false)

uVF_anim = VectorField([], u[:, 1:sts], t[1:sts], [], sts, :u2D, problem)
Sanim = solveStress(uVF_anim)
sanim = showStressResults(Sanim, :s, name=&quot;σ anim&quot;, visible=false, smooth=false)

gmsh.fltk.run()
gmsh.finalize()</code></pre><p>For more examples see <a href="https://github.com/perebalazs/LowLevelFEM.jl/tree/main/examples">examples on GitHub</a></p><hr/><h2 id="2D-Heat-Conduction-(steady-state)"><a class="docs-heading-anchor" href="#2D-Heat-Conduction-(steady-state)">2D Heat Conduction (steady state)</a><a id="2D-Heat-Conduction-(steady-state)-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Heat-Conduction-(steady-state)" title="Permalink"></a></h2><pre><code class="language-Julia hljs">using LowLevelFEM

gmsh.initialize()

# Problem and BCs
mat = material(&quot;body&quot;, k=45.0)
problem = Problem([mat], type=:PlaneHeatConduction, thickness=1.0)

bc_hot = temperatureConstraint(&quot;hot&quot;, T=100.0)
bc_cold = temperatureConstraint(&quot;cold&quot;, T=0.0)

# Assemble and solve K*T = q with Dirichlet BCs
Kth = heatConductionMatrix(problem)
qth = heatFluxVector(problem, [])
applyBoundaryConditions!(Kth, qth, [bc_hot, bc_cold])
T = solveTemperature(Kth, qth)

# Postprocess: temperature and heat flux
showDoFResults(T, :T, name=&quot;T&quot;, visible=true)
qflux = solveHeatFlux(T)
showHeatFluxResults(qflux, :qvec, name=&quot;q&quot;, visible=false, smooth=true)

openPostProcessor()
gmsh.finalize()</code></pre><h2 id="2D-Heat-Conduction-with-Convection"><a class="docs-heading-anchor" href="#2D-Heat-Conduction-with-Convection">2D Heat Conduction with Convection</a><a id="2D-Heat-Conduction-with-Convection-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Heat-Conduction-with-Convection" title="Permalink"></a></h2><pre><code class="language-Julia hljs">using LowLevelFEM

gmsh.initialize()

# Heat problem and BCs
matT = material(&quot;body&quot;, k=45.0)
probT = Problem([matT], type=:PlaneHeatConduction, thickness=1.0)

bc_hot = temperatureConstraint(&quot;hot&quot;, T=100.0)
hcv = heatConvection(&quot;conv&quot;, h=15.0, Tₐ=20.0)

Kth = heatConductionMatrix(probT)
qth = heatFluxVector(probT, [])
applyHeatConvection!(Kth, qth, [hcv])
applyBoundaryConditions!(Kth, qth, [bc_hot])
T = solveTemperature(Kth, qth)

showDoFResults(T, :T, name=&quot;T&quot;, visible=true)
qflux = solveHeatFlux(T)
showHeatFluxResults(qflux, :qvec, name=&quot;q&quot;, visible=false, smooth=true)

openPostProcessor()
gmsh.finalize()</code></pre><h2 id="Thermo‑Mechanical-Coupling-(Plane-Stress)"><a class="docs-heading-anchor" href="#Thermo‑Mechanical-Coupling-(Plane-Stress)">Thermo‑Mechanical Coupling (Plane Stress)</a><a id="Thermo‑Mechanical-Coupling-(Plane-Stress)-1"></a><a class="docs-heading-anchor-permalink" href="#Thermo‑Mechanical-Coupling-(Plane-Stress)" title="Permalink"></a></h2><pre><code class="language-Julia hljs">using LowLevelFEM

gmsh.initialize()

# 1) Heat problem to compute T(x)
matT = material(&quot;body&quot;, k=45.0)
probT = Problem([matT], type=:PlaneHeatConduction, thickness=1.0)
bc_hot = temperatureConstraint(&quot;hot&quot;, T=100.0)
hcv = heatConvection(&quot;conv&quot;, h=15.0, Tₐ=20.0)
Kth = heatConductionMatrix(probT)
qth = heatFluxVector(probT, [])
Cth = heatCapacityMatrix(probT)
applyHeatConvection!(Kth, qth, [hcv])
applyBoundaryConditions!(Kth, Cth, qth, [bc_hot])
T = solveTemperature(Kth, qth)

# 2) Elastic problem with thermal load
matE = material(&quot;body&quot;, E=210e3, ν=0.3, α=1.2e-5)
probE = Problem([matE], type=:PlaneStress, thickness=1.0)
K = stiffnessMatrix(probE)
fth = thermalLoadVector(probE, T)  # from temperature field
bc_fix = displacementConstraint(&quot;hot&quot;, ux=0.0, uy=0.0)
applyBoundaryConditions!(K, fth, [bc_fix])
q = solveDisplacement(K, fth)
S = solveStress(q)

showDoFResults(q, :uvec, name=&quot;u&quot;, visible=false)
showStressResults(S, :s, name=&quot;σ&quot;, visible=true, smooth=true)

openPostProcessor()
gmsh.finalize()</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Operators/">« Operators</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 24 September 2025 09:35">Wednesday 24 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
