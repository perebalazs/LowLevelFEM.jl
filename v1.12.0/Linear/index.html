<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear · LowLevelFEM</title><meta name="title" content="Linear · LowLevelFEM"/><meta property="og:title" content="Linear · LowLevelFEM"/><meta property="twitter:title" content="Linear · LowLevelFEM"/><meta name="description" content="Documentation for LowLevelFEM."/><meta property="og:description" content="Documentation for LowLevelFEM."/><meta property="twitter:description" content="Documentation for LowLevelFEM."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/plausible.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LowLevelFEM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../General/">General</a></li><li class="is-active"><a class="tocitem" href>Linear</a></li><li><a class="tocitem" href="../Heat/">Heat</a></li><li><a class="tocitem" href="../Poisson/">Poisson operators</a></li><li><a class="tocitem" href="../Nonlinear/">Nonlinear</a></li><li><a class="tocitem" href="../Operators/">Operators</a></li></ul></li><li><a class="tocitem" href="../Examples/">Examples</a></li><li><a class="tocitem" href="../news/">News &amp; Updates</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Linear</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/main/docs/src/Linear.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Mechanics"><a class="docs-heading-anchor" href="#Linear-Mechanics">Linear Mechanics</a><a id="Linear-Mechanics-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Mechanics" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDM-Tuple{SystemMatrix, SystemMatrix, SystemMatrix, VectorField, Vector{BoundaryCondition}, VectorField, VectorField, Int64, Float64}" href="#LowLevelFEM.CDM-Tuple{SystemMatrix, SystemMatrix, SystemMatrix, VectorField, Vector{BoundaryCondition}, VectorField, VectorField, Int64, Float64}"><code>LowLevelFEM.CDM</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CDM(K, M, C, f, bc, u0, v0, n, Δt)
CDM(K, M, f, bc, u0, v0, n, Δt)
CDM(K, M, C, f, u0, v0, n, Δt; support=[])
CDM(K, M, f, u0, v0, n, Δt; support=[])</code></pre><p>Solves a transient structural dynamic problem using the <strong>central difference method (CDM)</strong>, an explicit time integration scheme. (support ≡ bc)</p><p>The semi-discrete system</p><pre><code class="nohighlight hljs">
M * ü(t) + C * u̇(t) + K * u(t) = f(t)
</code></pre><p>is advanced in time using central finite differences. The method supports:</p><ul><li>time-independent or time-dependent load vectors <code>f</code></li><li>time-independent or time-dependent displacement boundary conditions</li><li>consistent treatment of constraint-induced inertia and damping terms</li><li>vector-valued unknowns (<code>VectorField</code>)</li></ul><p>Boundary conditions are applied <em>solver-side</em>: on constrained DOFs the prescribed displacements override the initial conditions, while on free DOFs the initial displacement <code>u0</code> and velocity <code>v0</code> are used. Velocities on constrained DOFs are derived from the prescribed displacements.</p><p>If <code>f.nsteps == 1</code>, the load is treated as time-independent. If <code>f.nsteps == n</code>, the load is applied time step–by–time step.</p><hr/><p><strong>Arguments</strong></p><ul><li><code>K::SystemMatrix</code>   Global stiffness matrix.</li><li><code>M::SystemMatrix</code>   Global mass matrix (assumed diagonal or lumped for efficiency).</li><li><code>C::SystemMatrix</code>   Global damping matrix. If omitted, zero damping is assumed.</li><li><code>f::VectorField</code>   External load vector (time-independent or time-dependent).</li><li><code>bc::Vector{BoundaryCondition}</code>   Displacement-type boundary conditions (possibly time-dependent).</li><li><code>u0::VectorField</code>   Initial displacement field. Overridden on constrained DOFs.</li><li><code>v0::VectorField</code>   Initial velocity field. Overridden on constrained DOFs.</li><li><code>n::Int</code>   Number of time steps.</li><li><code>Δt::Float64</code>   Time step size.</li></ul><hr/><p><strong>Returns</strong></p><ul><li><code>u::VectorField</code>   Displacement field at all time steps (<code>ndof × nsteps</code>).</li><li><code>v::VectorField</code>   Velocity field at all time steps (<code>ndof × nsteps</code>).</li></ul><p>The associated time vector is</p><pre><code class="nohighlight hljs">
t = 0 : Δt : (n-1)Δt
</code></pre><hr/><p><strong>Notes</strong></p><ul><li>The method is conditionally stable. The critical time step is governed by the highest eigenfrequency and damping:</li></ul><pre><code class="nohighlight hljs">
Δt_max = T_min / π * (√(1 + ξ_max^2) - ξ_max)
</code></pre><p>where <code>T_min</code> is the smallest modal period and <code>ξ_max</code> is the largest modal damping ratio.</p><ul><li>The algorithm itself is agnostic to the physical meaning of the displacement field;</li></ul><p>it operates purely on the algebraic system defined by <code>M</code>, <code>C</code>, and <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5795-L5876">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.CDMaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.CDMaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CDMaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=..., ξ=..., β=..., show_β=..., show_ξ=...)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the CDM method.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:PDR</code>: physical damping ratio</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. The damping matrix is assembled in the  following ways: <strong>C</strong>=α<strong>M</strong>+β<strong>K</strong> or <strong>C</strong>=α<strong>M</strong>+β₁<strong>K</strong>+β₂<strong>KM⁻¹K</strong>+β₃<strong>KM⁻¹KM⁻¹K</strong>+⋅⋅⋅.  The latter corresponds to the damping characteristic characterized by a power series consisting of powers of the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the argument list) are the values ​​of the  individual members of the series corresponding to the ωₘₐₓ value. βᵢ (<code>β</code> in the argument list) are the  coefficients of the series. (see <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>) Either <code>ξ</code> or <code>β</code> must be specified. <code>ξ</code> or <code>β</code> are scalars or  vectors. If <code>show_β</code> or <code>show_ξ</code> is <code>true</code>, the corresponding <code>β</code> or <code>ξ</code> values will be  sent to the output. Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64 of Vector{Float64}</li><li><code>ξ</code>: Float64 of Vector{Float64}</li><li><code>show_β</code>: Boolean</li><li><code>show_ξ</code>: Boolean</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L6229-L6267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHT-Tuple{SystemMatrix, SystemMatrix, VectorField, Vector{BoundaryCondition}, VectorField, VectorField, Int64, Float64}" href="#LowLevelFEM.HHT-Tuple{SystemMatrix, SystemMatrix, VectorField, Vector{BoundaryCondition}, VectorField, VectorField, Int64, Float64}"><code>LowLevelFEM.HHT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HHT(K, M, f, bc, u0, v0, n, Δt; α=0.0, δ=0.0, γ=0.5+δ, β=0.25*(0.5+γ)^2)
HHT(K, M, f, u0, v0, n, Δt; α=0.0, δ=0.0, γ=0.5+δ, β=0.25*(0.5+γ)^2)</code></pre><p>Solves a transient structural dynamic problem using the <strong>Hilber–Hughes–Taylor (HHT-α) method</strong><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, an implicit time integration scheme with controllable numerical dissipation.</p><p>The semi-discrete system</p><pre><code class="nohighlight hljs">
M * ü(t) + K * u(t) = f(t)
</code></pre><p>is integrated in time using the generalized Newmark formulation with the HHT-α modification. The method supports:</p><ul><li>time-independent or time-dependent load vectors <code>f</code></li><li>time-independent or time-dependent displacement boundary conditions</li><li>solver-side enforcement of Dirichlet constraints</li><li>consistent treatment of constraint-induced inertia forces</li><li>vector-valued unknowns (<code>VectorField</code>)</li></ul><p>Boundary conditions are applied <em>solver-side</em>: on constrained DOFs the prescribed displacements override the initial conditions, while on free DOFs the initial displacement <code>u0</code> and velocity <code>v0</code> are used. Prescribed displacements are inserted at every time step, and the corresponding inertial contributions are accounted for automatically through the global system.</p><p>If <code>f.nsteps == 1</code>, the load is treated as time-independent. If <code>f.nsteps == n</code>, the load is applied time step–by–time step.</p><p>The parameters <code>α</code>, <code>β</code>, and <code>γ</code> control numerical dissipation and stability. If <code>δ</code> is given, the standard relations</p><pre><code class="nohighlight hljs">
γ = 0.5 + δ
β = 0.25 * (0.5 + γ)^2
</code></pre><p>are used.</p><hr/><p><strong>Arguments</strong></p><ul><li><code>K::SystemMatrix</code>   Global stiffness matrix.</li><li><code>M::SystemMatrix</code>   Global mass matrix.</li><li><code>f::VectorField</code>   External load vector (time-independent or time-dependent).</li><li><code>bc::Vector{BoundaryCondition}</code>   Displacement-type boundary conditions (possibly time-dependent).</li><li><code>u0::VectorField</code>   Initial displacement field. Overridden on constrained DOFs.</li><li><code>v0::VectorField</code>   Initial velocity field. Overridden on constrained DOFs.</li><li><code>n::Int</code>   Number of time steps.</li><li><code>Δt::Float64</code>   Time step size.</li></ul><hr/><p><strong>Returns</strong></p><ul><li><code>u::VectorField</code>   Displacement field at all time steps (<code>ndof × nsteps</code>).</li><li><code>v::VectorField</code>   Velocity field at all time steps (<code>ndof × nsteps</code>).</li></ul><p>The associated time vector is</p><pre><code class="nohighlight hljs">
t = 0 : Δt : (n-1)Δt
</code></pre><hr/><p><strong>Notes</strong></p><ul><li>The HHT-α method is unconditionally stable for appropriate parameter choices and introduces numerical dissipation primarily in the high-frequency range.</li><li>The algorithm itself is independent of the physical interpretation of the displacement field and operates purely on the algebraic system defined by <code>M</code>, <code>K</code>, and <code>f</code>.</li><li>Damping matrices are not included explicitly; numerical dissipation is controlled via the HHT-α parameters.</li></ul><hr/><p><strong>Reference</strong></p><p>Hilber, H. M., Hughes, T. J. R., Taylor, R. L.   <em>Improved numerical dissipation for time integration algorithms in structural dynamics</em>,   Earthquake Engineering &amp; Structural Dynamics, 5(3), 283–292, 1977.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5951-L6048">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}" href="#LowLevelFEM.HHTaccuracyAnalysis-NTuple{4, Any}"><code>LowLevelFEM.HHTaccuracyAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HHTaccuracyAnalysis(ωₘᵢₙ, ωₘₐₓ, Δt, type; n=100, α=0.0, δ=0.0, γ=0.5 + δ, β=0.25 * (0.5 + γ)^2)</code></pre><p>Gives some functions (graphs) for accuracy analysis of the HHT-α method<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  <code>ωₘᵢₙ</code> and <code>ωₘₐₓ</code> are the square root of smallest and largest eigenvalues of the <strong>Kϕ</strong>=ω²<strong>Mϕ</strong> eigenvalue problem, <code>Δt</code> is the time step size. <code>type</code> is one of the following values:</p><ul><li><code>:SR</code>: spectral radius</li><li><code>:ADR</code>: algorithmic damping ratio</li><li><code>:PE</code>: period error</li></ul><p>For details see <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> and <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.  <code>n</code> is the number of points in the graph. For the meaning of <code>α</code>, <code>β</code> and <code>γ</code> see <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. If <code>δ</code> is given, γ=0.5+δ and β=0.25⋅(0.5+γ)². Returns a tuple of x and y values of the graph. (Can be plotted with <code>plot(xy)</code>)</p><p>Return: <code>xy</code></p><p>Types:</p><ul><li><code>ωₘᵢₙ</code>: Float64</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>Δt</code>: Float64 </li><li><code>n</code>: Int64</li><li><code>α</code>: Float64</li><li><code>β</code>: Float64</li><li><code>γ</code>: Float64</li><li><code>δ</code>: Float64</li><li><code>xy</code>: Tuple{Vector{Float64},Vector{Float64}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L6326-L6360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions!-Tuple{Union{ScalarField, TensorField, VectorField}, Vector{BoundaryCondition}}" href="#LowLevelFEM.applyBoundaryConditions!-Tuple{Union{ScalarField, TensorField, VectorField}, Vector{BoundaryCondition}}"><code>LowLevelFEM.applyBoundaryConditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions!(field::Union{ScalarField,VectorField,TensorField}, supports::Vector{BoundaryCondition})</code></pre><p>Applies boundary conditions <code>supports</code> on a <code>ScalarField</code>, <code>VectorField</code> or <code>TensorField</code> <code>field</code>. Mesh details are in <code>problem</code>. <code>supports</code> is <code>BoundaryCondition</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>field</code>: ScalarField, VectorField or TensorField</li><li><code>supports</code>: Vector{BoundaryCondition}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L3669-L3681">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyBoundaryConditions-Tuple{Problem, Vector{BoundaryCondition}}" href="#LowLevelFEM.applyBoundaryConditions-Tuple{Problem, Vector{BoundaryCondition}}"><code>LowLevelFEM.applyBoundaryConditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyBoundaryConditions(problem::Problem, supports::Vector{BoundaryCondition})</code></pre><p>Create a <code>ScalarField</code>, <code>VectorField</code> or <code>TensorField</code> and applies the boundary  conditions <code>supports</code> on it. Mesh details are in <code>problem</code>. <code>supports</code> is <code>BoundaryCondition</code>.</p><p>Returns: ScalarField, VectorField or TensorField</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>supports</code>: Vector{BoundaryCondition}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L3763-L3774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.applyElasticSupport!-Tuple{SystemMatrix, Any}" href="#LowLevelFEM.applyElasticSupport!-Tuple{SystemMatrix, Any}"><code>LowLevelFEM.applyElasticSupport!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applyElasticSupport!(stiffMat, elastSupp)</code></pre><p>Applies elastic support boundary conditions <code>elastSupp</code> on a stiffness matrix <code>stiffMat</code>. Mesh details are in <code>problem</code>. <code>elastSupp</code> is a tuple of <code>name</code> of physical group and prescribed <code>kx</code>, <code>ky</code> and <code>kz</code> stiffnesses.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>stiffMat</code>: SystemMatrix </li><li><code>elastSupp</code>: Vector{BoundaryCondition}}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L3791-L3803">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}" href="#LowLevelFEM.dampingMatrix-Tuple{Any, Any, Any}"><code>LowLevelFEM.dampingMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dampingMatrix(K, M, ωₘₐₓ; α=0.0, ξ=..., β=...)</code></pre><p>Generates the damping matrix for proportional damping. C = αM + βK, or C = αM + β₁K + β₂KM⁻¹K + β₃KM⁻¹KM⁻¹K + ⋯. The latter corresponds to a damping characteristic given by a power series in the natural frequencies with odd exponents. ξᵢ (<code>ξ</code> in the arguments) are the values of the individual terms of the series at ωₘₐₓ. βᵢ (<code>β</code> in the arguments) are the coefficients of the series. Either <code>ξ</code> or <code>β</code> must be specified; each may be a scalar or a vector. <code>K</code> is the stiffness matrix, <code>M</code> is the mass matrix, and <code>ωₘₐₓ</code> is the largest natural frequency.</p><p>Returns: <code>dampingMatrix</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>ωₘₐₓ</code>: Float64</li><li><code>α</code>: Float64</li><li><code>ξ</code>: Float64 or Vector{Float64}</li><li><code>β</code>: Float64 or Vector{Float64}</li><li><code>dampingMatrix</code>: SystemMatrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">K = stiffnessMatrix(problem)
M = massMatrix(problem; lumped=true)
ωmax = 2π * 1000
C = dampingMatrix(K, M, ωmax; α=0.0, ξ=[0.02, 0.02])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L2785-L2815">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}" href="#LowLevelFEM.elasticSupportMatrix-Tuple{Any, Any}"><code>LowLevelFEM.elasticSupportMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elasticSupportMatrix(problem, elSupp)</code></pre><p>Solves the elastic support matrix of the <code>problem</code>. <code>elSupp</code> is a vector of elastic supports defined in function <code>elasticSupport</code>. With the displacementent vector <code>q</code> in hand the reaction force vector <code>fR</code> arising from the elastic support can be solved. (<code>fR = heatConvMat * q</code>)</p><p>Return: <code>elSuppMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>elSupp</code>: Vector{BoundaryCondition}</li><li><code>elSuppMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L2842-L2856">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement!-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement!-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialDisplacement!(u0, name; ux=..., uy=..., uz=...)</code></pre><p>Changes the displacement values to <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in displacement vector <code>u0</code>.</p><p>Return: nothing</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li><li><code>u0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5615-L5630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialDisplacement-Tuple{Any, Any}" href="#LowLevelFEM.initialDisplacement-Tuple{Any, Any}"><code>LowLevelFEM.initialDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialDisplacement(problem, name; ux=..., uy=..., uz=...)</code></pre><p>Sets the displacement values <code>ux</code>, <code>uy</code> and <code>uz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial displacement vector <code>u0</code>.</p><p>Return: u0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>u0</code>: VectorField</li><li><code>ux</code>: Float64 </li><li><code>uy</code>: Float64 </li><li><code>uz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5593-L5609">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity!-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity!-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialVelocity!(v0, name; vx=..., vy=..., vz=...)</code></pre><p>Changes the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Original values are in velocity vector <code>v0</code>.</p><p>Returns: nothing</p><p>Types:</p><ul><li><code>name</code>: String </li><li><code>v0</code>: VectorField</li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5658-L5673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.initialVelocity-Tuple{Any, Any}" href="#LowLevelFEM.initialVelocity-Tuple{Any, Any}"><code>LowLevelFEM.initialVelocity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialVelocity(problem, name; vx=..., vy=..., vz=...)</code></pre><p>Sets the velocity values <code>vx</code>, <code>vy</code> and <code>vz</code> (depending on the dimension of the <code>problem</code>) at nodes belonging to physical group <code>name</code>. Returns the initial velocity vector <code>v0</code>.</p><p>Return: v0</p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>name</code>: String </li><li><code>vx</code>: Float64 </li><li><code>vy</code>: Float64 </li><li><code>vz</code>: Float64 </li><li><code>v0</code>: VectorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5636-L5652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestEigenValue-Tuple{SystemMatrix, SystemMatrix}" href="#LowLevelFEM.largestEigenValue-Tuple{SystemMatrix, SystemMatrix}"><code>LowLevelFEM.largestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">largestEigenValue(K, M)</code></pre><p>Solves the smallest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘᵢₙ</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>λₘᵢₙ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5768-L5780">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.largestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.largestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.largestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">largestPeriodTime(K, M, bc)</code></pre><p>Solves the largest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>, <code>bc</code> is a vector of <code>BoundaryCondition</code> where the displacement is given.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>bc</code>: Vector{BoundaryCondition}</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5679-L5693">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.loadVector-Tuple{Any, Any}" href="#LowLevelFEM.loadVector-Tuple{Any, Any}"><code>LowLevelFEM.loadVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadVector(problem, loads; F=nothing)</code></pre><p>Assembles the right-hand-side vector associated with external mechanical loads in weak-form finite element problems.</p><p>Depending on the problem dimension and the dimension of the physical group, this function handles concentrated forces, line/surface/volume loads, tractions, pressures, and body forces in 1D, 2D, and 3D.</p><p>The interpretation of the physical group dimension is:</p><ul><li>1D problems:<ul><li>Point  → concentrated force</li><li>Line   → distributed force</li></ul></li><li>2D problems:<ul><li>Point  → concentrated force</li><li>Line   → surface force</li><li>Surface → body force</li></ul></li><li>3D problems:<ul><li>Point  → concentrated force</li><li>Line   → edge force</li><li>Surface → surface force</li><li>Volume → body force</li></ul></li></ul><p>Load components may be specified as constants, spatial functions, or <code>ScalarField</code>s (nodal type). Axisymmetric and other weighted formulations can be handled by including the appropriate geometric factor (e.g. <code>2πr</code>) in the load definition or coefficient.</p><p>Returns a <code>VectorField</code> for vector-valued problems (<code>pdim &gt; 1</code>) and a <code>ScalarField</code> for scalar problems (<code>pdim == 1</code>).</p><p>If <code>F</code> is the deformation gradient (a <code>TensorField</code>), then the function solves the follower load for large displacement problems (in 3D).</p><p>Return: <code>loadVec</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>loads</code>: Vector{BoundaryCondition}</li><li><code>loadVec</code>: VectorField</li><li><code>F</code>: Union{Nothing,TensorField}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L3057-L3098">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.massMatrix-Tuple{Any}" href="#LowLevelFEM.massMatrix-Tuple{Any}"><code>LowLevelFEM.massMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">massMatrix(problem; lumped=...)</code></pre><p>Solves the mass matrix of the <code>problem</code>. If <code>lumped</code> is true, computes the lumped mass matrix.</p><p>Returns: <code>massMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>lumped</code>: Boolean</li><li><code>massMat</code>: SystemMatrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">M = massMatrix(problem; lumped=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L1825-L1842">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.nonLinearStiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.nonLinearStiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonLinearStiffnessMatrix(problem, q)</code></pre><p>Solves the nonlinear stiffness matrix of the <code>problem</code>. <code>q</code> is a displacement field.</p><p>Returns: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>q</code>: VectorField</li><li><code>stiffMat</code>: SystemMatrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L1538-L1549">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.printElasticConstantsTable-Tuple{}" href="#LowLevelFEM.printElasticConstantsTable-Tuple{}"><code>LowLevelFEM.printElasticConstantsTable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">printElasticConstantsTable(; io::IO=stdout)</code></pre><p>Prints a compact reference table of the most common relations between isotropic linear-elastic material constants:</p><ul><li>Young&#39;s modulus <code>E</code></li><li>Poisson&#39;s ratio <code>ν</code></li><li>Shear modulus <code>G</code> (also denoted as <code>μ</code>)</li><li>Bulk modulus <code>K</code></li><li>Lamé&#39;s first parameter <code>λ</code></li><li>Lamé&#39;s second parameter <code>μ</code> (= <code>G</code>)</li></ul><p>The table is meant as a quick cheat-sheet for documentation / teaching.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L6408-L6422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestEigenValue-Tuple{SystemMatrix, SystemMatrix}" href="#LowLevelFEM.smallestEigenValue-Tuple{SystemMatrix, SystemMatrix}"><code>LowLevelFEM.smallestEigenValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smallestEigenValue(K, M)</code></pre><p>Solves the largest eigenvalue for a transient problem given by stiffness (heat conduction) matrix <code>K</code> and the mass (heat capacity) matrix <code>M</code> (<code>C</code>).</p><p>Return: <code>λₘₐₓ</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>λₘₐₓ</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5739-L5751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}" href="#LowLevelFEM.smallestPeriodTime-Tuple{Any, Any}"><code>LowLevelFEM.smallestPeriodTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smallestPeriodTime(K, M, support=[])</code></pre><p>Solves the smallest period of time for a dynamic problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>, <code>support</code> is a vector of <code>BoundaryCondition</code> where the displacement is given.</p><p>Return: <code>Δt</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>support</code>: Vector{BoundaryCondition}</li><li><code>Δt</code>: Float64 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5710-L5724">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveAxialForce-Tuple{VectorField}" href="#LowLevelFEM.solveAxialForce-Tuple{VectorField}"><code>LowLevelFEM.solveAxialForce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveAxialForce(u::VectorField)</code></pre><p>Compute axial (bar/truss) forces from a displacement field.</p><p>The input displacement field <code>u</code> must be nodal (VectorField), typically containing the nodal displacements of a truss or bar structure.   The output is a scalar field (ScalarField), where each value represents  the axial force in a truss element.</p><p><strong>Arguments</strong></p><ul><li><code>u::VectorField</code>: nodal displacement field.</li></ul><p><strong>Returns</strong></p><ul><li><code>ScalarField</code>: axial forces defined per element.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">u = solveDisplacement(problem, load=[loads], support=[supports])  # VectorField of nodal displacements
N = solveAxialForce(u)                               # ScalarField of axial element forces</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5194-L5215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBuckling-Tuple{Any}" href="#LowLevelFEM.solveBuckling-Tuple{Any}"><code>LowLevelFEM.solveBuckling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveBuckling(problem; load=[], support=[], n=6)</code></pre><p>Solves the multipliers for the first <code>n</code> critical forces and the corresponding  buckling shapes for the instability of the <code>problem</code>, when <code>loads</code> and  <code>support</code> are applied. Result can be presented by <code>showBucklingResults</code> function. <code>loads</code> and <code>support</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively.</p><p>Return: <code>buckling</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>load</code>: Vector{BoundaryCondition}</li><li><code>support</code>: Vector{BoundaryCondition}</li><li><code>n</code>: Int64</li><li><code>buckling</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5546-L5563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveBucklingModes-Tuple{Any, Any}" href="#LowLevelFEM.solveBucklingModes-Tuple{Any, Any}"><code>LowLevelFEM.solveBucklingModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveBucklingModes(K, Knl; n=6)</code></pre><p>Solves the critical force multipliers and buckling mode shapes of a problem given by stiffness matrix <code>K</code> and the nonlinear stiffness matrix <code>Knl</code>. <code>n</code> is the number of buckling modes to solve. Returns the struct of critical forces and buckling modes. Results can be presented by <code>showBucklingResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>Knl</code>: SystemMatrix</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5433-L5447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{Problem}" href="#LowLevelFEM.solveDisplacement-Tuple{Problem}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(problem;
                  load = BoundaryCondition[],
                  support = BoundaryCondition[],
                  elasticSupport = BoundaryCondition[],
                  condensed = true,
                  iterative = false,
                  reltol = sqrt(eps()),
                  maxiter = problem.non * problem.dim,
                  preconditioner = Identity(),
                  ordering = true)</code></pre><p>Computes the displacement vector <code>u</code> for a given [<code>Problem</code>] subject to external loads, essential supports, and optional elastic supports.</p><p>The stiffness matrix is assembled internally. Depending on the value of <code>condensed</code>, either a reduced system (eliminating constrained degrees of freedom) or the full system with modified rows and columns is solved.</p><p>This is the <strong>high-level, user-facing displacement solver</strong>.</p><p><strong>Arguments</strong></p><ul><li><code>problem::Problem</code>: Finite element problem definition (geometry, materials, DOFs, etc.).</li><li><code>load::Vector{BoundaryCondition}</code> (keyword, optional): Prescribed nodal loads.</li><li><code>support::Vector{BoundaryCondition}</code> (keyword, optional): Essential (Dirichlet) boundary conditions.</li><li><code>elasticSupport::Vector{BoundaryCondition}</code> (keyword, optional): Elastic (spring-type) supports contributing to the stiffness matrix.</li><li><code>condensed::Bool</code> (keyword): If <code>true</code>, solves the reduced system using only free degrees of freedom. If <code>false</code>, modifies the full system matrix explicitly.</li><li><code>iterative::Bool</code> (keyword): If <code>true</code>, uses the conjugate gradient method.</li><li><code>reltol::Real</code> (keyword): Relative tolerance for the iterative solver.</li><li><code>maxiter::Int</code> (keyword): Maximum number of iterations for the iterative solver.</li><li><code>preconditioner</code> (keyword): Preconditioner object for iterative solution (e.g. from <code>ilu</code> or <code>ichol</code>).</li><li><code>ordering::Bool</code> (keyword): If <code>false</code>, disables column reordering in the direct solver (<code>lu(A, q=nothing)</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>u::VectorField</code>: Displacement vector defined on the problem degrees of freedom.</li></ul><p><strong>Notes</strong></p><ul><li>If <code>problem.type == :dummy</code>, the function returns <code>nothing</code>.</li><li>When <code>condensed = true</code>, constrained DOFs are eliminated algebraically.</li><li>When <code>condensed = false</code>, constrained rows and columns are modified explicitly.</li><li>This function internally calls the low-level <code>solveDisplacement(K, f; ...)</code> routine after assembling the stiffness matrix and load vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L3900-L3955">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveDisplacement-Tuple{SystemMatrix, VectorField}" href="#LowLevelFEM.solveDisplacement-Tuple{SystemMatrix, VectorField}"><code>LowLevelFEM.solveDisplacement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveDisplacement(K, f; support = BoundaryCondition[],
                  iterative = false,
                  reltol = sqrt(eps()),
                  maxiter = K.model.non * K.model.dim,
                  preconditioner = Identity(),
                  ordering = true)</code></pre><p>Solves the linear system</p><pre><code class="nohighlight hljs">K * u = f</code></pre><p>for the displacement vector <code>u</code>, where <code>K</code> is a stiffness matrix and <code>f</code> is the load vector. Essential (Dirichlet) boundary conditions are imposed via the <code>support</code> argument.</p><p>This is a <strong>low-level solver</strong> operating directly on a preassembled [<code>SystemMatrix</code>] and load [<code>VectorField</code>]. It assumes that the stiffness matrix already includes all material contributions (and optional elastic supports).</p><p>If <code>iterative = true</code>, the reduced system is solved using the conjugate gradient method. Otherwise, a direct solver is used.</p><p><strong>Arguments</strong></p><ul><li><code>K::SystemMatrix</code>: Assembled stiffness matrix associated with a [<code>Problem</code>].</li><li><code>f::VectorField</code>: Load vector.</li><li><code>support::Vector{BoundaryCondition}</code> (keyword, optional): Essential boundary conditions (Dirichlet-type constraints). Default is an empty vector (no supports).</li><li><code>iterative::Bool</code> (keyword): If <code>true</code>, uses the conjugate gradient method.</li><li><code>reltol::Real</code> (keyword): Relative tolerance for the iterative solver.</li><li><code>maxiter::Int</code> (keyword): Maximum number of iterations for the iterative solver.</li><li><code>preconditioner</code> (keyword): Preconditioner object for iterative solution (e.g. from <code>ilu</code> or <code>ichol</code>).</li><li><code>ordering::Bool</code> (keyword): If <code>false</code>, disables column reordering in the direct solver (<code>lu(A, q=nothing)</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>u::VectorField</code>: Displacement vector satisfying the prescribed boundary conditions.</li></ul><p><strong>Notes</strong></p><ul><li>Only the unconstrained degrees of freedom are solved for; constrained values are imposed explicitly.</li><li>This function is primarily intended for internal or advanced use. Most users should prefer the high-level <code>solveDisplacement(problem; ...)</code> interface.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L3813-L3865">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveEigenModes-Tuple{Any, Any}" href="#LowLevelFEM.solveEigenModes-Tuple{Any, Any}"><code>LowLevelFEM.solveEigenModes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveEigenModes(K, M; n=6, fₘᵢₙ=1.01)</code></pre><p>Solves the eigen frequencies and mode shapes of a problem given by stiffness matrix <code>K</code> and the mass matrix <code>M</code>. <code>n</code> is the number of eigenfrequencies to solve, and solves the eigenfrequencies greater than <code>fₘᵢₙ</code>. Returns the struct of eigenfrequencies and eigen modes. Results can be presented by <code>showModalResults</code> function.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>K</code>: SystemMatrix</li><li><code>M</code>: SystemMatrix</li><li><code>n</code>: Int64</li><li><code>fₘᵢₙ</code>: Float64</li><li><code>modes</code>: Eigen </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5393-L5409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveModalAnalysis-Tuple{Any}" href="#LowLevelFEM.solveModalAnalysis-Tuple{Any}"><code>LowLevelFEM.solveModalAnalysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveModalAnalysis(problem; support=[]; load=[], n=6, fₘᵢₙ=0.00001, directSolver=false)</code></pre><p>Solves the first <code>n</code> eigenfrequencies and the corresponding  mode shapes for the <code>problem</code>, when <code>load</code> and  <code>support</code> are applied. <code>load</code> and <code>contraints</code> are optional.  Result can be presented by <code>showModalResults</code> function.  <code>load</code> and <code>support</code> can be defined by <code>load</code> and <code>displacementConstraint</code> functions, respectively. If <code>load</code> are given, it solves the eigenfrequencies of a prestressed structure.</p><p>Return: <code>modes</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>load</code>: Vector{tuples}</li><li><code>support</code>: Vector{tuples}</li><li><code>n</code>: Int64</li><li><code>modes</code>: Eigen</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L5466-L5484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStrain-Tuple{Any}" href="#LowLevelFEM.solveStrain-Tuple{Any}"><code>LowLevelFEM.solveStrain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveStrain(q; DoFResults=false)</code></pre><p>Solves the strain field <code>E</code> from displacement vector <code>q</code>. Strain field is given per elements, so it usually contains jumps at the boundaries of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>E</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStrainResults</code> or <code>showElementResults</code>).</p><p>Return: <code>E</code></p><p>Types:</p><ul><li><code>q</code>: VectorField</li><li><code>E</code>: TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L4027-L4041">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.solveStress-Tuple{VectorField}" href="#LowLevelFEM.solveStress-Tuple{VectorField}"><code>LowLevelFEM.solveStress</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solveStress(q; T=..., T₀=..., DoFResults=false)</code></pre><p>Solves the stress field <code>S</code> from displacement vector <code>q</code>. Stress field is given per elements, so it usually contains jumps at the boundary of elements. Details of mesh is available in <code>problem</code>. If <code>DoFResults</code> is true, <code>S</code> is a matrix with nodal results. In this case <code>showDoFResults</code> can be used to show the results  (otherwise <code>showStressResults</code> or <code>showElementResults</code>). If the <code>T</code> temperature field (and <code>T₀</code> initial temperature field if it differs from zero) is given, the function solves also the thermal stresses.</p><p>Return: <code>S</code></p><p>Types:</p><ul><li><code>q</code>: VectorField</li><li><code>T</code>: ScalarField</li><li><code>T₀</code>: ScalarField</li><li><code>S</code>: TensorField</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L4668-L4686">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LowLevelFEM.stiffnessMatrix-Tuple{Any}" href="#LowLevelFEM.stiffnessMatrix-Tuple{Any}"><code>LowLevelFEM.stiffnessMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stiffnessMatrix(problem; forceOneThread=true)</code></pre><p>Solves the stiffness matrix of the <code>problem</code>.</p><p>Returns: <code>stiffMat</code></p><p>Types:</p><ul><li><code>problem</code>: Problem</li><li><code>stiffMat</code>: SystemMatrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">K = stiffnessMatrix(problem)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/perebalazs/LowLevelFEM.jl/blob/323f458361450de6c3dec059421c72257d86cae4/src/linear.jl#L53-L69">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a>Serfőző, D., Pere, B.: <em>An effective reduction method with Caughey damping for  spurious oscillations in dynamic problems</em>, Meccanica, <a href="https://doi.org/10.1007/s11012-025-02036-9">https://doi.org/10.1007/s11012-025-02036-9</a></li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Hilber, Hans M., Thomas JR Hughes, and Robert L. Taylor. <em>Improved  numerical dissipation for time integration algorithms in structural  dynamics</em>. Earthquake Engineering &amp; Structural Dynamics 5.3 (1977): 283-292.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Belytschko, Ted, and Thomas JR, Hughes: <em>Computational methods for  transient analysis</em>, North-Holland, (1983).</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>Serfőző, D., Pere, B.: <em>A method to accurately define arbitrary algorithmic damping character as viscous damping</em>. Arch Appl Mech 93, 3581–3595 (2023). <a href="https://doi.org/10.1007/s00419-023-02454-9">https://doi.org/10.1007/s00419-023-02454-9</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../General/">« General</a><a class="docs-footer-nextpage" href="../Heat/">Heat »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 2 February 2026 09:45">Monday 2 February 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
