[![Build Status](https://github.com/perebalazs/LowLevelFEM.jl/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/perebalazs/LowLevelFEM.jl/actions/workflows/CI.yml?query=branch%3Amain)
[![](https://img.shields.io/badge/docs-dev-blue.svg)](https://perebalazs.github.io/LowLevelFEM.jl/dev)
[![](https://img.shields.io/badge/docs-stable-blue.svg)](https://perebalazs.github.io/LowLevelFEM.jl/stable)
[![codecov](https://codecov.io/gh/perebalazs/LowLevelFEM.jl/branch/main/graph/badge.svg)](https://codecov.io/gh/perebalazs/LowLevelFEM.jl)
[![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)](https://opensource.org/licenses/MIT)
<!-- [![DOI](https://joss.theoj.org/papers/10.21105/joss.XXXXX/status.svg)](https://doi.org/10.21105/joss.XXXXX) -->
<!-- [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.YYYYYYY.svg)](https://doi.org/10.5281/zenodo.YYYYYYY) -->


# LowLevelFEM

LowLevelFEM is a Julia package for finite element analysis with an engineering-first workflow. It exposes each phase of the workflow as simple functions (mesh → matrices → loads/BCs → solve → postprocess → visualize), so you can customize, combine, or inspect any step. Typical tasks such as strain energy or resultants are one-liners (for example, `U = q' * K * q / 2`).

## Requirements

- Julia 1.x
- Gmsh C API is bundled via `gmsh_jll` and re-exported as `gmsh` from this package; no separate Gmsh.jl installation is required.

## Capabilities

- Geometry and meshing: integrates with `gmsh` for 2D/3D geometry, meshing, and physical groups.
- Problem types: 3D solids, 2D plane stress/plane strain, axisymmetric; 3D/2D heat conduction and axisymmetric heat conduction.
- Elements and order: standard line/triangle/quad/tetra/hex/pyramid/wedge with Lagrange order up to 10.
- Materials: linear elastic (Hooke) and large deformation laws (St. Venant–Kirchhoff, compressible Neo-Hooke).
- Matrices: stiffness `K`, mass `M` (lumped or consistent), proportional damping `C` (Rayleigh/Caughey), heat conduction/capacity, latent heat, and convection matrices/vectors.
- Loads and constraints: nodal and distributed loads on physical groups; function-based loads and temperature BCs; elastic supports; initial displacement/velocity/temperature.
- Thermal–structural coupling: thermal expansion, thermal stresses, and heat generated by elastic deformation.
- Solvers: static and transient dynamics (central difference and HHT-α from the Newmark family).
- Eigenproblems: modal analysis (frequencies and mode shapes, optionally prestressed) and linear buckling (critical factors and modes).
- Field operators and results: gradient/divergence/curl; stress/strain and heat flux as element or nodal fields; smoothing at nodes with field jumps; user-defined scalar/vector/tensor FE fields.
- Visualization and plots: Gmsh-based views for displacements, stresses, strains, heat flux, with animation for dynamics; plot results along user-defined paths; show results on surfaces.
- Coordinate systems: rotate nodal DOFs with constant or function-defined local coordinate systems (incl. curvilinear).
- Truss stuctures (static, transient, modal analysis)

## Installation

```julia
using Pkg
Pkg.add("LowLevelFEM")
```

## Quick Start

```julia
using LowLevelFEM

# `gmsh` is exported by LowLevelFEM
gmsh.initialize()
gmsh.open("your_model.geo")

mat = material("body", E=2e5, ν=0.3)
prob = Problem([mat], type=:PlaneStress)  # :Solid, :PlaneStrain, :AxiSymmetric, :HeatConduction, ...

bc   = displacementConstraint("supp", ux=0, uy=0)
force = load("load", fy=-1)

q = solveDisplacement(prob, [force], [bc])
S = solveStress(q)

showDoFResults(q, :uvec)
showStressResults(S, :s)

openPostProcessor()
gmsh.finalize()
```

Note: physical group names in your geometry (created in Gmsh) must match the strings used above (e.g., `"body"`, `"supp"`, `"load"`).

### An alternative solution (instead of `q = ...`, `S = ...`)

```julia
K = stiffnessMatrix(prob)
f = loadVector(prob, [force])
applyBoundaryConditions!(K, f, [bc])
q = K \ f

E = mat.E
ν = mat.ν

A = (u ∘ ∇ + ∇ ∘ u) / 2
I = unitTensor(A)
S = E / (1 + ν) * (A + ν / (1 - 2ν) * trace(A) * I)
```

More end-to-end examples are available under [examples](https://github.com/perebalazs/LowLevelFEM.jl/tree/main/examples) and in the [documentation](https://perebalazs.github.io/LowLevelFEM.jl/stable/).

## Documentation

- Latest docs: <https://perebalazs.github.io/LowLevelFEM.jl/dev>
- Stable docs: <https://perebalazs.github.io/LowLevelFEM.jl/stable>

## Planned features

- Other material laws (incompressible Neo-Hooke, Mooney-Rivlin, etc.)
- Beam, shell elements
- Contact problems (penalty, Lagrange multiplier)
- Multithreading (partially implemented)

Any [suggestions](https://github.com/perebalazs/LowLevelFEM.jl/discussions) are welcome. In case of any issue, please send a [bug report](https://github.com/perebalazs/LowLevelFEM.jl/issues).

## License

This project is licensed under the MIT License — see `LICENSE` for details.
